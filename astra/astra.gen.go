// Package astra provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package astra

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

const (
	BearerScopes     = "Bearer.Scopes"
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for CloudProvider.
const (
	CloudProviderAWS   CloudProvider = "AWS"
	CloudProviderAZURE CloudProvider = "AZURE"
	CloudProviderGCP   CloudProvider = "GCP"
)

// Defines values for DatabaseAvailableActions.
const (
	AddDatacenters                 DatabaseAvailableActions = "addDatacenters"
	AddKeyspace                    DatabaseAvailableActions = "addKeyspace"
	AddTable                       DatabaseAvailableActions = "addTable"
	CreateServerlessMigrationProxy DatabaseAvailableActions = "createServerlessMigrationProxy"
	GetCreds                       DatabaseAvailableActions = "getCreds"
	Hibernate                      DatabaseAvailableActions = "hibernate"
	LaunchMigrationProxy           DatabaseAvailableActions = "launchMigrationProxy"
	MigrateServerlessTenant        DatabaseAvailableActions = "migrateServerlessTenant"
	Park                           DatabaseAvailableActions = "park"
	RemoveKeyspace                 DatabaseAvailableActions = "removeKeyspace"
	RemoveMigrationProxy           DatabaseAvailableActions = "removeMigrationProxy"
	RemoveServerlessMigrationProxy DatabaseAvailableActions = "removeServerlessMigrationProxy"
	ResetPassword                  DatabaseAvailableActions = "resetPassword"
	Resize                         DatabaseAvailableActions = "resize"
	Suspend                        DatabaseAvailableActions = "suspend"
	Terminate                      DatabaseAvailableActions = "terminate"
	TerminateDatacenter            DatabaseAvailableActions = "terminateDatacenter"
	Unpark                         DatabaseAvailableActions = "unpark"
)

// Defines values for DatabaseDbType.
const (
	DatabaseDbTypeVector DatabaseDbType = "vector"
)

// Defines values for DatabaseInfoDbType.
const (
	DatabaseInfoDbTypeVector DatabaseInfoDbType = "vector"
)

// Defines values for DatabaseInfoCreateDbType.
const (
	Vector DatabaseInfoCreateDbType = "vector"
)

// Defines values for DatacenterRegionClassification.
const (
	Premium     DatacenterRegionClassification = "premium"
	PremiumPlus DatacenterRegionClassification = "premium_plus"
	Standard    DatacenterRegionClassification = "standard"
)

// Defines values for DatacenterRegionZone.
const (
	Apac DatacenterRegionZone = "apac"
	Emea DatacenterRegionZone = "emea"
	Na   DatacenterRegionZone = "na"
	Sa   DatacenterRegionZone = "sa"
)

// Defines values for PolicyEffect.
const (
	Allow PolicyEffect = "allow"
)

// Defines values for PolicyAction.
const (
	DbAllKeyspaceCreate      PolicyAction = "db-all-keyspace-create"
	DbAllKeyspaceDescribe    PolicyAction = "db-all-keyspace-describe"
	DbCql                    PolicyAction = "db-cql"
	DbGraphql                PolicyAction = "db-graphql"
	DbKeyspaceAlter          PolicyAction = "db-keyspace-alter"
	DbKeyspaceAuthorize      PolicyAction = "db-keyspace-authorize"
	DbKeyspaceCreate         PolicyAction = "db-keyspace-create"
	DbKeyspaceDescribe       PolicyAction = "db-keyspace-describe"
	DbKeyspaceDrop           PolicyAction = "db-keyspace-drop"
	DbKeyspaceGrant          PolicyAction = "db-keyspace-grant"
	DbKeyspaceModify         PolicyAction = "db-keyspace-modify"
	DbRest                   PolicyAction = "db-rest"
	DbTableAlter             PolicyAction = "db-table-alter"
	DbTableAuthorize         PolicyAction = "db-table-authorize"
	DbTableCreate            PolicyAction = "db-table-create"
	DbTableDescribe          PolicyAction = "db-table-describe"
	DbTableDrop              PolicyAction = "db-table-drop"
	DbTableGrant             PolicyAction = "db-table-grant"
	DbTableModify            PolicyAction = "db-table-modify"
	DbTableSelect            PolicyAction = "db-table-select"
	OrgAuditsRead            PolicyAction = "org-audits-read"
	OrgBillingRead           PolicyAction = "org-billing-read"
	OrgBillingWrite          PolicyAction = "org-billing-write"
	OrgDbAddpeering          PolicyAction = "org-db-addpeering"
	OrgDbCreate              PolicyAction = "org-db-create"
	OrgDbExpand              PolicyAction = "org-db-expand"
	OrgDbManagemigratorproxy PolicyAction = "org-db-managemigratorproxy"
	OrgDbPasswordreset       PolicyAction = "org-db-passwordreset"
	OrgDbSuspend             PolicyAction = "org-db-suspend"
	OrgDbTerminate           PolicyAction = "org-db-terminate"
	OrgDbView                PolicyAction = "org-db-view"
	OrgExternalAuthRead      PolicyAction = "org-external-auth-read"
	OrgExternalAuthWrite     PolicyAction = "org-external-auth-write"
	OrgNotificationWrite     PolicyAction = "org-notification-write"
	OrgRead                  PolicyAction = "org-read"
	OrgRoleDelete            PolicyAction = "org-role-delete"
	OrgRoleRead              PolicyAction = "org-role-read"
	OrgRoleWrite             PolicyAction = "org-role-write"
	OrgTokenRead             PolicyAction = "org-token-read"
	OrgTokenWrite            PolicyAction = "org-token-write"
	OrgUserRead              PolicyAction = "org-user-read"
	OrgUserWrite             PolicyAction = "org-user-write"
	OrgWrite                 PolicyAction = "org-write"
)

// Defines values for PrivateLinkEndpointStatus.
const (
	Accepted PrivateLinkEndpointStatus = "Accepted"
	Rejected PrivateLinkEndpointStatus = "Rejected"
)

// Defines values for StatusEnum.
const (
	ACTIVE       StatusEnum = "ACTIVE"
	ERROR        StatusEnum = "ERROR"
	INITIALIZING StatusEnum = "INITIALIZING"
	MAINTENANCE  StatusEnum = "MAINTENANCE"
	PARKED       StatusEnum = "PARKED"
	PARKING      StatusEnum = "PARKING"
	PENDING      StatusEnum = "PENDING"
	PREPARED     StatusEnum = "PREPARED"
	PREPARING    StatusEnum = "PREPARING"
	RESIZING     StatusEnum = "RESIZING"
	SUSPENDED    StatusEnum = "SUSPENDED"
	TERMINATED   StatusEnum = "TERMINATED"
	TERMINATING  StatusEnum = "TERMINATING"
	UNKNOWN      StatusEnum = "UNKNOWN"
	UNPARKING    StatusEnum = "UNPARKING"
)

// Defines values for Tier.
const (
	A10         Tier = "A10"
	A20         Tier = "A20"
	A40         Tier = "A40"
	A5          Tier = "A5"
	C10         Tier = "C10"
	C20         Tier = "C20"
	C40         Tier = "C40"
	Cloudnative Tier = "cloudnative"
	D10         Tier = "D10"
	D20         Tier = "D20"
	D40         Tier = "D40"
	Developer   Tier = "developer"
	Serverless  Tier = "serverless"
)

// Defines values for ListDatabasesParamsInclude.
const (
	ListDatabasesParamsIncludeActive        ListDatabasesParamsInclude = "active"
	ListDatabasesParamsIncludeAll           ListDatabasesParamsInclude = "all"
	ListDatabasesParamsIncludeError         ListDatabasesParamsInclude = "error"
	ListDatabasesParamsIncludeHibernated    ListDatabasesParamsInclude = "hibernated"
	ListDatabasesParamsIncludeHibernating   ListDatabasesParamsInclude = "hibernating"
	ListDatabasesParamsIncludeInitializing  ListDatabasesParamsInclude = "initializing"
	ListDatabasesParamsIncludeMaintenance   ListDatabasesParamsInclude = "maintenance"
	ListDatabasesParamsIncludeNonterminated ListDatabasesParamsInclude = "nonterminated"
	ListDatabasesParamsIncludeParked        ListDatabasesParamsInclude = "parked"
	ListDatabasesParamsIncludeParking       ListDatabasesParamsInclude = "parking"
	ListDatabasesParamsIncludePending       ListDatabasesParamsInclude = "pending"
	ListDatabasesParamsIncludePrepared      ListDatabasesParamsInclude = "prepared"
	ListDatabasesParamsIncludePreparing     ListDatabasesParamsInclude = "preparing"
	ListDatabasesParamsIncludeResizing      ListDatabasesParamsInclude = "resizing"
	ListDatabasesParamsIncludeResuming      ListDatabasesParamsInclude = "resuming"
	ListDatabasesParamsIncludeTerminated    ListDatabasesParamsInclude = "terminated"
	ListDatabasesParamsIncludeTerminating   ListDatabasesParamsInclude = "terminating"
	ListDatabasesParamsIncludeUnparking     ListDatabasesParamsInclude = "unparking"
)

// Defines values for ListDatabasesParamsProvider.
const (
	ListDatabasesParamsProviderALL   ListDatabasesParamsProvider = "ALL"
	ListDatabasesParamsProviderAWS   ListDatabasesParamsProvider = "AWS"
	ListDatabasesParamsProviderAzure ListDatabasesParamsProvider = "Azure"
	ListDatabasesParamsProviderGCP   ListDatabasesParamsProvider = "GCP"
)

// Defines values for DeleteVPCPeeringConnectionParamsProvider.
const (
	DeleteVPCPeeringConnectionParamsProviderAws   DeleteVPCPeeringConnectionParamsProvider = "aws"
	DeleteVPCPeeringConnectionParamsProviderAzure DeleteVPCPeeringConnectionParamsProvider = "azure"
	DeleteVPCPeeringConnectionParamsProviderGcp   DeleteVPCPeeringConnectionParamsProvider = "gcp"
)

// Defines values for GetVPCPeeringConnectionDetailsParamsProvider.
const (
	GetVPCPeeringConnectionDetailsParamsProviderAws   GetVPCPeeringConnectionDetailsParamsProvider = "aws"
	GetVPCPeeringConnectionDetailsParamsProviderAzure GetVPCPeeringConnectionDetailsParamsProvider = "azure"
	GetVPCPeeringConnectionDetailsParamsProviderGcp   GetVPCPeeringConnectionDetailsParamsProvider = "gcp"
)

// Defines values for CreateVPCPeeringConnectionParamsProvider.
const (
	Aws   CreateVPCPeeringConnectionParamsProvider = "aws"
	Azure CreateVPCPeeringConnectionParamsProvider = "azure"
	Gcp   CreateVPCPeeringConnectionParamsProvider = "gcp"
)

// AWSKMS defines model for AWS-KMS.
type AWSKMS struct {
	// KeyID The unique identifier of the customer-key.
	KeyID *string `json:"keyID,omitempty"`

	// Region The region in which the master key exists.
	Region *string `json:"region,omitempty"`
}

// AccessListConfigurations defines model for AccessListConfigurations.
type AccessListConfigurations struct {
	AccessListEnabled bool `json:"accessListEnabled"`
}

// AccessListRequest The model used to build an access list
type AccessListRequest struct {
	// Addresses A listing of the allowed addresses
	Addresses      *[]AddressRequest         `json:"addresses,omitempty"`
	Configurations *AccessListConfigurations `json:"configurations,omitempty"`
}

// AccessListResponse The response for a requested access list
type AccessListResponse struct {
	// Addresses A listing of the allowed addresses
	Addresses      *[]AddressResponse        `json:"addresses,omitempty"`
	Configurations *AccessListConfigurations `json:"configurations,omitempty"`

	// DatabaseId The unique identifier of the database
	DatabaseId *string `json:"databaseId,omitempty"`

	// OrganizationId The unique identifier of the organization
	OrganizationId *string `json:"organizationId,omitempty"`
}

// AddressRequest The model used to build an address for an access list
type AddressRequest struct {
	// Address The address (ip address and subnet mask in CIDR notation) of the address to allow
	Address string `json:"address"`

	// Description Description of this addresses use
	Description string `json:"description"`

	// Enabled The indication if the access address is enabled or not
	Enabled bool `json:"enabled"`
}

// AddressResponse The response for a requested address in an access list
type AddressResponse struct {
	// Address The address (ip address and subnet mask in CIDR notation) of the address to allow
	Address *string `json:"address,omitempty"`

	// Description Description of this addresses use
	Description *string `json:"description,omitempty"`

	// Enabled The indication if the access address is enabled or not
	Enabled *bool `json:"enabled,omitempty"`

	// LastUpdateDateTime The last update date/time for the access list
	LastUpdateDateTime *string `json:"lastUpdateDateTime,omitempty"`
}

// AllowedPrincipals List of principals to do action for private link
type AllowedPrincipals = []string

// AmazonVPC Details about an AWS virtual private cloud
type AmazonVPC struct {
	// AccountId ID of the AWS account the VPC belongs to
	AccountId string `json:"accountId"`

	// CidrBlock The CIDR block available for this VPC
	CidrBlock string `json:"cidrBlock"`

	// Region AWS region the VPC resides in
	Region string `json:"region"`

	// VpcId Unique identifier for the VPC
	VpcId string `json:"vpcId"`
}

// AvailableRegionCombination AvailableRegionCombination defines a Tier, cloud provider, region combination
type AvailableRegionCombination struct {
	CapacityUnitsLimit int `json:"capacityUnitsLimit"`
	CapacityUnitsUsed  int `json:"capacityUnitsUsed"`

	// CloudProvider Cloud hosting provider
	CloudProvider                   CloudProvider `json:"cloudProvider"`
	Cost                            Costs         `json:"cost"`
	DatabaseCountLimit              int           `json:"databaseCountLimit"`
	DatabaseCountUsed               int           `json:"databaseCountUsed"`
	DefaultStoragePerCapacityUnitGb int           `json:"defaultStoragePerCapacityUnitGb"`
	Description                     *string       `json:"description,omitempty"`
	Region                          string        `json:"region"`

	// Tier Tier defines the compute power (vertical scaling) for the database
	Tier Tier `json:"tier"`
}

// AzureVPC Details about an Azure virtual private cloud
type AzureVPC struct {
	// ResourceGroupName Name of the Resource Group the virtual network resides in
	ResourceGroupName string `json:"resourceGroupName"`

	// SubscriptionId ID of the subscription the resource group and virtual network reside in
	SubscriptionId string `json:"subscriptionId"`

	// TenantId ID of the Azure tenant the subscription resides in
	TenantId string `json:"tenantId"`

	// VirtualNetworkName Name of the Virtual Network the peering is connecting to
	VirtualNetworkName string `json:"virtualNetworkName"`
}

// CapacityUnits CapacityUnits is used to horizontally scale a database.
type CapacityUnits struct {
	// CapacityUnits CapacityUnits can be increased by a max of three additional capacity units per operation. Reducing capacity units is not supported at this time
	CapacityUnits *int `json:"capacityUnits,omitempty"`
}

// ClientRole An individual clientID and associated roles
type ClientRole struct {
	// ClientId the clientID
	ClientId *string   `json:"clientId,omitempty"`
	Roles    *[]string `json:"roles,omitempty"`
}

// ClientRoleList The response for a requested token
type ClientRoleList struct {
	// Clients a list of clientId and associated soles
	Clients *[]ClientRole `json:"clients,omitempty"`
}

// CloudProvider Cloud hosting provider
type CloudProvider string

// CloudProviderAccountDetails defines model for CloudProviderAccountDetails.
type CloudProviderAccountDetails struct {
	// OrganizationId The ID of your organization.
	OrganizationId *string `json:"organization_id,omitempty"`

	// Provider The provider, such as aws or gcp.
	Provider *string `json:"provider,omitempty"`

	// ProviderId The ID of the provider's storage account where DataStax stores your data.
	ProviderId *string `json:"provider_id,omitempty"`
}

// Costs defines model for Costs.
type Costs struct {
	CostPerDayCents         *float64 `json:"costPerDayCents,omitempty"`
	CostPerDayParkedCents   *float64 `json:"costPerDayParkedCents,omitempty"`
	CostPerHourCents        *float64 `json:"costPerHourCents,omitempty"`
	CostPerHourParkedCents  *float64 `json:"costPerHourParkedCents,omitempty"`
	CostPerMinCents         *float64 `json:"costPerMinCents,omitempty"`
	CostPerMinParkedCents   *float64 `json:"costPerMinParkedCents,omitempty"`
	CostPerMonthCents       *float64 `json:"costPerMonthCents,omitempty"`
	CostPerMonthParkedCents *float64 `json:"costPerMonthParkedCents,omitempty"`
}

// CreateRoleRequest The createRole model
type CreateRoleRequest struct {
	Name string `json:"name"`

	// Policy A policy for a role in Astra.
	Policy Policy `json:"policy"`
}

// CredsURL CredsURL from which the creds zip may be downloaded
type CredsURL struct {
	// CustomDomainBundles Collection of custom domain bundles
	CustomDomainBundles *CustomDomainBundles `json:"customDomainBundles,omitempty"`

	// DatacenterID Datacenter ID for which the download URL applies
	DatacenterID *string `json:"datacenterID,omitempty"`

	// DatcenterID Intentionally misspelled Datacenter ID for which the download URL applies
	DatcenterID *string `json:"datcenterID,omitempty"`

	// DownloadURL DownloadURL is only valid for about 5 minutes
	DownloadURL string `json:"downloadURL"`

	// DownloadURLInternal Internal DownloadURL is only valid for about 5 minutes
	DownloadURLInternal string `json:"downloadURLInternal"`

	// DownloadURLMigrationProxy Migration Proxy DownloadURL is only valid for about 5 minutes
	DownloadURLMigrationProxy string `json:"downloadURLMigrationProxy"`

	// DownloadURLMigrationProxyInternal Internal Migration Proxy DownloadURL is only valid for about 5 minutes
	DownloadURLMigrationProxyInternal string `json:"downloadURLMigrationProxyInternal"`
}

// CustomDomainBundle Download URL info for creds for a custom domain
type CustomDomainBundle struct {
	// ApiFQDN FQDN for the API
	ApiFQDN string `json:"apiFQDN"`

	// CqlFQDN FQDN for CQL
	CqlFQDN string `json:"cqlFQDN"`

	// DashboardFQDN FQDN for Dashboard
	DashboardFQDN string `json:"dashboardFQDN"`

	// Domain Custom domain
	Domain string `json:"domain"`

	// DownloadURL Download URL for the secure connect bundle for this custom domain
	DownloadURL string `json:"downloadURL"`
}

// CustomDomainBundles Collection of custom domain bundles
type CustomDomainBundles = []CustomDomainBundle

// Database Database contains the key information about a database
type Database struct {
	AvailableActions *[]DatabaseAvailableActions `json:"availableActions,omitempty"`
	CqlshUrl         *string                     `json:"cqlshUrl,omitempty"`

	// CreationTime CreationTime in ISO RFC3339 format
	CreationTime    *string         `json:"creationTime,omitempty"`
	DataEndpointUrl *string         `json:"dataEndpointUrl,omitempty"`
	DbType          *DatabaseDbType `json:"dbType,omitempty"`
	GrafanaUrl      *string         `json:"grafanaUrl,omitempty"`
	GraphqlUrl      *string         `json:"graphqlUrl,omitempty"`
	Id              string          `json:"id"`

	// Info DatabaseInfo is the user-provided information describing a database
	Info DatabaseInfo `json:"info"`

	// Message Message to the customer about the cluster
	Message *string    `json:"message,omitempty"`
	OrgId   string     `json:"orgId"`
	OwnerId string     `json:"ownerId"`
	Status  StatusEnum `json:"status"`

	// Storage Storage contains the information about how much storage space a cluster has available
	Storage   *Storage `json:"storage,omitempty"`
	StudioUrl *string  `json:"studioUrl,omitempty"`

	// TerminationTime TerminationTime in ISO RFC3339 format
	TerminationTime *string `json:"terminationTime,omitempty"`
}

// DatabaseAvailableActions defines model for Database.AvailableActions.
type DatabaseAvailableActions string

// DatabaseDbType defines model for Database.DbType.
type DatabaseDbType string

// DatabaseInfo DatabaseInfo is the user-provided information describing a database
type DatabaseInfo struct {
	// AdditionalKeyspaces Additional keyspaces names in database
	AdditionalKeyspaces *[]string `json:"additionalKeyspaces,omitempty"`

	// CapacityUnits CapacityUnits is the amount of space available (horizontal scaling) for the database. For free tier the max CU's is 1, and 12 for C10 the max is 12 on startup.
	CapacityUnits *int `json:"capacityUnits,omitempty"`

	// CloudProvider Cloud hosting provider
	CloudProvider *CloudProvider      `json:"cloudProvider,omitempty"`
	Datacenters   *[]Datacenter       `json:"datacenters,omitempty"`
	DbType        *DatabaseInfoDbType `json:"dbType,omitempty"`

	// Keyspace Keyspace name in database
	Keyspace *string `json:"keyspace,omitempty"`

	// Name Name of the database--user friendly identifier
	Name *string `json:"name,omitempty"`

	// Password Password for the user to access the database
	Password *string `json:"password,omitempty"`

	// Region Region refers to the cloud region.
	Region *string `json:"region,omitempty"`

	// Tier Tier defines the compute power (vertical scaling) for the database
	Tier *Tier `json:"tier,omitempty"`

	// User User is the user to access the database
	User *string `json:"user,omitempty"`
}

// DatabaseInfoDbType defines model for DatabaseInfo.DbType.
type DatabaseInfoDbType string

// DatabaseInfoCreate DatabaseInfo is the user-provided information describing a database
type DatabaseInfoCreate struct {
	// CapacityUnits CapacityUnits is the amount of space available (horizontal scaling) for the database. For free tier the max CU's is 1, and 100 for CXX/DXX the max is 12 on startup.
	CapacityUnits int `json:"capacityUnits"`

	// CloudProvider Cloud hosting provider
	CloudProvider CloudProvider             `json:"cloudProvider"`
	DbType        *DatabaseInfoCreateDbType `json:"dbType,omitempty"`

	// Keyspace Keyspace name in database
	Keyspace *string `json:"keyspace,omitempty"`

	// Name Name of the database--user friendly identifier
	Name string `json:"name"`

	// Password Password for the user to access the database
	Password *string `json:"password,omitempty"`

	// Region Region refers to the cloud region.
	Region string `json:"region"`

	// Tier Tier defines the compute power (vertical scaling) for the database
	Tier Tier `json:"tier"`

	// User User is the user to access the database
	User *string `json:"user,omitempty"`
}

// DatabaseInfoCreateDbType defines model for DatabaseInfoCreate.DbType.
type DatabaseInfoCreateDbType string

// Datacenter Datacenter is the definition of a cassandra datacenter
type Datacenter struct {
	// CapacityUnits CapacityUnits is the amount of space available (horizontal scaling) for the database
	CapacityUnits *int `json:"capacityUnits,omitempty"`

	// CloudProvider Cloud hosting provider
	CloudProvider                         CloudProvider                   `json:"cloudProvider"`
	CqlshUrl                              *string                         `json:"cqlshUrl,omitempty"`
	DataEndpointUrl                       *string                         `json:"dataEndpointUrl,omitempty"`
	GrafanaUrl                            *string                         `json:"grafanaUrl,omitempty"`
	GraphqlUrl                            *string                         `json:"graphqlUrl,omitempty"`
	Id                                    *string                         `json:"id,omitempty"`
	Name                                  *string                         `json:"name,omitempty"`
	Region                                string                          `json:"region"`
	RegionClassification                  *DatacenterRegionClassification `json:"regionClassification,omitempty"`
	RegionZone                            *DatacenterRegionZone           `json:"regionZone,omitempty"`
	SecureBundleInternalUrl               *string                         `json:"secureBundleInternalUrl,omitempty"`
	SecureBundleMigrationProxyInternalUrl *string                         `json:"secureBundleMigrationProxyInternalUrl,omitempty"`
	SecureBundleMigrationProxyUrl         *string                         `json:"secureBundleMigrationProxyUrl,omitempty"`
	SecureBundleUrl                       *string                         `json:"secureBundleUrl,omitempty"`
	Status                                string                          `json:"status"`
	StudioUrl                             *string                         `json:"studioUrl,omitempty"`

	// Tier Tier defines the compute power (vertical scaling) for the database
	Tier Tier `json:"tier"`
}

// DatacenterRegionClassification defines model for Datacenter.RegionClassification.
type DatacenterRegionClassification string

// DatacenterRegionZone defines model for Datacenter.RegionZone.
type DatacenterRegionZone string

// Error ModelError information that is returned to users
type Error struct {
	// ID API specific error code
	ID *int `json:"ID,omitempty"`

	// Message User-friendly description of error
	Message string `json:"message"`
}

// Errors Errors is a collection of individual Error objects
type Errors struct {
	Errors []Error `json:"errors"`
}

// ExternalKMS defines model for ExternalKMS.
type ExternalKMS struct {
	Aws *AWSKMS `json:"aws,omitempty"`
	Gcp *GCPKMS `json:"gcp,omitempty"`

	// OrgId The unique identifier for the organization.
	OrgId *string `json:"orgId,omitempty"`
}

// ExternalKMSResponse defines model for ExternalKMSResponse.
type ExternalKMSResponse struct {
	// CloudProvider The cloud provider, such as aws or gcp.
	CloudProvider *string `json:"CloudProvider,omitempty"`

	// KeyID The ID of the Customer Key.
	KeyID *string `json:"KeyID,omitempty"`

	// OrganizationID The ID of your organization.
	OrganizationID *string `json:"OrganizationID,omitempty"`

	// Region The region in which the Customer Key is used.
	Region *string `json:"Region,omitempty"`
}

// GCPKMS defines model for GCP-KMS.
type GCPKMS struct {
	// KeyID The KMS key version resource id for encryption operations.
	KeyID *string `json:"keyID,omitempty"`

	// Region The region in which the key exists.
	Region *string `json:"region,omitempty"`
}

// GenerateTokenBody The post body to generate a token
type GenerateTokenBody struct {
	// Roles The roles for which the token will be generated
	Roles []string `json:"roles"`
}

// GenerateTokenResponse The response for a requested token
type GenerateTokenResponse struct {
	// ClientId The id of the client (uuid)
	ClientId string `json:"clientId"`

	// OrgId the UUID of the organization
	OrgId string `json:"orgId"`

	// Roles The roles for which the token will be generated
	Roles []string `json:"roles"`

	// Secret The secret token
	Secret string `json:"secret"`

	// Token AstraCS:clientId:hex(sha256(secret))
	Token *string `json:"token,omitempty"`
}

// GetAllCustomerKeys List of Customer Keys in an organization
type GetAllCustomerKeys = []ExternalKMSResponse

// GetCloudProviderAccounts List of Cloud provider accounts in an organization for a cloud-provider & region combination
type GetCloudProviderAccounts = []CloudProviderAccountDetails

// GetParticularCustomerKey Retrieves a Customer Key for the specified provider and region combination
type GetParticularCustomerKey struct {
	Aws *struct {
		KeyID  *string `json:"keyID,omitempty"`
		Region *string `json:"region,omitempty"`
	} `json:"aws,omitempty"`
	OrgId *string `json:"orgId,omitempty"`
}

// GoogleVPC Details about a GCP virtual private cloud
type GoogleVPC struct {
	// ProjectId ID of the GPC project the VPC belongs to
	ProjectId string `json:"projectId"`

	// VpcNetworkName Unique identifier for the VPC
	VpcNetworkName string `json:"vpcNetworkName"`
}

// KafkaBootstrapServer Kafka bootstrap server
type KafkaBootstrapServer = string

// MetricsRequest Metrics Config
type MetricsRequest struct {
	KafkaBootstrapServers *[]KafkaBootstrapServer `json:"kafka_bootstrap_servers,omitempty"`

	// KafkaSaslMechanism Kafka SASL mechanism
	KafkaSaslMechanism *string `json:"kafka_sasl_mechanism,omitempty"`

	// KafkaSaslPassword kafka password
	KafkaSaslPassword *string `json:"kafka_sasl_password,omitempty"`

	// KafkaSaslUsername kafka username
	KafkaSaslUsername *string `json:"kafka_sasl_username,omitempty"`

	// KafkaTopic kafka topic name
	KafkaTopic *string `json:"kafka_topic,omitempty"`

	// PromEndpoint ip address or dns for prometheus endpoint
	PromEndpoint *string `json:"prom_endpoint,omitempty"`

	// PromPassword prometheus password (only pass if basic strategy was selected)
	PromPassword *string `json:"prom_password,omitempty"`

	// PromStrategy either basic or bearer depending on your prom remote_write auth
	PromStrategy *string `json:"prom_strategy,omitempty"`

	// PromToken prometheus bearer token, only pass if using bearer strategy
	PromToken *string `json:"prom_token,omitempty"`

	// PromUser prometheus username only pass with basic strategy
	PromUser *string `json:"prom_user,omitempty"`
}

// MigrationProxyConfiguration Configuration of the migration proxy and mappings of astra node to a customer node currently in use
type MigrationProxyConfiguration struct {
	Mappings []MigrationProxyMapping `json:"mappings"`

	// OriginPassword origin cassandra password
	OriginPassword string `json:"originPassword"`

	// OriginUsername origin cassandra username
	OriginUsername string `json:"originUsername"`
}

// MigrationProxyMapping A mapping of astra node to a customer node currently in use
type MigrationProxyMapping struct {
	// OriginIP ip on which the node currently in use is accessible
	OriginIP string `json:"originIP"`

	// OriginPort port on which the node currently in use is accessible
	OriginPort int `json:"originPort"`

	// Rack the number of the rack, usually 0, 1, or 2
	Rack int `json:"rack"`

	// RackNodeOrdinal The number of the node in a given rack, starting with 0
	RackNodeOrdinal int `json:"rackNodeOrdinal"`
}

// Organization An organization
type Organization struct {
	// Id The organization UUID
	Id string `json:"id"`
}

// OrganizationUsers defines model for OrganizationUsers.
type OrganizationUsers struct {
	OrgID   string `json:"orgID"`
	OrgName string `json:"orgName"`

	// Users an array of users in the organization
	Users []UserResponse `json:"users"`
}

// Policy A policy for a role in Astra.
type Policy struct {
	// Actions The actions this policy can take. Example Actions: 'org-billing-write' 'db-keyspace-create'
	Actions []PolicyAction `json:"actions"`

	// Description A description of this policy
	Description string `json:"description"`

	// Effect Effect this policy will have on the provided resource
	Effect PolicyEffect `json:"effect"`

	// Resources The resources this policy can manipulate.
	Resources []string `json:"resources"`
}

// PolicyEffect Effect this policy will have on the provided resource
type PolicyEffect string

// PolicyAction Actions permitted by a Policy
type PolicyAction string

// PrivateLinkClusterOutput defines model for PrivateLinkClusterOutput.
type PrivateLinkClusterOutput struct {
	// ClusterID Cluster ID for all private links connected to the cluster's datacenters
	ClusterID *string `json:"clusterID,omitempty"`

	// Datacenters List of endpoints for a datacenter
	Datacenters *[]PrivateLinkDatacenterOutput `json:"datacenters,omitempty"`
}

// PrivateLinkCreateConfigInput defines model for PrivateLinkCreateConfigInput.
type PrivateLinkCreateConfigInput struct {
	// AllowedPrincipals List of principals to do action for private link
	AllowedPrincipals *AllowedPrincipals `json:"allowedPrincipals,omitempty"`
}

// PrivateLinkCreateConfigOutput defines model for PrivateLinkCreateConfigOutput.
type PrivateLinkCreateConfigOutput struct {
	// AllowedPrincipals List of principals to do action for private link
	AllowedPrincipals *AllowedPrincipals `json:"allowedPrincipals,omitempty"`

	// ServiceName The given endpoint service for the user to connect to
	ServiceName *ServiceName `json:"serviceName,omitempty"`
}

// PrivateLinkCreateEndpointInput defines model for PrivateLinkCreateEndpointInput.
type PrivateLinkCreateEndpointInput struct {
	// Description The human readable description of the endpoint
	Description *string `json:"description,omitempty"`

	// EndpointID The user's endpoint created in their cloud provider account
	EndpointID *string `json:"endpointID,omitempty"`
}

// PrivateLinkDatacenterOutput defines model for PrivateLinkDatacenterOutput.
type PrivateLinkDatacenterOutput struct {
	// AllowedPrincipals List of principals to do action for private link
	AllowedPrincipals *AllowedPrincipals `json:"allowedPrincipals,omitempty"`

	// DatacenterID Datacenter ID for the private link endpoint
	DatacenterID *string `json:"datacenterID,omitempty"`

	// Endpoints List of endpoints associated with the given org-cluster-dc combo
	Endpoints *[]PrivateLinkEndpoint `json:"endpoints,omitempty"`

	// ServiceName The given endpoint service for the user to connect to
	ServiceName *ServiceName `json:"serviceName,omitempty"`
}

// PrivateLinkDeleteConfigInput defines model for PrivateLinkDeleteConfigInput.
type PrivateLinkDeleteConfigInput struct {
	// AllowedPrincipal The allowed-principal
	AllowedPrincipal *string `json:"allowedPrincipal,omitempty"`
}

// PrivateLinkEndpoint defines model for PrivateLinkEndpoint.
type PrivateLinkEndpoint struct {
	// CreatedDateTime The datetime that the private link connection was created
	CreatedDateTime *string `json:"createdDateTime,omitempty"`

	// Description User defined description of the endpoint
	Description *string `json:"description,omitempty"`

	// EndpointID Endpoint ID of the user side private link
	EndpointID *string `json:"endpointID,omitempty"`

	// LinkID Link ID for the private link service and endpoint connection
	LinkID *string `json:"linkID,omitempty"`

	// Status The current status of the connection
	Status *PrivateLinkEndpointStatus `json:"status,omitempty"`
}

// PrivateLinkEndpointStatus The current status of the connection
type PrivateLinkEndpointStatus string

// PrivateLinkOrgOutput defines model for PrivateLinkOrgOutput.
type PrivateLinkOrgOutput struct {
	// Clusters List of endpoints for a cluster
	Clusters *[]PrivateLinkClusterOutput `json:"clusters,omitempty"`
}

// PrivateLinkUpdateEndpointInput defines model for PrivateLinkUpdateEndpointInput.
type PrivateLinkUpdateEndpointInput struct {
	// Description User defined description of the endpoint
	Description *string `json:"description,omitempty"`
}

// Role Details of a user role and its policy details
type Role struct {
	// Id The unique system generated identifier of the role.
	Id *string `json:"id,omitempty"`

	// LastUpdateDatetime The date and time of the last update on the role.
	LastUpdateDatetime *time.Time `json:"last_update_datetime,omitempty"`

	// LastUpdateUserid The userID of the user who last updated the role.
	LastUpdateUserid *string `json:"last_update_userid,omitempty"`

	// Name The name of the role.
	Name *string `json:"name,omitempty"`

	// Policy A policy for a role in Astra.
	Policy *Policy `json:"policy,omitempty"`
}

// RoleInviteRequest The roleInvite model
type RoleInviteRequest struct {
	Roles []string `json:"roles"`
}

// SecureBundles List of Secure Connection Bundle info
type SecureBundles = []CredsURL

// ServerlessRegion Serverless region information
type ServerlessRegion struct {
	Classification string `json:"classification"`

	// CloudProvider Cloud hosting provider
	CloudProvider             CloudProvider `json:"cloudProvider"`
	DisplayName               string        `json:"displayName"`
	Enabled                   *bool         `json:"enabled,omitempty"`
	Name                      string        `json:"name"`
	RegionType                *string       `json:"region_type,omitempty"`
	ReservedForQualifiedUsers *bool         `json:"reservedForQualifiedUsers,omitempty"`
	Zone                      string        `json:"zone"`
}

// ServiceAccountTokenInput defines model for ServiceAccountTokenInput.
type ServiceAccountTokenInput struct {
	// ClientId The unique identifier for the client for authentication
	ClientId string `json:"clientId"`

	// ClientName The organization name in a more human readable format
	ClientName string `json:"clientName"`

	// ClientSecret The UUID client secret for the service account from the create service account response in the user interface
	ClientSecret string `json:"clientSecret"`
}

// ServiceAccountTokenResponse defines model for ServiceAccountTokenResponse.
type ServiceAccountTokenResponse struct {
	// Token JWT that will be used as Authorization header on all requests requiring authentication.
	Token *string `json:"token,omitempty"`
}

// ServiceName The given endpoint service for the user to connect to
type ServiceName = string

// StatusEnum defines model for StatusEnum.
type StatusEnum string

// Storage Storage contains the information about how much storage space a cluster has available
type Storage struct {
	// NodeCount NodeCount for the cluster
	NodeCount int `json:"nodeCount"`

	// ReplicationFactor ReplicationFactor is the number of nodes storing a piece of data
	ReplicationFactor int `json:"replicationFactor"`

	// TotalStorage TotalStorage of the cluster in GB
	TotalStorage int `json:"totalStorage"`

	// UsedStorage UsedStorage in GB
	UsedStorage *int `json:"usedStorage,omitempty"`
}

// Tier Tier defines the compute power (vertical scaling) for the database
type Tier string

// UpdateRoleRequest The updateRole model
type UpdateRoleRequest struct {
	Name string `json:"name"`

	// Policy A policy for a role in Astra.
	Policy Policy `json:"policy"`
}

// UserInvite The userInvite model
type UserInvite struct {
	// Email The email of the user being invited
	Email string `json:"email"`

	// OrgID The unique system generated identifier of the organization
	OrgID string   `json:"orgID"`
	Roles []string `json:"roles"`
}

// UserPassword UserPassword specifies a username and new password. The specified password will be updated for the specified database user
type UserPassword struct {
	// Password New password (min 6 characters)
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UserResponse defines model for UserResponse.
type UserResponse struct {
	Email *string `json:"email,omitempty"`

	// Roles an array of roles the user belongs to for an organization
	Roles *[]Role `json:"roles,omitempty"`

	// Status The status of a user within an organization either active or invited
	Status *string `json:"status,omitempty"`
	UserID string  `json:"userID"`
}

// VPC Details about a virtual private cloud
type VPC struct {
	// Account Account (AWS), Project (GCP) or Subscription (Azure) the VPC belongs to
	Account string `json:"account"`

	// CidrBlock The CIDR block available for this VPC
	CidrBlock string `json:"cidrBlock"`

	// Provider Cloud provider the VPC is hosted on
	Provider string `json:"provider"`

	// VpcId The VPC's unique identifier
	VpcId string `json:"vpcId"`
}

// VPCConnection A VPC peering connection with an Astra database
type VPCConnection struct {
	// ConnectionId A unique identifier for the peering connection
	ConnectionId string `json:"connectionId"`

	// CurrentVpc Details about a virtual private cloud
	CurrentVpc VPC `json:"currentVpc"`

	// OtherVpc Details about a virtual private cloud
	OtherVpc VPC `json:"otherVpc"`

	// Status The current status of the connection
	Status string `json:"status"`
}

// ValidationResponse The response for validation checks
type ValidationResponse struct {
	Valid              *bool     `json:"valid,omitempty"`
	ValidationFailures *[]string `json:"validationFailures,omitempty"`
}

// AddressesQueryParam defines model for AddressesQueryParam.
type AddressesQueryParam = []string

// ClientIdParam defines model for ClientIdParam.
type ClientIdParam = string

// DatabaseIdParam defines model for DatabaseIdParam.
type DatabaseIdParam = string

// DatacenterIdParam defines model for DatacenterIdParam.
type DatacenterIdParam = string

// KeyspaceNameParam defines model for KeyspaceNameParam.
type KeyspaceNameParam = string

// RoleIdParam defines model for RoleIdParam.
type RoleIdParam = string

// UserIdParam defines model for UserIdParam.
type UserIdParam = string

// BadRequest Errors is a collection of individual Error objects
type BadRequest = Errors

// Conflict Errors is a collection of individual Error objects
type Conflict = Errors

// CustomNotFound defines model for CustomNotFound.
type CustomNotFound = string

// Forbidden Errors is a collection of individual Error objects
type Forbidden = Errors

// NotFound Errors is a collection of individual Error objects
type NotFound = Errors

// ServerError Errors is a collection of individual Error objects
type ServerError = Errors

// Unauthorized Errors is a collection of individual Error objects
type Unauthorized = Errors

// UnprocessableEntity Errors is a collection of individual Error objects
type UnprocessableEntity = Errors

// ListDatabasesParams defines parameters for ListDatabases.
type ListDatabasesParams struct {
	// Include Allows filtering so that databases in listed states are returned
	Include *ListDatabasesParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Provider Allows filtering so that databases from a given provider are returned.
	Provider *ListDatabasesParamsProvider `form:"provider,omitempty" json:"provider,omitempty"`

	// StartingAfter Optional parameter for pagination purposes. Used as this value for starting retrieving a specific page of results.
	StartingAfter *string `form:"starting_after,omitempty" json:"starting_after,omitempty"`

	// Limit Optional parameter for pagination purposes. Specify the number of items for one page of data
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ListDatabasesParamsInclude defines parameters for ListDatabases.
type ListDatabasesParamsInclude string

// ListDatabasesParamsProvider defines parameters for ListDatabases.
type ListDatabasesParamsProvider string

// DeleteAddressesOrAccessListForDatabaseParams defines parameters for DeleteAddressesOrAccessListForDatabase.
type DeleteAddressesOrAccessListForDatabaseParams struct {
	// Addresses Array of addresses
	Addresses *AddressesQueryParam `form:"addresses,omitempty" json:"addresses,omitempty"`
}

// AddAddressesToAccessListForDatabaseJSONBody defines parameters for AddAddressesToAccessListForDatabase.
type AddAddressesToAccessListForDatabaseJSONBody = []AddressRequest

// ListDatacentersParams defines parameters for ListDatacenters.
type ListDatacentersParams struct {
	// All Allows retrieving datacenters in TERMINATED state along with ACTIVE ones
	All *bool `form:"all,omitempty" json:"all,omitempty"`
}

// AddDatacentersJSONBody defines parameters for AddDatacenters.
type AddDatacentersJSONBody = []Datacenter

// GenerateSecureBundleURLParams defines parameters for GenerateSecureBundleURL.
type GenerateSecureBundleURLParams struct {
	// All Fetch bundles for all datacenters.
	All *bool `form:"all,omitempty" json:"all,omitempty"`
}

// TerminateDatabaseParams defines parameters for TerminateDatabase.
type TerminateDatabaseParams struct {
	// PreparedStateOnly For internal use only.  Used to safely terminate prepared databases.
	PreparedStateOnly *bool `form:"preparedStateOnly,omitempty" json:"preparedStateOnly,omitempty"`
}

// DeleteVPCPeeringConnectionParamsProvider defines parameters for DeleteVPCPeeringConnection.
type DeleteVPCPeeringConnectionParamsProvider string

// GetVPCPeeringConnectionDetailsParamsProvider defines parameters for GetVPCPeeringConnectionDetails.
type GetVPCPeeringConnectionDetailsParamsProvider string

// CreateVPCPeeringConnectionJSONBody defines parameters for CreateVPCPeeringConnection.
type CreateVPCPeeringConnectionJSONBody struct {
	union json.RawMessage
}

// CreateVPCPeeringConnectionParamsProvider defines parameters for CreateVPCPeeringConnection.
type CreateVPCPeeringConnectionParamsProvider string

// ListServerlessRegionsParams defines parameters for ListServerlessRegions.
type ListServerlessRegionsParams struct {
	// RegionType Allows retrieving regions by type (serverless, vector or all)
	RegionType *string `form:"region-type,omitempty" json:"region-type,omitempty"`

	// FilterByOrg Allows retrieving regions filtered by organization ID
	FilterByOrg *string `form:"filter-by-org,omitempty" json:"filter-by-org,omitempty"`
}

// AuthenticateServiceAccountTokenJSONRequestBody defines body for AuthenticateServiceAccountToken for application/json ContentType.
type AuthenticateServiceAccountTokenJSONRequestBody = ServiceAccountTokenInput

// GenerateTokenForClientJSONRequestBody defines body for GenerateTokenForClient for application/json ContentType.
type GenerateTokenForClientJSONRequestBody = GenerateTokenBody

// CreateDatabaseJSONRequestBody defines body for CreateDatabase for application/json ContentType.
type CreateDatabaseJSONRequestBody = DatabaseInfoCreate

// UpdateAccessListForDatabaseJSONRequestBody defines body for UpdateAccessListForDatabase for application/json ContentType.
type UpdateAccessListForDatabaseJSONRequestBody = AccessListRequest

// AddAddressesToAccessListForDatabaseJSONRequestBody defines body for AddAddressesToAccessListForDatabase for application/json ContentType.
type AddAddressesToAccessListForDatabaseJSONRequestBody = AddAddressesToAccessListForDatabaseJSONBody

// UpsertAccessListForDatabaseJSONRequestBody defines body for UpsertAccessListForDatabase for application/json ContentType.
type UpsertAccessListForDatabaseJSONRequestBody = AccessListRequest

// AddDatacentersJSONRequestBody defines body for AddDatacenters for application/json ContentType.
type AddDatacentersJSONRequestBody = AddDatacentersJSONBody

// LaunchMigrationProxyJSONRequestBody defines body for LaunchMigrationProxy for application/json ContentType.
type LaunchMigrationProxyJSONRequestBody = MigrationProxyConfiguration

// ResetPasswordJSONRequestBody defines body for ResetPassword for application/json ContentType.
type ResetPasswordJSONRequestBody = UserPassword

// ResizeDatabaseJSONRequestBody defines body for ResizeDatabase for application/json ContentType.
type ResizeDatabaseJSONRequestBody = CapacityUnits

// ConfigureMetricsExportJSONRequestBody defines body for ConfigureMetricsExport for application/json ContentType.
type ConfigureMetricsExportJSONRequestBody = MetricsRequest

// CreateKeyJSONRequestBody defines body for CreateKey for application/json ContentType.
type CreateKeyJSONRequestBody = ExternalKMS

// RemoveAllowedPrincipalFromServiceJSONRequestBody defines body for RemoveAllowedPrincipalFromService for application/json ContentType.
type RemoveAllowedPrincipalFromServiceJSONRequestBody = PrivateLinkDeleteConfigInput

// AddAllowedPrincipalJSONRequestBody defines body for AddAllowedPrincipal for application/json ContentType.
type AddAllowedPrincipalJSONRequestBody = PrivateLinkCreateConfigInput

// AcceptEndpointToServiceJSONRequestBody defines body for AcceptEndpointToService for application/json ContentType.
type AcceptEndpointToServiceJSONRequestBody = PrivateLinkCreateEndpointInput

// UpdateEndpointDescriptionJSONRequestBody defines body for UpdateEndpointDescription for application/json ContentType.
type UpdateEndpointDescriptionJSONRequestBody = PrivateLinkUpdateEndpointInput

// AddAllowedPrincipalToServiceJSONRequestBody defines body for AddAllowedPrincipalToService for application/json ContentType.
type AddAllowedPrincipalToServiceJSONRequestBody = PrivateLinkCreateConfigInput

// AddOrganizationRoleJSONRequestBody defines body for AddOrganizationRole for application/json ContentType.
type AddOrganizationRoleJSONRequestBody = CreateRoleRequest

// UpdateRoleJSONRequestBody defines body for UpdateRole for application/json ContentType.
type UpdateRoleJSONRequestBody = UpdateRoleRequest

// InviteUserToOrganizationJSONRequestBody defines body for InviteUserToOrganization for application/json ContentType.
type InviteUserToOrganizationJSONRequestBody = UserInvite

// UpdateRolesForUserInOrganizationJSONRequestBody defines body for UpdateRolesForUserInOrganization for application/json ContentType.
type UpdateRolesForUserInOrganizationJSONRequestBody = RoleInviteRequest

// CreateVPCPeeringConnectionJSONRequestBody defines body for CreateVPCPeeringConnection for application/json ContentType.
type CreateVPCPeeringConnectionJSONRequestBody CreateVPCPeeringConnectionJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAccessListTemplate request
	GetAccessListTemplate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateAccessList request
	ValidateAccessList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllAccessListsForOrganization request
	GetAllAccessListsForOrganization(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthenticateServiceAccountToken request with any body
	AuthenticateServiceAccountTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthenticateServiceAccountToken(ctx context.Context, body AuthenticateServiceAccountTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAvailableRegions request
	ListAvailableRegions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientsForOrg request
	GetClientsForOrg(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateTokenForClient request with any body
	GenerateTokenForClientWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateTokenForClient(ctx context.Context, body GenerateTokenForClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTokenForClient request
	DeleteTokenForClient(ctx context.Context, clientId ClientIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentOrganization request
	GetCurrentOrganization(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDatabases request
	ListDatabases(ctx context.Context, params *ListDatabasesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDatabase request with any body
	CreateDatabaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDatabase(ctx context.Context, body CreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatabase request
	GetDatabase(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAddressesOrAccessListForDatabase request
	DeleteAddressesOrAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, params *DeleteAddressesOrAccessListForDatabaseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccessListForDatabase request
	GetAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAccessListForDatabase request with any body
	UpdateAccessListForDatabaseWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, body UpdateAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddAddressesToAccessListForDatabase request with any body
	AddAddressesToAccessListForDatabaseWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddAddressesToAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, body AddAddressesToAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertAccessListForDatabase request with any body
	UpsertAccessListForDatabaseWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, body UpsertAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDatacenters request
	ListDatacenters(ctx context.Context, databaseId DatabaseIdParam, params *ListDatacentersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddDatacenters request with any body
	AddDatacentersWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddDatacenters(ctx context.Context, databaseId DatabaseIdParam, body AddDatacentersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TerminateDatacenter request
	TerminateDatacenter(ctx context.Context, databaseId DatabaseIdParam, datacenterId DatacenterIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DropKeyspace request
	DropKeyspace(ctx context.Context, databaseId DatabaseIdParam, keyspaceName KeyspaceNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddKeyspace request
	AddKeyspace(ctx context.Context, databaseId DatabaseIdParam, keyspaceName KeyspaceNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveMigrationProxy request
	RemoveMigrationProxy(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LaunchMigrationProxy request with any body
	LaunchMigrationProxyWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LaunchMigrationProxy(ctx context.Context, databaseId DatabaseIdParam, body LaunchMigrationProxyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ParkDatabase request
	ParkDatabase(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetPassword request with any body
	ResetPasswordWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResetPassword(ctx context.Context, databaseId DatabaseIdParam, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResizeDatabase request with any body
	ResizeDatabaseWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResizeDatabase(ctx context.Context, databaseId DatabaseIdParam, body ResizeDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateSecureBundleURL request
	GenerateSecureBundleURL(ctx context.Context, databaseId DatabaseIdParam, params *GenerateSecureBundleURLParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TerminateDatabase request
	TerminateDatabase(ctx context.Context, databaseId DatabaseIdParam, params *TerminateDatabaseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfigureMetricsExport request with any body
	ConfigureMetricsExportWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConfigureMetricsExport(ctx context.Context, databaseId DatabaseIdParam, body ConfigureMetricsExportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnparkDatabase request
	UnparkDatabase(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListKeys request
	ListKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKey request with any body
	CreateKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateKey(ctx context.Context, body CreateKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerlessKey request
	GetServerlessKey(ctx context.Context, provider string, region string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCloudAccounts request
	GetCloudAccounts(ctx context.Context, provider string, region string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveAllowedPrincipalFromService request with any body
	RemoveAllowedPrincipalFromServiceWithBody(ctx context.Context, clusterID string, datacenterID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveAllowedPrincipalFromService(ctx context.Context, clusterID string, datacenterID string, body RemoveAllowedPrincipalFromServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddAllowedPrincipal request with any body
	AddAllowedPrincipalWithBody(ctx context.Context, clusterID string, datacenterID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddAllowedPrincipal(ctx context.Context, clusterID string, datacenterID string, body AddAllowedPrincipalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AcceptEndpointToService request with any body
	AcceptEndpointToServiceWithBody(ctx context.Context, clusterID string, datacenterID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AcceptEndpointToService(ctx context.Context, clusterID string, datacenterID string, body AcceptEndpointToServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RejectEndpoint request
	RejectEndpoint(ctx context.Context, clusterID string, datacenterID string, endpointID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPrivateLinkEndpoint request
	GetPrivateLinkEndpoint(ctx context.Context, clusterID string, datacenterID string, endpointID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEndpointDescription request with any body
	UpdateEndpointDescriptionWithBody(ctx context.Context, clusterID string, datacenterID string, endpointID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEndpointDescription(ctx context.Context, clusterID string, datacenterID string, endpointID string, body UpdateEndpointDescriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPrivateLinksForDatacenter request
	GetPrivateLinksForDatacenter(ctx context.Context, clusterID string, datacenterID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddAllowedPrincipalToService request with any body
	AddAllowedPrincipalToServiceWithBody(ctx context.Context, clusterID string, datacenterID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddAllowedPrincipalToService(ctx context.Context, clusterID string, datacenterID string, body AddAllowedPrincipalToServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPrivateLinksForCluster request
	ListPrivateLinksForCluster(ctx context.Context, clusterID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPrivateLinksForOrg request
	ListPrivateLinksForOrg(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationRoles request
	GetOrganizationRoles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddOrganizationRole request with any body
	AddOrganizationRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddOrganizationRole(ctx context.Context, body AddOrganizationRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOrganizationRole request
	DeleteOrganizationRole(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationRole request
	GetOrganizationRole(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRole request with any body
	UpdateRoleWithBody(ctx context.Context, roleID RoleIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRole(ctx context.Context, roleID RoleIdParam, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationUsers request
	GetOrganizationUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InviteUserToOrganization request with any body
	InviteUserToOrganizationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InviteUserToOrganization(ctx context.Context, body InviteUserToOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveUserFromOrganization request
	RemoveUserFromOrganization(ctx context.Context, userID UserIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationUser request
	GetOrganizationUser(ctx context.Context, userID UserIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRolesForUserInOrganization request with any body
	UpdateRolesForUserInOrganizationWithBody(ctx context.Context, userID UserIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRolesForUserInOrganization(ctx context.Context, userID UserIdParam, body UpdateRolesForUserInOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVPCPeeringConnection request
	DeleteVPCPeeringConnection(ctx context.Context, provider DeleteVPCPeeringConnectionParamsProvider, databaseID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVPCPeeringConnectionDetails request
	GetVPCPeeringConnectionDetails(ctx context.Context, provider GetVPCPeeringConnectionDetailsParamsProvider, databaseID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVPCPeeringConnection request with any body
	CreateVPCPeeringConnectionWithBody(ctx context.Context, provider CreateVPCPeeringConnectionParamsProvider, databaseID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVPCPeeringConnection(ctx context.Context, provider CreateVPCPeeringConnectionParamsProvider, databaseID string, body CreateVPCPeeringConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListServerlessRegions request
	ListServerlessRegions(ctx context.Context, params *ListServerlessRegionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAccessListTemplate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccessListTemplateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateAccessList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateAccessListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllAccessListsForOrganization(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllAccessListsForOrganizationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthenticateServiceAccountTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticateServiceAccountTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthenticateServiceAccountToken(ctx context.Context, body AuthenticateServiceAccountTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticateServiceAccountTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAvailableRegions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAvailableRegionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientsForOrg(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientsForOrgRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateTokenForClientWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateTokenForClientRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateTokenForClient(ctx context.Context, body GenerateTokenForClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateTokenForClientRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTokenForClient(ctx context.Context, clientId ClientIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTokenForClientRequest(c.Server, clientId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentOrganization(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentOrganizationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDatabases(ctx context.Context, params *ListDatabasesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDatabasesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabase(ctx context.Context, body CreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatabase(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatabaseRequest(c.Server, databaseId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAddressesOrAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, params *DeleteAddressesOrAccessListForDatabaseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAddressesOrAccessListForDatabaseRequest(c.Server, databaseId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccessListForDatabaseRequest(c.Server, databaseId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccessListForDatabaseWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccessListForDatabaseRequestWithBody(c.Server, databaseId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, body UpdateAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccessListForDatabaseRequest(c.Server, databaseId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddAddressesToAccessListForDatabaseWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddAddressesToAccessListForDatabaseRequestWithBody(c.Server, databaseId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddAddressesToAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, body AddAddressesToAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddAddressesToAccessListForDatabaseRequest(c.Server, databaseId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertAccessListForDatabaseWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertAccessListForDatabaseRequestWithBody(c.Server, databaseId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, body UpsertAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertAccessListForDatabaseRequest(c.Server, databaseId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDatacenters(ctx context.Context, databaseId DatabaseIdParam, params *ListDatacentersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDatacentersRequest(c.Server, databaseId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddDatacentersWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddDatacentersRequestWithBody(c.Server, databaseId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddDatacenters(ctx context.Context, databaseId DatabaseIdParam, body AddDatacentersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddDatacentersRequest(c.Server, databaseId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TerminateDatacenter(ctx context.Context, databaseId DatabaseIdParam, datacenterId DatacenterIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTerminateDatacenterRequest(c.Server, databaseId, datacenterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DropKeyspace(ctx context.Context, databaseId DatabaseIdParam, keyspaceName KeyspaceNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDropKeyspaceRequest(c.Server, databaseId, keyspaceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddKeyspace(ctx context.Context, databaseId DatabaseIdParam, keyspaceName KeyspaceNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddKeyspaceRequest(c.Server, databaseId, keyspaceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveMigrationProxy(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveMigrationProxyRequest(c.Server, databaseId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LaunchMigrationProxyWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLaunchMigrationProxyRequestWithBody(c.Server, databaseId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LaunchMigrationProxy(ctx context.Context, databaseId DatabaseIdParam, body LaunchMigrationProxyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLaunchMigrationProxyRequest(c.Server, databaseId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ParkDatabase(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewParkDatabaseRequest(c.Server, databaseId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPasswordWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPasswordRequestWithBody(c.Server, databaseId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPassword(ctx context.Context, databaseId DatabaseIdParam, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPasswordRequest(c.Server, databaseId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResizeDatabaseWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResizeDatabaseRequestWithBody(c.Server, databaseId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResizeDatabase(ctx context.Context, databaseId DatabaseIdParam, body ResizeDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResizeDatabaseRequest(c.Server, databaseId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateSecureBundleURL(ctx context.Context, databaseId DatabaseIdParam, params *GenerateSecureBundleURLParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateSecureBundleURLRequest(c.Server, databaseId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TerminateDatabase(ctx context.Context, databaseId DatabaseIdParam, params *TerminateDatabaseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTerminateDatabaseRequest(c.Server, databaseId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfigureMetricsExportWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfigureMetricsExportRequestWithBody(c.Server, databaseId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfigureMetricsExport(ctx context.Context, databaseId DatabaseIdParam, body ConfigureMetricsExportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfigureMetricsExportRequest(c.Server, databaseId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnparkDatabase(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnparkDatabaseRequest(c.Server, databaseId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListKeysRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKey(ctx context.Context, body CreateKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerlessKey(ctx context.Context, provider string, region string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerlessKeyRequest(c.Server, provider, region)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCloudAccounts(ctx context.Context, provider string, region string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCloudAccountsRequest(c.Server, provider, region)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveAllowedPrincipalFromServiceWithBody(ctx context.Context, clusterID string, datacenterID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveAllowedPrincipalFromServiceRequestWithBody(c.Server, clusterID, datacenterID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveAllowedPrincipalFromService(ctx context.Context, clusterID string, datacenterID string, body RemoveAllowedPrincipalFromServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveAllowedPrincipalFromServiceRequest(c.Server, clusterID, datacenterID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddAllowedPrincipalWithBody(ctx context.Context, clusterID string, datacenterID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddAllowedPrincipalRequestWithBody(c.Server, clusterID, datacenterID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddAllowedPrincipal(ctx context.Context, clusterID string, datacenterID string, body AddAllowedPrincipalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddAllowedPrincipalRequest(c.Server, clusterID, datacenterID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptEndpointToServiceWithBody(ctx context.Context, clusterID string, datacenterID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptEndpointToServiceRequestWithBody(c.Server, clusterID, datacenterID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptEndpointToService(ctx context.Context, clusterID string, datacenterID string, body AcceptEndpointToServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptEndpointToServiceRequest(c.Server, clusterID, datacenterID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RejectEndpoint(ctx context.Context, clusterID string, datacenterID string, endpointID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRejectEndpointRequest(c.Server, clusterID, datacenterID, endpointID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPrivateLinkEndpoint(ctx context.Context, clusterID string, datacenterID string, endpointID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPrivateLinkEndpointRequest(c.Server, clusterID, datacenterID, endpointID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEndpointDescriptionWithBody(ctx context.Context, clusterID string, datacenterID string, endpointID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEndpointDescriptionRequestWithBody(c.Server, clusterID, datacenterID, endpointID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEndpointDescription(ctx context.Context, clusterID string, datacenterID string, endpointID string, body UpdateEndpointDescriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEndpointDescriptionRequest(c.Server, clusterID, datacenterID, endpointID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPrivateLinksForDatacenter(ctx context.Context, clusterID string, datacenterID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPrivateLinksForDatacenterRequest(c.Server, clusterID, datacenterID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddAllowedPrincipalToServiceWithBody(ctx context.Context, clusterID string, datacenterID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddAllowedPrincipalToServiceRequestWithBody(c.Server, clusterID, datacenterID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddAllowedPrincipalToService(ctx context.Context, clusterID string, datacenterID string, body AddAllowedPrincipalToServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddAllowedPrincipalToServiceRequest(c.Server, clusterID, datacenterID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPrivateLinksForCluster(ctx context.Context, clusterID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPrivateLinksForClusterRequest(c.Server, clusterID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPrivateLinksForOrg(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPrivateLinksForOrgRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationRoles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationRolesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrganizationRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrganizationRoleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrganizationRole(ctx context.Context, body AddOrganizationRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrganizationRoleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOrganizationRole(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOrganizationRoleRequest(c.Server, roleID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationRole(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationRoleRequest(c.Server, roleID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRoleWithBody(ctx context.Context, roleID RoleIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleRequestWithBody(c.Server, roleID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRole(ctx context.Context, roleID RoleIdParam, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleRequest(c.Server, roleID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationUsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteUserToOrganizationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteUserToOrganizationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteUserToOrganization(ctx context.Context, body InviteUserToOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteUserToOrganizationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUserFromOrganization(ctx context.Context, userID UserIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUserFromOrganizationRequest(c.Server, userID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationUser(ctx context.Context, userID UserIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationUserRequest(c.Server, userID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRolesForUserInOrganizationWithBody(ctx context.Context, userID UserIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRolesForUserInOrganizationRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRolesForUserInOrganization(ctx context.Context, userID UserIdParam, body UpdateRolesForUserInOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRolesForUserInOrganizationRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVPCPeeringConnection(ctx context.Context, provider DeleteVPCPeeringConnectionParamsProvider, databaseID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVPCPeeringConnectionRequest(c.Server, provider, databaseID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVPCPeeringConnectionDetails(ctx context.Context, provider GetVPCPeeringConnectionDetailsParamsProvider, databaseID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVPCPeeringConnectionDetailsRequest(c.Server, provider, databaseID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVPCPeeringConnectionWithBody(ctx context.Context, provider CreateVPCPeeringConnectionParamsProvider, databaseID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVPCPeeringConnectionRequestWithBody(c.Server, provider, databaseID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVPCPeeringConnection(ctx context.Context, provider CreateVPCPeeringConnectionParamsProvider, databaseID string, body CreateVPCPeeringConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVPCPeeringConnectionRequest(c.Server, provider, databaseID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListServerlessRegions(ctx context.Context, params *ListServerlessRegionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServerlessRegionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAccessListTemplateRequest generates requests for GetAccessListTemplate
func NewGetAccessListTemplateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/access-list/template")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewValidateAccessListRequest generates requests for ValidateAccessList
func NewValidateAccessListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/access-list/validate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllAccessListsForOrganizationRequest generates requests for GetAllAccessListsForOrganization
func NewGetAllAccessListsForOrganizationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/access-lists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthenticateServiceAccountTokenRequest calls the generic AuthenticateServiceAccountToken builder with application/json body
func NewAuthenticateServiceAccountTokenRequest(server string, body AuthenticateServiceAccountTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthenticateServiceAccountTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthenticateServiceAccountTokenRequestWithBody generates requests for AuthenticateServiceAccountToken with any type of body
func NewAuthenticateServiceAccountTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/authenticateServiceAccount")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAvailableRegionsRequest generates requests for ListAvailableRegions
func NewListAvailableRegionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/availableRegions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClientsForOrgRequest generates requests for GetClientsForOrg
func NewGetClientsForOrgRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/clientIdSecrets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateTokenForClientRequest calls the generic GenerateTokenForClient builder with application/json body
func NewGenerateTokenForClientRequest(server string, body GenerateTokenForClientJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateTokenForClientRequestWithBody(server, "application/json", bodyReader)
}

// NewGenerateTokenForClientRequestWithBody generates requests for GenerateTokenForClient with any type of body
func NewGenerateTokenForClientRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/clientIdSecrets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTokenForClientRequest generates requests for DeleteTokenForClient
func NewDeleteTokenForClientRequest(server string, clientId ClientIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/clientIdSecrets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentOrganizationRequest generates requests for GetCurrentOrganization
func NewGetCurrentOrganizationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/currentOrg")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDatabasesRequest generates requests for ListDatabases
func NewListDatabasesRequest(server string, params *ListDatabasesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Provider != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "provider", runtime.ParamLocationQuery, *params.Provider); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartingAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDatabaseRequest calls the generic CreateDatabase builder with application/json body
func NewCreateDatabaseRequest(server string, body CreateDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDatabaseRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDatabaseRequestWithBody generates requests for CreateDatabase with any type of body
func NewCreateDatabaseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDatabaseRequest generates requests for GetDatabase
func NewGetDatabaseRequest(server string, databaseId DatabaseIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteAddressesOrAccessListForDatabaseRequest generates requests for DeleteAddressesOrAccessListForDatabase
func NewDeleteAddressesOrAccessListForDatabaseRequest(server string, databaseId DatabaseIdParam, params *DeleteAddressesOrAccessListForDatabaseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/access-list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Addresses != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addresses", runtime.ParamLocationQuery, *params.Addresses); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAccessListForDatabaseRequest generates requests for GetAccessListForDatabase
func NewGetAccessListForDatabaseRequest(server string, databaseId DatabaseIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/access-list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAccessListForDatabaseRequest calls the generic UpdateAccessListForDatabase builder with application/json body
func NewUpdateAccessListForDatabaseRequest(server string, databaseId DatabaseIdParam, body UpdateAccessListForDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAccessListForDatabaseRequestWithBody(server, databaseId, "application/json", bodyReader)
}

// NewUpdateAccessListForDatabaseRequestWithBody generates requests for UpdateAccessListForDatabase with any type of body
func NewUpdateAccessListForDatabaseRequestWithBody(server string, databaseId DatabaseIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/access-list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddAddressesToAccessListForDatabaseRequest calls the generic AddAddressesToAccessListForDatabase builder with application/json body
func NewAddAddressesToAccessListForDatabaseRequest(server string, databaseId DatabaseIdParam, body AddAddressesToAccessListForDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddAddressesToAccessListForDatabaseRequestWithBody(server, databaseId, "application/json", bodyReader)
}

// NewAddAddressesToAccessListForDatabaseRequestWithBody generates requests for AddAddressesToAccessListForDatabase with any type of body
func NewAddAddressesToAccessListForDatabaseRequestWithBody(server string, databaseId DatabaseIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/access-list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpsertAccessListForDatabaseRequest calls the generic UpsertAccessListForDatabase builder with application/json body
func NewUpsertAccessListForDatabaseRequest(server string, databaseId DatabaseIdParam, body UpsertAccessListForDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertAccessListForDatabaseRequestWithBody(server, databaseId, "application/json", bodyReader)
}

// NewUpsertAccessListForDatabaseRequestWithBody generates requests for UpsertAccessListForDatabase with any type of body
func NewUpsertAccessListForDatabaseRequestWithBody(server string, databaseId DatabaseIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/access-list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListDatacentersRequest generates requests for ListDatacenters
func NewListDatacentersRequest(server string, databaseId DatabaseIdParam, params *ListDatacentersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/datacenters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.All != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all", runtime.ParamLocationQuery, *params.All); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddDatacentersRequest calls the generic AddDatacenters builder with application/json body
func NewAddDatacentersRequest(server string, databaseId DatabaseIdParam, body AddDatacentersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddDatacentersRequestWithBody(server, databaseId, "application/json", bodyReader)
}

// NewAddDatacentersRequestWithBody generates requests for AddDatacenters with any type of body
func NewAddDatacentersRequestWithBody(server string, databaseId DatabaseIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/datacenters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTerminateDatacenterRequest generates requests for TerminateDatacenter
func NewTerminateDatacenterRequest(server string, databaseId DatabaseIdParam, datacenterId DatacenterIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "datacenterId", runtime.ParamLocationPath, datacenterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/datacenters/%s/terminate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDropKeyspaceRequest generates requests for DropKeyspace
func NewDropKeyspaceRequest(server string, databaseId DatabaseIdParam, keyspaceName KeyspaceNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "keyspaceName", runtime.ParamLocationPath, keyspaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/keyspaces/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddKeyspaceRequest generates requests for AddKeyspace
func NewAddKeyspaceRequest(server string, databaseId DatabaseIdParam, keyspaceName KeyspaceNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "keyspaceName", runtime.ParamLocationPath, keyspaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/keyspaces/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveMigrationProxyRequest generates requests for RemoveMigrationProxy
func NewRemoveMigrationProxyRequest(server string, databaseId DatabaseIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/migrationProxy", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLaunchMigrationProxyRequest calls the generic LaunchMigrationProxy builder with application/json body
func NewLaunchMigrationProxyRequest(server string, databaseId DatabaseIdParam, body LaunchMigrationProxyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLaunchMigrationProxyRequestWithBody(server, databaseId, "application/json", bodyReader)
}

// NewLaunchMigrationProxyRequestWithBody generates requests for LaunchMigrationProxy with any type of body
func NewLaunchMigrationProxyRequestWithBody(server string, databaseId DatabaseIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/migrationProxy", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewParkDatabaseRequest generates requests for ParkDatabase
func NewParkDatabaseRequest(server string, databaseId DatabaseIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/park", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResetPasswordRequest calls the generic ResetPassword builder with application/json body
func NewResetPasswordRequest(server string, databaseId DatabaseIdParam, body ResetPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResetPasswordRequestWithBody(server, databaseId, "application/json", bodyReader)
}

// NewResetPasswordRequestWithBody generates requests for ResetPassword with any type of body
func NewResetPasswordRequestWithBody(server string, databaseId DatabaseIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/resetPassword", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResizeDatabaseRequest calls the generic ResizeDatabase builder with application/json body
func NewResizeDatabaseRequest(server string, databaseId DatabaseIdParam, body ResizeDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResizeDatabaseRequestWithBody(server, databaseId, "application/json", bodyReader)
}

// NewResizeDatabaseRequestWithBody generates requests for ResizeDatabase with any type of body
func NewResizeDatabaseRequestWithBody(server string, databaseId DatabaseIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/resize", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenerateSecureBundleURLRequest generates requests for GenerateSecureBundleURL
func NewGenerateSecureBundleURLRequest(server string, databaseId DatabaseIdParam, params *GenerateSecureBundleURLParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/secureBundleURL", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.All != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all", runtime.ParamLocationQuery, *params.All); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTerminateDatabaseRequest generates requests for TerminateDatabase
func NewTerminateDatabaseRequest(server string, databaseId DatabaseIdParam, params *TerminateDatabaseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/terminate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PreparedStateOnly != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preparedStateOnly", runtime.ParamLocationQuery, *params.PreparedStateOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConfigureMetricsExportRequest calls the generic ConfigureMetricsExport builder with application/json body
func NewConfigureMetricsExportRequest(server string, databaseId DatabaseIdParam, body ConfigureMetricsExportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConfigureMetricsExportRequestWithBody(server, databaseId, "application/json", bodyReader)
}

// NewConfigureMetricsExportRequestWithBody generates requests for ConfigureMetricsExport with any type of body
func NewConfigureMetricsExportRequestWithBody(server string, databaseId DatabaseIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/third-party-metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnparkDatabaseRequest generates requests for UnparkDatabase
func NewUnparkDatabaseRequest(server string, databaseId DatabaseIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/unpark", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListKeysRequest generates requests for ListKeys
func NewListKeysRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/kms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateKeyRequest calls the generic CreateKey builder with application/json body
func NewCreateKeyRequest(server string, body CreateKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateKeyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateKeyRequestWithBody generates requests for CreateKey with any type of body
func NewCreateKeyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/kms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetServerlessKeyRequest generates requests for GetServerlessKey
func NewGetServerlessKeyRequest(server string, provider string, region string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "provider", runtime.ParamLocationPath, provider)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "region", runtime.ParamLocationPath, region)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/kms/provider/%s/region/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCloudAccountsRequest generates requests for GetCloudAccounts
func NewGetCloudAccountsRequest(server string, provider string, region string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "provider", runtime.ParamLocationPath, provider)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "region", runtime.ParamLocationPath, region)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/kms/provider/%s/region/%s/accounts", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveAllowedPrincipalFromServiceRequest calls the generic RemoveAllowedPrincipalFromService builder with application/json body
func NewRemoveAllowedPrincipalFromServiceRequest(server string, clusterID string, datacenterID string, body RemoveAllowedPrincipalFromServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveAllowedPrincipalFromServiceRequestWithBody(server, clusterID, datacenterID, "application/json", bodyReader)
}

// NewRemoveAllowedPrincipalFromServiceRequestWithBody generates requests for RemoveAllowedPrincipalFromService with any type of body
func NewRemoveAllowedPrincipalFromServiceRequestWithBody(server string, clusterID string, datacenterID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterID", runtime.ParamLocationPath, clusterID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "datacenterID", runtime.ParamLocationPath, datacenterID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/clusters/%s/datacenters/%s/allowed-principals", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddAllowedPrincipalRequest calls the generic AddAllowedPrincipal builder with application/json body
func NewAddAllowedPrincipalRequest(server string, clusterID string, datacenterID string, body AddAllowedPrincipalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddAllowedPrincipalRequestWithBody(server, clusterID, datacenterID, "application/json", bodyReader)
}

// NewAddAllowedPrincipalRequestWithBody generates requests for AddAllowedPrincipal with any type of body
func NewAddAllowedPrincipalRequestWithBody(server string, clusterID string, datacenterID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterID", runtime.ParamLocationPath, clusterID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "datacenterID", runtime.ParamLocationPath, datacenterID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/clusters/%s/datacenters/%s/allowed-principals", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAcceptEndpointToServiceRequest calls the generic AcceptEndpointToService builder with application/json body
func NewAcceptEndpointToServiceRequest(server string, clusterID string, datacenterID string, body AcceptEndpointToServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAcceptEndpointToServiceRequestWithBody(server, clusterID, datacenterID, "application/json", bodyReader)
}

// NewAcceptEndpointToServiceRequestWithBody generates requests for AcceptEndpointToService with any type of body
func NewAcceptEndpointToServiceRequestWithBody(server string, clusterID string, datacenterID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterID", runtime.ParamLocationPath, clusterID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "datacenterID", runtime.ParamLocationPath, datacenterID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/clusters/%s/datacenters/%s/endpoints", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRejectEndpointRequest generates requests for RejectEndpoint
func NewRejectEndpointRequest(server string, clusterID string, datacenterID string, endpointID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterID", runtime.ParamLocationPath, clusterID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "datacenterID", runtime.ParamLocationPath, datacenterID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "endpointID", runtime.ParamLocationPath, endpointID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/clusters/%s/datacenters/%s/endpoints/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPrivateLinkEndpointRequest generates requests for GetPrivateLinkEndpoint
func NewGetPrivateLinkEndpointRequest(server string, clusterID string, datacenterID string, endpointID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterID", runtime.ParamLocationPath, clusterID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "datacenterID", runtime.ParamLocationPath, datacenterID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "endpointID", runtime.ParamLocationPath, endpointID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/clusters/%s/datacenters/%s/endpoints/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateEndpointDescriptionRequest calls the generic UpdateEndpointDescription builder with application/json body
func NewUpdateEndpointDescriptionRequest(server string, clusterID string, datacenterID string, endpointID string, body UpdateEndpointDescriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEndpointDescriptionRequestWithBody(server, clusterID, datacenterID, endpointID, "application/json", bodyReader)
}

// NewUpdateEndpointDescriptionRequestWithBody generates requests for UpdateEndpointDescription with any type of body
func NewUpdateEndpointDescriptionRequestWithBody(server string, clusterID string, datacenterID string, endpointID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterID", runtime.ParamLocationPath, clusterID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "datacenterID", runtime.ParamLocationPath, datacenterID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "endpointID", runtime.ParamLocationPath, endpointID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/clusters/%s/datacenters/%s/endpoints/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPrivateLinksForDatacenterRequest generates requests for GetPrivateLinksForDatacenter
func NewGetPrivateLinksForDatacenterRequest(server string, clusterID string, datacenterID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterID", runtime.ParamLocationPath, clusterID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "datacenterID", runtime.ParamLocationPath, datacenterID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/clusters/%s/datacenters/%s/private-link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddAllowedPrincipalToServiceRequest calls the generic AddAllowedPrincipalToService builder with application/json body
func NewAddAllowedPrincipalToServiceRequest(server string, clusterID string, datacenterID string, body AddAllowedPrincipalToServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddAllowedPrincipalToServiceRequestWithBody(server, clusterID, datacenterID, "application/json", bodyReader)
}

// NewAddAllowedPrincipalToServiceRequestWithBody generates requests for AddAllowedPrincipalToService with any type of body
func NewAddAllowedPrincipalToServiceRequestWithBody(server string, clusterID string, datacenterID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterID", runtime.ParamLocationPath, clusterID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "datacenterID", runtime.ParamLocationPath, datacenterID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/clusters/%s/datacenters/%s/private-link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPrivateLinksForClusterRequest generates requests for ListPrivateLinksForCluster
func NewListPrivateLinksForClusterRequest(server string, clusterID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterID", runtime.ParamLocationPath, clusterID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/clusters/%s/private-link", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPrivateLinksForOrgRequest generates requests for ListPrivateLinksForOrg
func NewListPrivateLinksForOrgRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/private-link")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationRolesRequest generates requests for GetOrganizationRoles
func NewGetOrganizationRolesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddOrganizationRoleRequest calls the generic AddOrganizationRole builder with application/json body
func NewAddOrganizationRoleRequest(server string, body AddOrganizationRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddOrganizationRoleRequestWithBody(server, "application/json", bodyReader)
}

// NewAddOrganizationRoleRequestWithBody generates requests for AddOrganizationRole with any type of body
func NewAddOrganizationRoleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOrganizationRoleRequest generates requests for DeleteOrganizationRole
func NewDeleteOrganizationRoleRequest(server string, roleID RoleIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleID", runtime.ParamLocationPath, roleID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationRoleRequest generates requests for GetOrganizationRole
func NewGetOrganizationRoleRequest(server string, roleID RoleIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleID", runtime.ParamLocationPath, roleID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRoleRequest calls the generic UpdateRole builder with application/json body
func NewUpdateRoleRequest(server string, roleID RoleIdParam, body UpdateRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRoleRequestWithBody(server, roleID, "application/json", bodyReader)
}

// NewUpdateRoleRequestWithBody generates requests for UpdateRole with any type of body
func NewUpdateRoleRequestWithBody(server string, roleID RoleIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleID", runtime.ParamLocationPath, roleID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOrganizationUsersRequest generates requests for GetOrganizationUsers
func NewGetOrganizationUsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInviteUserToOrganizationRequest calls the generic InviteUserToOrganization builder with application/json body
func NewInviteUserToOrganizationRequest(server string, body InviteUserToOrganizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInviteUserToOrganizationRequestWithBody(server, "application/json", bodyReader)
}

// NewInviteUserToOrganizationRequestWithBody generates requests for InviteUserToOrganization with any type of body
func NewInviteUserToOrganizationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveUserFromOrganizationRequest generates requests for RemoveUserFromOrganization
func NewRemoveUserFromOrganizationRequest(server string, userID UserIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationUserRequest generates requests for GetOrganizationUser
func NewGetOrganizationUserRequest(server string, userID UserIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRolesForUserInOrganizationRequest calls the generic UpdateRolesForUserInOrganization builder with application/json body
func NewUpdateRolesForUserInOrganizationRequest(server string, userID UserIdParam, body UpdateRolesForUserInOrganizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRolesForUserInOrganizationRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewUpdateRolesForUserInOrganizationRequestWithBody generates requests for UpdateRolesForUserInOrganization with any type of body
func NewUpdateRolesForUserInOrganizationRequestWithBody(server string, userID UserIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/users/%s/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVPCPeeringConnectionRequest generates requests for DeleteVPCPeeringConnection
func NewDeleteVPCPeeringConnectionRequest(server string, provider DeleteVPCPeeringConnectionParamsProvider, databaseID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "provider", runtime.ParamLocationPath, provider)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "databaseID", runtime.ParamLocationPath, databaseID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/peering/provider/%s/database/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVPCPeeringConnectionDetailsRequest generates requests for GetVPCPeeringConnectionDetails
func NewGetVPCPeeringConnectionDetailsRequest(server string, provider GetVPCPeeringConnectionDetailsParamsProvider, databaseID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "provider", runtime.ParamLocationPath, provider)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "databaseID", runtime.ParamLocationPath, databaseID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/peering/provider/%s/database/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVPCPeeringConnectionRequest calls the generic CreateVPCPeeringConnection builder with application/json body
func NewCreateVPCPeeringConnectionRequest(server string, provider CreateVPCPeeringConnectionParamsProvider, databaseID string, body CreateVPCPeeringConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVPCPeeringConnectionRequestWithBody(server, provider, databaseID, "application/json", bodyReader)
}

// NewCreateVPCPeeringConnectionRequestWithBody generates requests for CreateVPCPeeringConnection with any type of body
func NewCreateVPCPeeringConnectionRequestWithBody(server string, provider CreateVPCPeeringConnectionParamsProvider, databaseID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "provider", runtime.ParamLocationPath, provider)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "databaseID", runtime.ParamLocationPath, databaseID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/peering/provider/%s/database/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListServerlessRegionsRequest generates requests for ListServerlessRegions
func NewListServerlessRegionsRequest(server string, params *ListServerlessRegionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/regions/serverless")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.RegionType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region-type", runtime.ParamLocationQuery, *params.RegionType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterByOrg != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter-by-org", runtime.ParamLocationQuery, *params.FilterByOrg); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAccessListTemplate request
	GetAccessListTemplateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAccessListTemplateResponse, error)

	// ValidateAccessList request
	ValidateAccessListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ValidateAccessListResponse, error)

	// GetAllAccessListsForOrganization request
	GetAllAccessListsForOrganizationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllAccessListsForOrganizationResponse, error)

	// AuthenticateServiceAccountToken request with any body
	AuthenticateServiceAccountTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthenticateServiceAccountTokenResponse, error)

	AuthenticateServiceAccountTokenWithResponse(ctx context.Context, body AuthenticateServiceAccountTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticateServiceAccountTokenResponse, error)

	// ListAvailableRegions request
	ListAvailableRegionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAvailableRegionsResponse, error)

	// GetClientsForOrg request
	GetClientsForOrgWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClientsForOrgResponse, error)

	// GenerateTokenForClient request with any body
	GenerateTokenForClientWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateTokenForClientResponse, error)

	GenerateTokenForClientWithResponse(ctx context.Context, body GenerateTokenForClientJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateTokenForClientResponse, error)

	// DeleteTokenForClient request
	DeleteTokenForClientWithResponse(ctx context.Context, clientId ClientIdParam, reqEditors ...RequestEditorFn) (*DeleteTokenForClientResponse, error)

	// GetCurrentOrganization request
	GetCurrentOrganizationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentOrganizationResponse, error)

	// ListDatabases request
	ListDatabasesWithResponse(ctx context.Context, params *ListDatabasesParams, reqEditors ...RequestEditorFn) (*ListDatabasesResponse, error)

	// CreateDatabase request with any body
	CreateDatabaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseResponse, error)

	CreateDatabaseWithResponse(ctx context.Context, body CreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseResponse, error)

	// GetDatabase request
	GetDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*GetDatabaseResponse, error)

	// DeleteAddressesOrAccessListForDatabase request
	DeleteAddressesOrAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, params *DeleteAddressesOrAccessListForDatabaseParams, reqEditors ...RequestEditorFn) (*DeleteAddressesOrAccessListForDatabaseResponse, error)

	// GetAccessListForDatabase request
	GetAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*GetAccessListForDatabaseResponse, error)

	// UpdateAccessListForDatabase request with any body
	UpdateAccessListForDatabaseWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccessListForDatabaseResponse, error)

	UpdateAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, body UpdateAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccessListForDatabaseResponse, error)

	// AddAddressesToAccessListForDatabase request with any body
	AddAddressesToAccessListForDatabaseWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddAddressesToAccessListForDatabaseResponse, error)

	AddAddressesToAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, body AddAddressesToAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*AddAddressesToAccessListForDatabaseResponse, error)

	// UpsertAccessListForDatabase request with any body
	UpsertAccessListForDatabaseWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertAccessListForDatabaseResponse, error)

	UpsertAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, body UpsertAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertAccessListForDatabaseResponse, error)

	// ListDatacenters request
	ListDatacentersWithResponse(ctx context.Context, databaseId DatabaseIdParam, params *ListDatacentersParams, reqEditors ...RequestEditorFn) (*ListDatacentersResponse, error)

	// AddDatacenters request with any body
	AddDatacentersWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddDatacentersResponse, error)

	AddDatacentersWithResponse(ctx context.Context, databaseId DatabaseIdParam, body AddDatacentersJSONRequestBody, reqEditors ...RequestEditorFn) (*AddDatacentersResponse, error)

	// TerminateDatacenter request
	TerminateDatacenterWithResponse(ctx context.Context, databaseId DatabaseIdParam, datacenterId DatacenterIdParam, reqEditors ...RequestEditorFn) (*TerminateDatacenterResponse, error)

	// DropKeyspace request
	DropKeyspaceWithResponse(ctx context.Context, databaseId DatabaseIdParam, keyspaceName KeyspaceNameParam, reqEditors ...RequestEditorFn) (*DropKeyspaceResponse, error)

	// AddKeyspace request
	AddKeyspaceWithResponse(ctx context.Context, databaseId DatabaseIdParam, keyspaceName KeyspaceNameParam, reqEditors ...RequestEditorFn) (*AddKeyspaceResponse, error)

	// RemoveMigrationProxy request
	RemoveMigrationProxyWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*RemoveMigrationProxyResponse, error)

	// LaunchMigrationProxy request with any body
	LaunchMigrationProxyWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LaunchMigrationProxyResponse, error)

	LaunchMigrationProxyWithResponse(ctx context.Context, databaseId DatabaseIdParam, body LaunchMigrationProxyJSONRequestBody, reqEditors ...RequestEditorFn) (*LaunchMigrationProxyResponse, error)

	// ParkDatabase request
	ParkDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*ParkDatabaseResponse, error)

	// ResetPassword request with any body
	ResetPasswordWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error)

	ResetPasswordWithResponse(ctx context.Context, databaseId DatabaseIdParam, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error)

	// ResizeDatabase request with any body
	ResizeDatabaseWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResizeDatabaseResponse, error)

	ResizeDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, body ResizeDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*ResizeDatabaseResponse, error)

	// GenerateSecureBundleURL request
	GenerateSecureBundleURLWithResponse(ctx context.Context, databaseId DatabaseIdParam, params *GenerateSecureBundleURLParams, reqEditors ...RequestEditorFn) (*GenerateSecureBundleURLResponse, error)

	// TerminateDatabase request
	TerminateDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, params *TerminateDatabaseParams, reqEditors ...RequestEditorFn) (*TerminateDatabaseResponse, error)

	// ConfigureMetricsExport request with any body
	ConfigureMetricsExportWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfigureMetricsExportResponse, error)

	ConfigureMetricsExportWithResponse(ctx context.Context, databaseId DatabaseIdParam, body ConfigureMetricsExportJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfigureMetricsExportResponse, error)

	// UnparkDatabase request
	UnparkDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*UnparkDatabaseResponse, error)

	// ListKeys request
	ListKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListKeysResponse, error)

	// CreateKey request with any body
	CreateKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeyResponse, error)

	CreateKeyWithResponse(ctx context.Context, body CreateKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeyResponse, error)

	// GetServerlessKey request
	GetServerlessKeyWithResponse(ctx context.Context, provider string, region string, reqEditors ...RequestEditorFn) (*GetServerlessKeyResponse, error)

	// GetCloudAccounts request
	GetCloudAccountsWithResponse(ctx context.Context, provider string, region string, reqEditors ...RequestEditorFn) (*GetCloudAccountsResponse, error)

	// RemoveAllowedPrincipalFromService request with any body
	RemoveAllowedPrincipalFromServiceWithBodyWithResponse(ctx context.Context, clusterID string, datacenterID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveAllowedPrincipalFromServiceResponse, error)

	RemoveAllowedPrincipalFromServiceWithResponse(ctx context.Context, clusterID string, datacenterID string, body RemoveAllowedPrincipalFromServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveAllowedPrincipalFromServiceResponse, error)

	// AddAllowedPrincipal request with any body
	AddAllowedPrincipalWithBodyWithResponse(ctx context.Context, clusterID string, datacenterID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddAllowedPrincipalResponse, error)

	AddAllowedPrincipalWithResponse(ctx context.Context, clusterID string, datacenterID string, body AddAllowedPrincipalJSONRequestBody, reqEditors ...RequestEditorFn) (*AddAllowedPrincipalResponse, error)

	// AcceptEndpointToService request with any body
	AcceptEndpointToServiceWithBodyWithResponse(ctx context.Context, clusterID string, datacenterID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AcceptEndpointToServiceResponse, error)

	AcceptEndpointToServiceWithResponse(ctx context.Context, clusterID string, datacenterID string, body AcceptEndpointToServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*AcceptEndpointToServiceResponse, error)

	// RejectEndpoint request
	RejectEndpointWithResponse(ctx context.Context, clusterID string, datacenterID string, endpointID string, reqEditors ...RequestEditorFn) (*RejectEndpointResponse, error)

	// GetPrivateLinkEndpoint request
	GetPrivateLinkEndpointWithResponse(ctx context.Context, clusterID string, datacenterID string, endpointID string, reqEditors ...RequestEditorFn) (*GetPrivateLinkEndpointResponse, error)

	// UpdateEndpointDescription request with any body
	UpdateEndpointDescriptionWithBodyWithResponse(ctx context.Context, clusterID string, datacenterID string, endpointID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEndpointDescriptionResponse, error)

	UpdateEndpointDescriptionWithResponse(ctx context.Context, clusterID string, datacenterID string, endpointID string, body UpdateEndpointDescriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEndpointDescriptionResponse, error)

	// GetPrivateLinksForDatacenter request
	GetPrivateLinksForDatacenterWithResponse(ctx context.Context, clusterID string, datacenterID string, reqEditors ...RequestEditorFn) (*GetPrivateLinksForDatacenterResponse, error)

	// AddAllowedPrincipalToService request with any body
	AddAllowedPrincipalToServiceWithBodyWithResponse(ctx context.Context, clusterID string, datacenterID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddAllowedPrincipalToServiceResponse, error)

	AddAllowedPrincipalToServiceWithResponse(ctx context.Context, clusterID string, datacenterID string, body AddAllowedPrincipalToServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*AddAllowedPrincipalToServiceResponse, error)

	// ListPrivateLinksForCluster request
	ListPrivateLinksForClusterWithResponse(ctx context.Context, clusterID string, reqEditors ...RequestEditorFn) (*ListPrivateLinksForClusterResponse, error)

	// ListPrivateLinksForOrg request
	ListPrivateLinksForOrgWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListPrivateLinksForOrgResponse, error)

	// GetOrganizationRoles request
	GetOrganizationRolesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOrganizationRolesResponse, error)

	// AddOrganizationRole request with any body
	AddOrganizationRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrganizationRoleResponse, error)

	AddOrganizationRoleWithResponse(ctx context.Context, body AddOrganizationRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrganizationRoleResponse, error)

	// DeleteOrganizationRole request
	DeleteOrganizationRoleWithResponse(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*DeleteOrganizationRoleResponse, error)

	// GetOrganizationRole request
	GetOrganizationRoleWithResponse(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*GetOrganizationRoleResponse, error)

	// UpdateRole request with any body
	UpdateRoleWithBodyWithResponse(ctx context.Context, roleID RoleIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error)

	UpdateRoleWithResponse(ctx context.Context, roleID RoleIdParam, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error)

	// GetOrganizationUsers request
	GetOrganizationUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOrganizationUsersResponse, error)

	// InviteUserToOrganization request with any body
	InviteUserToOrganizationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteUserToOrganizationResponse, error)

	InviteUserToOrganizationWithResponse(ctx context.Context, body InviteUserToOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteUserToOrganizationResponse, error)

	// RemoveUserFromOrganization request
	RemoveUserFromOrganizationWithResponse(ctx context.Context, userID UserIdParam, reqEditors ...RequestEditorFn) (*RemoveUserFromOrganizationResponse, error)

	// GetOrganizationUser request
	GetOrganizationUserWithResponse(ctx context.Context, userID UserIdParam, reqEditors ...RequestEditorFn) (*GetOrganizationUserResponse, error)

	// UpdateRolesForUserInOrganization request with any body
	UpdateRolesForUserInOrganizationWithBodyWithResponse(ctx context.Context, userID UserIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRolesForUserInOrganizationResponse, error)

	UpdateRolesForUserInOrganizationWithResponse(ctx context.Context, userID UserIdParam, body UpdateRolesForUserInOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRolesForUserInOrganizationResponse, error)

	// DeleteVPCPeeringConnection request
	DeleteVPCPeeringConnectionWithResponse(ctx context.Context, provider DeleteVPCPeeringConnectionParamsProvider, databaseID string, reqEditors ...RequestEditorFn) (*DeleteVPCPeeringConnectionResponse, error)

	// GetVPCPeeringConnectionDetails request
	GetVPCPeeringConnectionDetailsWithResponse(ctx context.Context, provider GetVPCPeeringConnectionDetailsParamsProvider, databaseID string, reqEditors ...RequestEditorFn) (*GetVPCPeeringConnectionDetailsResponse, error)

	// CreateVPCPeeringConnection request with any body
	CreateVPCPeeringConnectionWithBodyWithResponse(ctx context.Context, provider CreateVPCPeeringConnectionParamsProvider, databaseID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVPCPeeringConnectionResponse, error)

	CreateVPCPeeringConnectionWithResponse(ctx context.Context, provider CreateVPCPeeringConnectionParamsProvider, databaseID string, body CreateVPCPeeringConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVPCPeeringConnectionResponse, error)

	// ListServerlessRegions request
	ListServerlessRegionsWithResponse(ctx context.Context, params *ListServerlessRegionsParams, reqEditors ...RequestEditorFn) (*ListServerlessRegionsResponse, error)
}

type GetAccessListTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccessListRequest
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r GetAccessListTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccessListTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateAccessListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ValidationResponse
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r ValidateAccessListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateAccessListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllAccessListsForOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AccessListResponse
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r GetAllAccessListsForOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllAccessListsForOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthenticateServiceAccountTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceAccountTokenResponse
	JSON400      *Errors
	JSON401      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r AuthenticateServiceAccountTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthenticateServiceAccountTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAvailableRegionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AvailableRegionCombination
	JSON401      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r ListAvailableRegionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAvailableRegionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientsForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *Errors
	JSON403      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r GetClientsForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientsForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateTokenForClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r GenerateTokenForClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateTokenForClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTokenForClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON403      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r DeleteTokenForClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTokenForClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Organization
	JSON400      *Errors
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r GetCurrentOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDatabasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Database
	JSON400      *Errors
	JSON401      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r ListDatabasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDatabasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON401      *Errors
	JSON422      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r CreateDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Database
	JSON400      *Errors
	JSON401      *Errors
	JSON404      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r GetDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAddressesOrAccessListForDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r DeleteAddressesOrAccessListForDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAddressesOrAccessListForDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccessListForDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccessListResponse
	JSON400      *Errors
	JSON403      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r GetAccessListForDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccessListForDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAccessListForDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r UpdateAccessListForDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAccessListForDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddAddressesToAccessListForDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddAddressesToAccessListForDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddAddressesToAccessListForDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertAccessListForDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r UpsertAccessListForDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertAccessListForDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDatacentersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Datacenter
	JSON401      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r ListDatacentersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDatacentersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddDatacentersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON401      *Errors
	JSON404      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r AddDatacentersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddDatacentersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TerminateDatacenterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON401      *Errors
	JSON404      *Errors
	JSON409      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r TerminateDatacenterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TerminateDatacenterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DropKeyspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r DropKeyspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DropKeyspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddKeyspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *Errors
	JSON422      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r AddKeyspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddKeyspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveMigrationProxyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON401      *Errors
	JSON404      *Errors
	JSON409      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r RemoveMigrationProxyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveMigrationProxyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LaunchMigrationProxyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON401      *Errors
	JSON404      *Errors
	JSON409      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r LaunchMigrationProxyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LaunchMigrationProxyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ParkDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON401      *Errors
	JSON404      *Errors
	JSON409      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r ParkDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ParkDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON401      *Errors
	JSON404      *Errors
	JSON409      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r ResetPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResizeDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON401      *Errors
	JSON404      *Errors
	JSON409      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r ResizeDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResizeDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateSecureBundleURLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SecureBundles
	JSON400      *Errors
	JSON401      *Errors
	JSON404      *Errors
	JSON409      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r GenerateSecureBundleURLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateSecureBundleURLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TerminateDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON401      *Errors
	JSON404      *Errors
	JSON409      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r TerminateDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TerminateDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfigureMetricsExportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CredsURL
	JSON400      *Errors
	JSON401      *Errors
	JSON404      *Errors
	JSON409      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r ConfigureMetricsExportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfigureMetricsExportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnparkDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON401      *Errors
	JSON404      *Errors
	JSON409      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r UnparkDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnparkDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAllCustomerKeys
	JSON400      *Errors
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r ListKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r CreateKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerlessKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetParticularCustomerKey
	JSON400      *Errors
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r GetServerlessKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerlessKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCloudAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCloudProviderAccounts
	JSON400      *Errors
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r GetCloudAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCloudAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveAllowedPrincipalFromServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveAllowedPrincipalFromServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveAllowedPrincipalFromServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddAllowedPrincipalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PrivateLinkCreateConfigOutput
}

// Status returns HTTPResponse.Status
func (r AddAllowedPrincipalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddAllowedPrincipalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AcceptEndpointToServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PrivateLinkEndpoint
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r AcceptEndpointToServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcceptEndpointToServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RejectEndpointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r RejectEndpointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RejectEndpointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPrivateLinkEndpointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PrivateLinkEndpoint
	JSON400      *Errors
	JSON404      *string
	JSON409      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r GetPrivateLinkEndpointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPrivateLinkEndpointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEndpointDescriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PrivateLinkEndpoint
	JSON400      *Errors
	JSON404      *Errors
	JSON409      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r UpdateEndpointDescriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEndpointDescriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPrivateLinksForDatacenterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PrivateLinkDatacenterOutput
}

// Status returns HTTPResponse.Status
func (r GetPrivateLinksForDatacenterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPrivateLinksForDatacenterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddAllowedPrincipalToServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PrivateLinkCreateConfigOutput
}

// Status returns HTTPResponse.Status
func (r AddAllowedPrincipalToServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddAllowedPrincipalToServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPrivateLinksForClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PrivateLinkClusterOutput
}

// Status returns HTTPResponse.Status
func (r ListPrivateLinksForClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPrivateLinksForClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPrivateLinksForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PrivateLinkOrgOutput
	JSON400      *Errors
	JSON404      *Errors
	JSON409      *Errors
}

// Status returns HTTPResponse.Status
func (r ListPrivateLinksForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPrivateLinksForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Role
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r GetOrganizationRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddOrganizationRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Role
	JSON400      *string
	JSON403      *string
	JSON404      *string
	JSON409      *string
	JSON500      *string
}

// Status returns HTTPResponse.Status
func (r AddOrganizationRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddOrganizationRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOrganizationRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *string
	JSON404      *string
	JSON500      *string
}

// Status returns HTTPResponse.Status
func (r DeleteOrganizationRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOrganizationRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Role
	JSON400      *string
	JSON403      *string
	JSON404      *string
	JSON500      *string
}

// Status returns HTTPResponse.Status
func (r GetOrganizationRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *string
	JSON403      *string
	JSON404      *string
	JSON500      *string
}

// Status returns HTTPResponse.Status
func (r UpdateRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrganizationUsers
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r GetOrganizationUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InviteUserToOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r InviteUserToOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InviteUserToOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveUserFromOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r RemoveUserFromOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveUserFromOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserResponse
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r GetOrganizationUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRolesForUserInOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r UpdateRolesForUserInOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRolesForUserInOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVPCPeeringConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r DeleteVPCPeeringConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVPCPeeringConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVPCPeeringConnectionDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VPCConnection
	JSON400      *Errors
	JSON404      *Errors
	JSON409      *Errors
}

// Status returns HTTPResponse.Status
func (r GetVPCPeeringConnectionDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVPCPeeringConnectionDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVPCPeeringConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VPCConnection
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r CreateVPCPeeringConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVPCPeeringConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListServerlessRegionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ServerlessRegion
	JSON401      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r ListServerlessRegionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServerlessRegionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAccessListTemplateWithResponse request returning *GetAccessListTemplateResponse
func (c *ClientWithResponses) GetAccessListTemplateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAccessListTemplateResponse, error) {
	rsp, err := c.GetAccessListTemplate(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccessListTemplateResponse(rsp)
}

// ValidateAccessListWithResponse request returning *ValidateAccessListResponse
func (c *ClientWithResponses) ValidateAccessListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ValidateAccessListResponse, error) {
	rsp, err := c.ValidateAccessList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateAccessListResponse(rsp)
}

// GetAllAccessListsForOrganizationWithResponse request returning *GetAllAccessListsForOrganizationResponse
func (c *ClientWithResponses) GetAllAccessListsForOrganizationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllAccessListsForOrganizationResponse, error) {
	rsp, err := c.GetAllAccessListsForOrganization(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllAccessListsForOrganizationResponse(rsp)
}

// AuthenticateServiceAccountTokenWithBodyWithResponse request with arbitrary body returning *AuthenticateServiceAccountTokenResponse
func (c *ClientWithResponses) AuthenticateServiceAccountTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthenticateServiceAccountTokenResponse, error) {
	rsp, err := c.AuthenticateServiceAccountTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticateServiceAccountTokenResponse(rsp)
}

func (c *ClientWithResponses) AuthenticateServiceAccountTokenWithResponse(ctx context.Context, body AuthenticateServiceAccountTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticateServiceAccountTokenResponse, error) {
	rsp, err := c.AuthenticateServiceAccountToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticateServiceAccountTokenResponse(rsp)
}

// ListAvailableRegionsWithResponse request returning *ListAvailableRegionsResponse
func (c *ClientWithResponses) ListAvailableRegionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAvailableRegionsResponse, error) {
	rsp, err := c.ListAvailableRegions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAvailableRegionsResponse(rsp)
}

// GetClientsForOrgWithResponse request returning *GetClientsForOrgResponse
func (c *ClientWithResponses) GetClientsForOrgWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClientsForOrgResponse, error) {
	rsp, err := c.GetClientsForOrg(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientsForOrgResponse(rsp)
}

// GenerateTokenForClientWithBodyWithResponse request with arbitrary body returning *GenerateTokenForClientResponse
func (c *ClientWithResponses) GenerateTokenForClientWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateTokenForClientResponse, error) {
	rsp, err := c.GenerateTokenForClientWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateTokenForClientResponse(rsp)
}

func (c *ClientWithResponses) GenerateTokenForClientWithResponse(ctx context.Context, body GenerateTokenForClientJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateTokenForClientResponse, error) {
	rsp, err := c.GenerateTokenForClient(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateTokenForClientResponse(rsp)
}

// DeleteTokenForClientWithResponse request returning *DeleteTokenForClientResponse
func (c *ClientWithResponses) DeleteTokenForClientWithResponse(ctx context.Context, clientId ClientIdParam, reqEditors ...RequestEditorFn) (*DeleteTokenForClientResponse, error) {
	rsp, err := c.DeleteTokenForClient(ctx, clientId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTokenForClientResponse(rsp)
}

// GetCurrentOrganizationWithResponse request returning *GetCurrentOrganizationResponse
func (c *ClientWithResponses) GetCurrentOrganizationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentOrganizationResponse, error) {
	rsp, err := c.GetCurrentOrganization(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentOrganizationResponse(rsp)
}

// ListDatabasesWithResponse request returning *ListDatabasesResponse
func (c *ClientWithResponses) ListDatabasesWithResponse(ctx context.Context, params *ListDatabasesParams, reqEditors ...RequestEditorFn) (*ListDatabasesResponse, error) {
	rsp, err := c.ListDatabases(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDatabasesResponse(rsp)
}

// CreateDatabaseWithBodyWithResponse request with arbitrary body returning *CreateDatabaseResponse
func (c *ClientWithResponses) CreateDatabaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseResponse, error) {
	rsp, err := c.CreateDatabaseWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseResponse(rsp)
}

func (c *ClientWithResponses) CreateDatabaseWithResponse(ctx context.Context, body CreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseResponse, error) {
	rsp, err := c.CreateDatabase(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseResponse(rsp)
}

// GetDatabaseWithResponse request returning *GetDatabaseResponse
func (c *ClientWithResponses) GetDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*GetDatabaseResponse, error) {
	rsp, err := c.GetDatabase(ctx, databaseId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatabaseResponse(rsp)
}

// DeleteAddressesOrAccessListForDatabaseWithResponse request returning *DeleteAddressesOrAccessListForDatabaseResponse
func (c *ClientWithResponses) DeleteAddressesOrAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, params *DeleteAddressesOrAccessListForDatabaseParams, reqEditors ...RequestEditorFn) (*DeleteAddressesOrAccessListForDatabaseResponse, error) {
	rsp, err := c.DeleteAddressesOrAccessListForDatabase(ctx, databaseId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAddressesOrAccessListForDatabaseResponse(rsp)
}

// GetAccessListForDatabaseWithResponse request returning *GetAccessListForDatabaseResponse
func (c *ClientWithResponses) GetAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*GetAccessListForDatabaseResponse, error) {
	rsp, err := c.GetAccessListForDatabase(ctx, databaseId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccessListForDatabaseResponse(rsp)
}

// UpdateAccessListForDatabaseWithBodyWithResponse request with arbitrary body returning *UpdateAccessListForDatabaseResponse
func (c *ClientWithResponses) UpdateAccessListForDatabaseWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccessListForDatabaseResponse, error) {
	rsp, err := c.UpdateAccessListForDatabaseWithBody(ctx, databaseId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccessListForDatabaseResponse(rsp)
}

func (c *ClientWithResponses) UpdateAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, body UpdateAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccessListForDatabaseResponse, error) {
	rsp, err := c.UpdateAccessListForDatabase(ctx, databaseId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccessListForDatabaseResponse(rsp)
}

// AddAddressesToAccessListForDatabaseWithBodyWithResponse request with arbitrary body returning *AddAddressesToAccessListForDatabaseResponse
func (c *ClientWithResponses) AddAddressesToAccessListForDatabaseWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddAddressesToAccessListForDatabaseResponse, error) {
	rsp, err := c.AddAddressesToAccessListForDatabaseWithBody(ctx, databaseId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddAddressesToAccessListForDatabaseResponse(rsp)
}

func (c *ClientWithResponses) AddAddressesToAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, body AddAddressesToAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*AddAddressesToAccessListForDatabaseResponse, error) {
	rsp, err := c.AddAddressesToAccessListForDatabase(ctx, databaseId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddAddressesToAccessListForDatabaseResponse(rsp)
}

// UpsertAccessListForDatabaseWithBodyWithResponse request with arbitrary body returning *UpsertAccessListForDatabaseResponse
func (c *ClientWithResponses) UpsertAccessListForDatabaseWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertAccessListForDatabaseResponse, error) {
	rsp, err := c.UpsertAccessListForDatabaseWithBody(ctx, databaseId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertAccessListForDatabaseResponse(rsp)
}

func (c *ClientWithResponses) UpsertAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, body UpsertAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertAccessListForDatabaseResponse, error) {
	rsp, err := c.UpsertAccessListForDatabase(ctx, databaseId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertAccessListForDatabaseResponse(rsp)
}

// ListDatacentersWithResponse request returning *ListDatacentersResponse
func (c *ClientWithResponses) ListDatacentersWithResponse(ctx context.Context, databaseId DatabaseIdParam, params *ListDatacentersParams, reqEditors ...RequestEditorFn) (*ListDatacentersResponse, error) {
	rsp, err := c.ListDatacenters(ctx, databaseId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDatacentersResponse(rsp)
}

// AddDatacentersWithBodyWithResponse request with arbitrary body returning *AddDatacentersResponse
func (c *ClientWithResponses) AddDatacentersWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddDatacentersResponse, error) {
	rsp, err := c.AddDatacentersWithBody(ctx, databaseId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddDatacentersResponse(rsp)
}

func (c *ClientWithResponses) AddDatacentersWithResponse(ctx context.Context, databaseId DatabaseIdParam, body AddDatacentersJSONRequestBody, reqEditors ...RequestEditorFn) (*AddDatacentersResponse, error) {
	rsp, err := c.AddDatacenters(ctx, databaseId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddDatacentersResponse(rsp)
}

// TerminateDatacenterWithResponse request returning *TerminateDatacenterResponse
func (c *ClientWithResponses) TerminateDatacenterWithResponse(ctx context.Context, databaseId DatabaseIdParam, datacenterId DatacenterIdParam, reqEditors ...RequestEditorFn) (*TerminateDatacenterResponse, error) {
	rsp, err := c.TerminateDatacenter(ctx, databaseId, datacenterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTerminateDatacenterResponse(rsp)
}

// DropKeyspaceWithResponse request returning *DropKeyspaceResponse
func (c *ClientWithResponses) DropKeyspaceWithResponse(ctx context.Context, databaseId DatabaseIdParam, keyspaceName KeyspaceNameParam, reqEditors ...RequestEditorFn) (*DropKeyspaceResponse, error) {
	rsp, err := c.DropKeyspace(ctx, databaseId, keyspaceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDropKeyspaceResponse(rsp)
}

// AddKeyspaceWithResponse request returning *AddKeyspaceResponse
func (c *ClientWithResponses) AddKeyspaceWithResponse(ctx context.Context, databaseId DatabaseIdParam, keyspaceName KeyspaceNameParam, reqEditors ...RequestEditorFn) (*AddKeyspaceResponse, error) {
	rsp, err := c.AddKeyspace(ctx, databaseId, keyspaceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddKeyspaceResponse(rsp)
}

// RemoveMigrationProxyWithResponse request returning *RemoveMigrationProxyResponse
func (c *ClientWithResponses) RemoveMigrationProxyWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*RemoveMigrationProxyResponse, error) {
	rsp, err := c.RemoveMigrationProxy(ctx, databaseId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveMigrationProxyResponse(rsp)
}

// LaunchMigrationProxyWithBodyWithResponse request with arbitrary body returning *LaunchMigrationProxyResponse
func (c *ClientWithResponses) LaunchMigrationProxyWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LaunchMigrationProxyResponse, error) {
	rsp, err := c.LaunchMigrationProxyWithBody(ctx, databaseId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLaunchMigrationProxyResponse(rsp)
}

func (c *ClientWithResponses) LaunchMigrationProxyWithResponse(ctx context.Context, databaseId DatabaseIdParam, body LaunchMigrationProxyJSONRequestBody, reqEditors ...RequestEditorFn) (*LaunchMigrationProxyResponse, error) {
	rsp, err := c.LaunchMigrationProxy(ctx, databaseId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLaunchMigrationProxyResponse(rsp)
}

// ParkDatabaseWithResponse request returning *ParkDatabaseResponse
func (c *ClientWithResponses) ParkDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*ParkDatabaseResponse, error) {
	rsp, err := c.ParkDatabase(ctx, databaseId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseParkDatabaseResponse(rsp)
}

// ResetPasswordWithBodyWithResponse request with arbitrary body returning *ResetPasswordResponse
func (c *ClientWithResponses) ResetPasswordWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error) {
	rsp, err := c.ResetPasswordWithBody(ctx, databaseId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPasswordResponse(rsp)
}

func (c *ClientWithResponses) ResetPasswordWithResponse(ctx context.Context, databaseId DatabaseIdParam, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error) {
	rsp, err := c.ResetPassword(ctx, databaseId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPasswordResponse(rsp)
}

// ResizeDatabaseWithBodyWithResponse request with arbitrary body returning *ResizeDatabaseResponse
func (c *ClientWithResponses) ResizeDatabaseWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResizeDatabaseResponse, error) {
	rsp, err := c.ResizeDatabaseWithBody(ctx, databaseId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResizeDatabaseResponse(rsp)
}

func (c *ClientWithResponses) ResizeDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, body ResizeDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*ResizeDatabaseResponse, error) {
	rsp, err := c.ResizeDatabase(ctx, databaseId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResizeDatabaseResponse(rsp)
}

// GenerateSecureBundleURLWithResponse request returning *GenerateSecureBundleURLResponse
func (c *ClientWithResponses) GenerateSecureBundleURLWithResponse(ctx context.Context, databaseId DatabaseIdParam, params *GenerateSecureBundleURLParams, reqEditors ...RequestEditorFn) (*GenerateSecureBundleURLResponse, error) {
	rsp, err := c.GenerateSecureBundleURL(ctx, databaseId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateSecureBundleURLResponse(rsp)
}

// TerminateDatabaseWithResponse request returning *TerminateDatabaseResponse
func (c *ClientWithResponses) TerminateDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, params *TerminateDatabaseParams, reqEditors ...RequestEditorFn) (*TerminateDatabaseResponse, error) {
	rsp, err := c.TerminateDatabase(ctx, databaseId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTerminateDatabaseResponse(rsp)
}

// ConfigureMetricsExportWithBodyWithResponse request with arbitrary body returning *ConfigureMetricsExportResponse
func (c *ClientWithResponses) ConfigureMetricsExportWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfigureMetricsExportResponse, error) {
	rsp, err := c.ConfigureMetricsExportWithBody(ctx, databaseId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfigureMetricsExportResponse(rsp)
}

func (c *ClientWithResponses) ConfigureMetricsExportWithResponse(ctx context.Context, databaseId DatabaseIdParam, body ConfigureMetricsExportJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfigureMetricsExportResponse, error) {
	rsp, err := c.ConfigureMetricsExport(ctx, databaseId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfigureMetricsExportResponse(rsp)
}

// UnparkDatabaseWithResponse request returning *UnparkDatabaseResponse
func (c *ClientWithResponses) UnparkDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*UnparkDatabaseResponse, error) {
	rsp, err := c.UnparkDatabase(ctx, databaseId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnparkDatabaseResponse(rsp)
}

// ListKeysWithResponse request returning *ListKeysResponse
func (c *ClientWithResponses) ListKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListKeysResponse, error) {
	rsp, err := c.ListKeys(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListKeysResponse(rsp)
}

// CreateKeyWithBodyWithResponse request with arbitrary body returning *CreateKeyResponse
func (c *ClientWithResponses) CreateKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeyResponse, error) {
	rsp, err := c.CreateKeyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeyResponse(rsp)
}

func (c *ClientWithResponses) CreateKeyWithResponse(ctx context.Context, body CreateKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeyResponse, error) {
	rsp, err := c.CreateKey(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeyResponse(rsp)
}

// GetServerlessKeyWithResponse request returning *GetServerlessKeyResponse
func (c *ClientWithResponses) GetServerlessKeyWithResponse(ctx context.Context, provider string, region string, reqEditors ...RequestEditorFn) (*GetServerlessKeyResponse, error) {
	rsp, err := c.GetServerlessKey(ctx, provider, region, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerlessKeyResponse(rsp)
}

// GetCloudAccountsWithResponse request returning *GetCloudAccountsResponse
func (c *ClientWithResponses) GetCloudAccountsWithResponse(ctx context.Context, provider string, region string, reqEditors ...RequestEditorFn) (*GetCloudAccountsResponse, error) {
	rsp, err := c.GetCloudAccounts(ctx, provider, region, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCloudAccountsResponse(rsp)
}

// RemoveAllowedPrincipalFromServiceWithBodyWithResponse request with arbitrary body returning *RemoveAllowedPrincipalFromServiceResponse
func (c *ClientWithResponses) RemoveAllowedPrincipalFromServiceWithBodyWithResponse(ctx context.Context, clusterID string, datacenterID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveAllowedPrincipalFromServiceResponse, error) {
	rsp, err := c.RemoveAllowedPrincipalFromServiceWithBody(ctx, clusterID, datacenterID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveAllowedPrincipalFromServiceResponse(rsp)
}

func (c *ClientWithResponses) RemoveAllowedPrincipalFromServiceWithResponse(ctx context.Context, clusterID string, datacenterID string, body RemoveAllowedPrincipalFromServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveAllowedPrincipalFromServiceResponse, error) {
	rsp, err := c.RemoveAllowedPrincipalFromService(ctx, clusterID, datacenterID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveAllowedPrincipalFromServiceResponse(rsp)
}

// AddAllowedPrincipalWithBodyWithResponse request with arbitrary body returning *AddAllowedPrincipalResponse
func (c *ClientWithResponses) AddAllowedPrincipalWithBodyWithResponse(ctx context.Context, clusterID string, datacenterID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddAllowedPrincipalResponse, error) {
	rsp, err := c.AddAllowedPrincipalWithBody(ctx, clusterID, datacenterID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddAllowedPrincipalResponse(rsp)
}

func (c *ClientWithResponses) AddAllowedPrincipalWithResponse(ctx context.Context, clusterID string, datacenterID string, body AddAllowedPrincipalJSONRequestBody, reqEditors ...RequestEditorFn) (*AddAllowedPrincipalResponse, error) {
	rsp, err := c.AddAllowedPrincipal(ctx, clusterID, datacenterID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddAllowedPrincipalResponse(rsp)
}

// AcceptEndpointToServiceWithBodyWithResponse request with arbitrary body returning *AcceptEndpointToServiceResponse
func (c *ClientWithResponses) AcceptEndpointToServiceWithBodyWithResponse(ctx context.Context, clusterID string, datacenterID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AcceptEndpointToServiceResponse, error) {
	rsp, err := c.AcceptEndpointToServiceWithBody(ctx, clusterID, datacenterID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptEndpointToServiceResponse(rsp)
}

func (c *ClientWithResponses) AcceptEndpointToServiceWithResponse(ctx context.Context, clusterID string, datacenterID string, body AcceptEndpointToServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*AcceptEndpointToServiceResponse, error) {
	rsp, err := c.AcceptEndpointToService(ctx, clusterID, datacenterID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptEndpointToServiceResponse(rsp)
}

// RejectEndpointWithResponse request returning *RejectEndpointResponse
func (c *ClientWithResponses) RejectEndpointWithResponse(ctx context.Context, clusterID string, datacenterID string, endpointID string, reqEditors ...RequestEditorFn) (*RejectEndpointResponse, error) {
	rsp, err := c.RejectEndpoint(ctx, clusterID, datacenterID, endpointID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRejectEndpointResponse(rsp)
}

// GetPrivateLinkEndpointWithResponse request returning *GetPrivateLinkEndpointResponse
func (c *ClientWithResponses) GetPrivateLinkEndpointWithResponse(ctx context.Context, clusterID string, datacenterID string, endpointID string, reqEditors ...RequestEditorFn) (*GetPrivateLinkEndpointResponse, error) {
	rsp, err := c.GetPrivateLinkEndpoint(ctx, clusterID, datacenterID, endpointID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPrivateLinkEndpointResponse(rsp)
}

// UpdateEndpointDescriptionWithBodyWithResponse request with arbitrary body returning *UpdateEndpointDescriptionResponse
func (c *ClientWithResponses) UpdateEndpointDescriptionWithBodyWithResponse(ctx context.Context, clusterID string, datacenterID string, endpointID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEndpointDescriptionResponse, error) {
	rsp, err := c.UpdateEndpointDescriptionWithBody(ctx, clusterID, datacenterID, endpointID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEndpointDescriptionResponse(rsp)
}

func (c *ClientWithResponses) UpdateEndpointDescriptionWithResponse(ctx context.Context, clusterID string, datacenterID string, endpointID string, body UpdateEndpointDescriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEndpointDescriptionResponse, error) {
	rsp, err := c.UpdateEndpointDescription(ctx, clusterID, datacenterID, endpointID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEndpointDescriptionResponse(rsp)
}

// GetPrivateLinksForDatacenterWithResponse request returning *GetPrivateLinksForDatacenterResponse
func (c *ClientWithResponses) GetPrivateLinksForDatacenterWithResponse(ctx context.Context, clusterID string, datacenterID string, reqEditors ...RequestEditorFn) (*GetPrivateLinksForDatacenterResponse, error) {
	rsp, err := c.GetPrivateLinksForDatacenter(ctx, clusterID, datacenterID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPrivateLinksForDatacenterResponse(rsp)
}

// AddAllowedPrincipalToServiceWithBodyWithResponse request with arbitrary body returning *AddAllowedPrincipalToServiceResponse
func (c *ClientWithResponses) AddAllowedPrincipalToServiceWithBodyWithResponse(ctx context.Context, clusterID string, datacenterID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddAllowedPrincipalToServiceResponse, error) {
	rsp, err := c.AddAllowedPrincipalToServiceWithBody(ctx, clusterID, datacenterID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddAllowedPrincipalToServiceResponse(rsp)
}

func (c *ClientWithResponses) AddAllowedPrincipalToServiceWithResponse(ctx context.Context, clusterID string, datacenterID string, body AddAllowedPrincipalToServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*AddAllowedPrincipalToServiceResponse, error) {
	rsp, err := c.AddAllowedPrincipalToService(ctx, clusterID, datacenterID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddAllowedPrincipalToServiceResponse(rsp)
}

// ListPrivateLinksForClusterWithResponse request returning *ListPrivateLinksForClusterResponse
func (c *ClientWithResponses) ListPrivateLinksForClusterWithResponse(ctx context.Context, clusterID string, reqEditors ...RequestEditorFn) (*ListPrivateLinksForClusterResponse, error) {
	rsp, err := c.ListPrivateLinksForCluster(ctx, clusterID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPrivateLinksForClusterResponse(rsp)
}

// ListPrivateLinksForOrgWithResponse request returning *ListPrivateLinksForOrgResponse
func (c *ClientWithResponses) ListPrivateLinksForOrgWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListPrivateLinksForOrgResponse, error) {
	rsp, err := c.ListPrivateLinksForOrg(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPrivateLinksForOrgResponse(rsp)
}

// GetOrganizationRolesWithResponse request returning *GetOrganizationRolesResponse
func (c *ClientWithResponses) GetOrganizationRolesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOrganizationRolesResponse, error) {
	rsp, err := c.GetOrganizationRoles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationRolesResponse(rsp)
}

// AddOrganizationRoleWithBodyWithResponse request with arbitrary body returning *AddOrganizationRoleResponse
func (c *ClientWithResponses) AddOrganizationRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrganizationRoleResponse, error) {
	rsp, err := c.AddOrganizationRoleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrganizationRoleResponse(rsp)
}

func (c *ClientWithResponses) AddOrganizationRoleWithResponse(ctx context.Context, body AddOrganizationRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrganizationRoleResponse, error) {
	rsp, err := c.AddOrganizationRole(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrganizationRoleResponse(rsp)
}

// DeleteOrganizationRoleWithResponse request returning *DeleteOrganizationRoleResponse
func (c *ClientWithResponses) DeleteOrganizationRoleWithResponse(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*DeleteOrganizationRoleResponse, error) {
	rsp, err := c.DeleteOrganizationRole(ctx, roleID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOrganizationRoleResponse(rsp)
}

// GetOrganizationRoleWithResponse request returning *GetOrganizationRoleResponse
func (c *ClientWithResponses) GetOrganizationRoleWithResponse(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*GetOrganizationRoleResponse, error) {
	rsp, err := c.GetOrganizationRole(ctx, roleID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationRoleResponse(rsp)
}

// UpdateRoleWithBodyWithResponse request with arbitrary body returning *UpdateRoleResponse
func (c *ClientWithResponses) UpdateRoleWithBodyWithResponse(ctx context.Context, roleID RoleIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error) {
	rsp, err := c.UpdateRoleWithBody(ctx, roleID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleResponse(rsp)
}

func (c *ClientWithResponses) UpdateRoleWithResponse(ctx context.Context, roleID RoleIdParam, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error) {
	rsp, err := c.UpdateRole(ctx, roleID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleResponse(rsp)
}

// GetOrganizationUsersWithResponse request returning *GetOrganizationUsersResponse
func (c *ClientWithResponses) GetOrganizationUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOrganizationUsersResponse, error) {
	rsp, err := c.GetOrganizationUsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationUsersResponse(rsp)
}

// InviteUserToOrganizationWithBodyWithResponse request with arbitrary body returning *InviteUserToOrganizationResponse
func (c *ClientWithResponses) InviteUserToOrganizationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteUserToOrganizationResponse, error) {
	rsp, err := c.InviteUserToOrganizationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteUserToOrganizationResponse(rsp)
}

func (c *ClientWithResponses) InviteUserToOrganizationWithResponse(ctx context.Context, body InviteUserToOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteUserToOrganizationResponse, error) {
	rsp, err := c.InviteUserToOrganization(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteUserToOrganizationResponse(rsp)
}

// RemoveUserFromOrganizationWithResponse request returning *RemoveUserFromOrganizationResponse
func (c *ClientWithResponses) RemoveUserFromOrganizationWithResponse(ctx context.Context, userID UserIdParam, reqEditors ...RequestEditorFn) (*RemoveUserFromOrganizationResponse, error) {
	rsp, err := c.RemoveUserFromOrganization(ctx, userID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUserFromOrganizationResponse(rsp)
}

// GetOrganizationUserWithResponse request returning *GetOrganizationUserResponse
func (c *ClientWithResponses) GetOrganizationUserWithResponse(ctx context.Context, userID UserIdParam, reqEditors ...RequestEditorFn) (*GetOrganizationUserResponse, error) {
	rsp, err := c.GetOrganizationUser(ctx, userID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationUserResponse(rsp)
}

// UpdateRolesForUserInOrganizationWithBodyWithResponse request with arbitrary body returning *UpdateRolesForUserInOrganizationResponse
func (c *ClientWithResponses) UpdateRolesForUserInOrganizationWithBodyWithResponse(ctx context.Context, userID UserIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRolesForUserInOrganizationResponse, error) {
	rsp, err := c.UpdateRolesForUserInOrganizationWithBody(ctx, userID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRolesForUserInOrganizationResponse(rsp)
}

func (c *ClientWithResponses) UpdateRolesForUserInOrganizationWithResponse(ctx context.Context, userID UserIdParam, body UpdateRolesForUserInOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRolesForUserInOrganizationResponse, error) {
	rsp, err := c.UpdateRolesForUserInOrganization(ctx, userID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRolesForUserInOrganizationResponse(rsp)
}

// DeleteVPCPeeringConnectionWithResponse request returning *DeleteVPCPeeringConnectionResponse
func (c *ClientWithResponses) DeleteVPCPeeringConnectionWithResponse(ctx context.Context, provider DeleteVPCPeeringConnectionParamsProvider, databaseID string, reqEditors ...RequestEditorFn) (*DeleteVPCPeeringConnectionResponse, error) {
	rsp, err := c.DeleteVPCPeeringConnection(ctx, provider, databaseID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVPCPeeringConnectionResponse(rsp)
}

// GetVPCPeeringConnectionDetailsWithResponse request returning *GetVPCPeeringConnectionDetailsResponse
func (c *ClientWithResponses) GetVPCPeeringConnectionDetailsWithResponse(ctx context.Context, provider GetVPCPeeringConnectionDetailsParamsProvider, databaseID string, reqEditors ...RequestEditorFn) (*GetVPCPeeringConnectionDetailsResponse, error) {
	rsp, err := c.GetVPCPeeringConnectionDetails(ctx, provider, databaseID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVPCPeeringConnectionDetailsResponse(rsp)
}

// CreateVPCPeeringConnectionWithBodyWithResponse request with arbitrary body returning *CreateVPCPeeringConnectionResponse
func (c *ClientWithResponses) CreateVPCPeeringConnectionWithBodyWithResponse(ctx context.Context, provider CreateVPCPeeringConnectionParamsProvider, databaseID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVPCPeeringConnectionResponse, error) {
	rsp, err := c.CreateVPCPeeringConnectionWithBody(ctx, provider, databaseID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVPCPeeringConnectionResponse(rsp)
}

func (c *ClientWithResponses) CreateVPCPeeringConnectionWithResponse(ctx context.Context, provider CreateVPCPeeringConnectionParamsProvider, databaseID string, body CreateVPCPeeringConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVPCPeeringConnectionResponse, error) {
	rsp, err := c.CreateVPCPeeringConnection(ctx, provider, databaseID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVPCPeeringConnectionResponse(rsp)
}

// ListServerlessRegionsWithResponse request returning *ListServerlessRegionsResponse
func (c *ClientWithResponses) ListServerlessRegionsWithResponse(ctx context.Context, params *ListServerlessRegionsParams, reqEditors ...RequestEditorFn) (*ListServerlessRegionsResponse, error) {
	rsp, err := c.ListServerlessRegions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServerlessRegionsResponse(rsp)
}

// ParseGetAccessListTemplateResponse parses an HTTP response from a GetAccessListTemplateWithResponse call
func ParseGetAccessListTemplateResponse(rsp *http.Response) (*GetAccessListTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccessListTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccessListRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseValidateAccessListResponse parses an HTTP response from a ValidateAccessListWithResponse call
func ParseValidateAccessListResponse(rsp *http.Response) (*ValidateAccessListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateAccessListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ValidationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAllAccessListsForOrganizationResponse parses an HTTP response from a GetAllAccessListsForOrganizationWithResponse call
func ParseGetAllAccessListsForOrganizationResponse(rsp *http.Response) (*GetAllAccessListsForOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllAccessListsForOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AccessListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthenticateServiceAccountTokenResponse parses an HTTP response from a AuthenticateServiceAccountTokenWithResponse call
func ParseAuthenticateServiceAccountTokenResponse(rsp *http.Response) (*AuthenticateServiceAccountTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthenticateServiceAccountTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceAccountTokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseListAvailableRegionsResponse parses an HTTP response from a ListAvailableRegionsWithResponse call
func ParseListAvailableRegionsResponse(rsp *http.Response) (*ListAvailableRegionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAvailableRegionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AvailableRegionCombination
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetClientsForOrgResponse parses an HTTP response from a GetClientsForOrgWithResponse call
func ParseGetClientsForOrgResponse(rsp *http.Response) (*GetClientsForOrgResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientsForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGenerateTokenForClientResponse parses an HTTP response from a GenerateTokenForClientWithResponse call
func ParseGenerateTokenForClientResponse(rsp *http.Response) (*GenerateTokenForClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateTokenForClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteTokenForClientResponse parses an HTTP response from a DeleteTokenForClientWithResponse call
func ParseDeleteTokenForClientResponse(rsp *http.Response) (*DeleteTokenForClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTokenForClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCurrentOrganizationResponse parses an HTTP response from a GetCurrentOrganizationWithResponse call
func ParseGetCurrentOrganizationResponse(rsp *http.Response) (*GetCurrentOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Organization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListDatabasesResponse parses an HTTP response from a ListDatabasesWithResponse call
func ParseListDatabasesResponse(rsp *http.Response) (*ListDatabasesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDatabasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Database
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseCreateDatabaseResponse parses an HTTP response from a CreateDatabaseWithResponse call
func ParseCreateDatabaseResponse(rsp *http.Response) (*CreateDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDatabaseResponse parses an HTTP response from a GetDatabaseWithResponse call
func ParseGetDatabaseResponse(rsp *http.Response) (*GetDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Database
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseDeleteAddressesOrAccessListForDatabaseResponse parses an HTTP response from a DeleteAddressesOrAccessListForDatabaseWithResponse call
func ParseDeleteAddressesOrAccessListForDatabaseResponse(rsp *http.Response) (*DeleteAddressesOrAccessListForDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAddressesOrAccessListForDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAccessListForDatabaseResponse parses an HTTP response from a GetAccessListForDatabaseWithResponse call
func ParseGetAccessListForDatabaseResponse(rsp *http.Response) (*GetAccessListForDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccessListForDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccessListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAccessListForDatabaseResponse parses an HTTP response from a UpdateAccessListForDatabaseWithResponse call
func ParseUpdateAccessListForDatabaseResponse(rsp *http.Response) (*UpdateAccessListForDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAccessListForDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddAddressesToAccessListForDatabaseResponse parses an HTTP response from a AddAddressesToAccessListForDatabaseWithResponse call
func ParseAddAddressesToAccessListForDatabaseResponse(rsp *http.Response) (*AddAddressesToAccessListForDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddAddressesToAccessListForDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpsertAccessListForDatabaseResponse parses an HTTP response from a UpsertAccessListForDatabaseWithResponse call
func ParseUpsertAccessListForDatabaseResponse(rsp *http.Response) (*UpsertAccessListForDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertAccessListForDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListDatacentersResponse parses an HTTP response from a ListDatacentersWithResponse call
func ParseListDatacentersResponse(rsp *http.Response) (*ListDatacentersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDatacentersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Datacenter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseAddDatacentersResponse parses an HTTP response from a AddDatacentersWithResponse call
func ParseAddDatacentersResponse(rsp *http.Response) (*AddDatacentersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddDatacentersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseTerminateDatacenterResponse parses an HTTP response from a TerminateDatacenterWithResponse call
func ParseTerminateDatacenterResponse(rsp *http.Response) (*TerminateDatacenterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TerminateDatacenterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseDropKeyspaceResponse parses an HTTP response from a DropKeyspaceWithResponse call
func ParseDropKeyspaceResponse(rsp *http.Response) (*DropKeyspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DropKeyspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseAddKeyspaceResponse parses an HTTP response from a AddKeyspaceWithResponse call
func ParseAddKeyspaceResponse(rsp *http.Response) (*AddKeyspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddKeyspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseRemoveMigrationProxyResponse parses an HTTP response from a RemoveMigrationProxyWithResponse call
func ParseRemoveMigrationProxyResponse(rsp *http.Response) (*RemoveMigrationProxyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveMigrationProxyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseLaunchMigrationProxyResponse parses an HTTP response from a LaunchMigrationProxyWithResponse call
func ParseLaunchMigrationProxyResponse(rsp *http.Response) (*LaunchMigrationProxyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LaunchMigrationProxyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseParkDatabaseResponse parses an HTTP response from a ParkDatabaseWithResponse call
func ParseParkDatabaseResponse(rsp *http.Response) (*ParkDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ParkDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseResetPasswordResponse parses an HTTP response from a ResetPasswordWithResponse call
func ParseResetPasswordResponse(rsp *http.Response) (*ResetPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseResizeDatabaseResponse parses an HTTP response from a ResizeDatabaseWithResponse call
func ParseResizeDatabaseResponse(rsp *http.Response) (*ResizeDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResizeDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGenerateSecureBundleURLResponse parses an HTTP response from a GenerateSecureBundleURLWithResponse call
func ParseGenerateSecureBundleURLResponse(rsp *http.Response) (*GenerateSecureBundleURLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateSecureBundleURLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		// response can be either a JSON array or a single JSON document
		// try to decode as a single document first, and if unmarshalling fails, assume an array
		var destObj CredsURL
		err := json.Unmarshal(bodyBytes, &destObj);
		if err == nil {
			response.JSON200 = &SecureBundles{destObj}
		} else {
			var destArr SecureBundles
			err = json.Unmarshal(bodyBytes, &destArr)
			if err == nil {
				response.JSON200 = &destArr
			}
		}
		if err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseTerminateDatabaseResponse parses an HTTP response from a TerminateDatabaseWithResponse call
func ParseTerminateDatabaseResponse(rsp *http.Response) (*TerminateDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TerminateDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseConfigureMetricsExportResponse parses an HTTP response from a ConfigureMetricsExportWithResponse call
func ParseConfigureMetricsExportResponse(rsp *http.Response) (*ConfigureMetricsExportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfigureMetricsExportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CredsURL
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseUnparkDatabaseResponse parses an HTTP response from a UnparkDatabaseWithResponse call
func ParseUnparkDatabaseResponse(rsp *http.Response) (*UnparkDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnparkDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseListKeysResponse parses an HTTP response from a ListKeysWithResponse call
func ParseListKeysResponse(rsp *http.Response) (*ListKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAllCustomerKeys
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateKeyResponse parses an HTTP response from a CreateKeyWithResponse call
func ParseCreateKeyResponse(rsp *http.Response) (*CreateKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetServerlessKeyResponse parses an HTTP response from a GetServerlessKeyWithResponse call
func ParseGetServerlessKeyResponse(rsp *http.Response) (*GetServerlessKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerlessKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetParticularCustomerKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCloudAccountsResponse parses an HTTP response from a GetCloudAccountsWithResponse call
func ParseGetCloudAccountsResponse(rsp *http.Response) (*GetCloudAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCloudAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCloudProviderAccounts
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRemoveAllowedPrincipalFromServiceResponse parses an HTTP response from a RemoveAllowedPrincipalFromServiceWithResponse call
func ParseRemoveAllowedPrincipalFromServiceResponse(rsp *http.Response) (*RemoveAllowedPrincipalFromServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveAllowedPrincipalFromServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddAllowedPrincipalResponse parses an HTTP response from a AddAllowedPrincipalWithResponse call
func ParseAddAllowedPrincipalResponse(rsp *http.Response) (*AddAllowedPrincipalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddAllowedPrincipalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PrivateLinkCreateConfigOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAcceptEndpointToServiceResponse parses an HTTP response from a AcceptEndpointToServiceWithResponse call
func ParseAcceptEndpointToServiceResponse(rsp *http.Response) (*AcceptEndpointToServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcceptEndpointToServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PrivateLinkEndpoint
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRejectEndpointResponse parses an HTTP response from a RejectEndpointWithResponse call
func ParseRejectEndpointResponse(rsp *http.Response) (*RejectEndpointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RejectEndpointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPrivateLinkEndpointResponse parses an HTTP response from a GetPrivateLinkEndpointWithResponse call
func ParseGetPrivateLinkEndpointResponse(rsp *http.Response) (*GetPrivateLinkEndpointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPrivateLinkEndpointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PrivateLinkEndpoint
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateEndpointDescriptionResponse parses an HTTP response from a UpdateEndpointDescriptionWithResponse call
func ParseUpdateEndpointDescriptionResponse(rsp *http.Response) (*UpdateEndpointDescriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEndpointDescriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PrivateLinkEndpoint
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPrivateLinksForDatacenterResponse parses an HTTP response from a GetPrivateLinksForDatacenterWithResponse call
func ParseGetPrivateLinksForDatacenterResponse(rsp *http.Response) (*GetPrivateLinksForDatacenterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPrivateLinksForDatacenterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PrivateLinkDatacenterOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddAllowedPrincipalToServiceResponse parses an HTTP response from a AddAllowedPrincipalToServiceWithResponse call
func ParseAddAllowedPrincipalToServiceResponse(rsp *http.Response) (*AddAllowedPrincipalToServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddAllowedPrincipalToServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PrivateLinkCreateConfigOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPrivateLinksForClusterResponse parses an HTTP response from a ListPrivateLinksForClusterWithResponse call
func ParseListPrivateLinksForClusterResponse(rsp *http.Response) (*ListPrivateLinksForClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPrivateLinksForClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PrivateLinkClusterOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPrivateLinksForOrgResponse parses an HTTP response from a ListPrivateLinksForOrgWithResponse call
func ParseListPrivateLinksForOrgResponse(rsp *http.Response) (*ListPrivateLinksForOrgResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPrivateLinksForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PrivateLinkOrgOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetOrganizationRolesResponse parses an HTTP response from a GetOrganizationRolesWithResponse call
func ParseGetOrganizationRolesResponse(rsp *http.Response) (*GetOrganizationRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddOrganizationRoleResponse parses an HTTP response from a AddOrganizationRoleWithResponse call
func ParseAddOrganizationRoleResponse(rsp *http.Response) (*AddOrganizationRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddOrganizationRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteOrganizationRoleResponse parses an HTTP response from a DeleteOrganizationRoleWithResponse call
func ParseDeleteOrganizationRoleResponse(rsp *http.Response) (*DeleteOrganizationRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOrganizationRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOrganizationRoleResponse parses an HTTP response from a GetOrganizationRoleWithResponse call
func ParseGetOrganizationRoleResponse(rsp *http.Response) (*GetOrganizationRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRoleResponse parses an HTTP response from a UpdateRoleWithResponse call
func ParseUpdateRoleResponse(rsp *http.Response) (*UpdateRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOrganizationUsersResponse parses an HTTP response from a GetOrganizationUsersWithResponse call
func ParseGetOrganizationUsersResponse(rsp *http.Response) (*GetOrganizationUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrganizationUsers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInviteUserToOrganizationResponse parses an HTTP response from a InviteUserToOrganizationWithResponse call
func ParseInviteUserToOrganizationResponse(rsp *http.Response) (*InviteUserToOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InviteUserToOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRemoveUserFromOrganizationResponse parses an HTTP response from a RemoveUserFromOrganizationWithResponse call
func ParseRemoveUserFromOrganizationResponse(rsp *http.Response) (*RemoveUserFromOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveUserFromOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOrganizationUserResponse parses an HTTP response from a GetOrganizationUserWithResponse call
func ParseGetOrganizationUserResponse(rsp *http.Response) (*GetOrganizationUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRolesForUserInOrganizationResponse parses an HTTP response from a UpdateRolesForUserInOrganizationWithResponse call
func ParseUpdateRolesForUserInOrganizationResponse(rsp *http.Response) (*UpdateRolesForUserInOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRolesForUserInOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteVPCPeeringConnectionResponse parses an HTTP response from a DeleteVPCPeeringConnectionWithResponse call
func ParseDeleteVPCPeeringConnectionResponse(rsp *http.Response) (*DeleteVPCPeeringConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVPCPeeringConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVPCPeeringConnectionDetailsResponse parses an HTTP response from a GetVPCPeeringConnectionDetailsWithResponse call
func ParseGetVPCPeeringConnectionDetailsResponse(rsp *http.Response) (*GetVPCPeeringConnectionDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVPCPeeringConnectionDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VPCConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseCreateVPCPeeringConnectionResponse parses an HTTP response from a CreateVPCPeeringConnectionWithResponse call
func ParseCreateVPCPeeringConnectionResponse(rsp *http.Response) (*CreateVPCPeeringConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVPCPeeringConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VPCConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListServerlessRegionsResponse parses an HTTP response from a ListServerlessRegionsWithResponse call
func ParseListServerlessRegionsResponse(rsp *http.Response) (*ListServerlessRegionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListServerlessRegionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ServerlessRegion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}
