// Package astrarestapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package astrarestapi

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

// Defines values for ClusteringExpressionOrder.
const (
	ASC  ClusteringExpressionOrder = "ASC"
	DESC ClusteringExpressionOrder = "DESC"
)

// Defines values for ColumnDefinitionTypeDefinition.
const (
	Ascii          ColumnDefinitionTypeDefinition = "ascii"
	Bigint         ColumnDefinitionTypeDefinition = "bigint"
	Blob           ColumnDefinitionTypeDefinition = "blob"
	Boolean        ColumnDefinitionTypeDefinition = "boolean"
	Counter        ColumnDefinitionTypeDefinition = "counter"
	Date           ColumnDefinitionTypeDefinition = "date"
	DateRangeType  ColumnDefinitionTypeDefinition = "DateRangeType"
	Decimal        ColumnDefinitionTypeDefinition = "decimal"
	Double         ColumnDefinitionTypeDefinition = "double"
	Duration       ColumnDefinitionTypeDefinition = "duration"
	Float          ColumnDefinitionTypeDefinition = "float"
	Frozen         ColumnDefinitionTypeDefinition = "frozen"
	Inet           ColumnDefinitionTypeDefinition = "inet"
	Int            ColumnDefinitionTypeDefinition = "int"
	LineStringType ColumnDefinitionTypeDefinition = "LineStringType"
	List           ColumnDefinitionTypeDefinition = "list"
	Map            ColumnDefinitionTypeDefinition = "map"
	PointType      ColumnDefinitionTypeDefinition = "PointType"
	PolygonType    ColumnDefinitionTypeDefinition = "PolygonType"
	Set            ColumnDefinitionTypeDefinition = "set"
	Smallint       ColumnDefinitionTypeDefinition = "smallint"
	Text           ColumnDefinitionTypeDefinition = "text"
	Time           ColumnDefinitionTypeDefinition = "time"
	Timestamp      ColumnDefinitionTypeDefinition = "timestamp"
	Timeuuid       ColumnDefinitionTypeDefinition = "timeuuid"
	Tinyint        ColumnDefinitionTypeDefinition = "tinyint"
	Tuple          ColumnDefinitionTypeDefinition = "tuple"
	Uuid           ColumnDefinitionTypeDefinition = "uuid"
	Varchar        ColumnDefinitionTypeDefinition = "varchar"
	Varint         ColumnDefinitionTypeDefinition = "varint"
)

// Defines values for IndexDefinitionKind.
const (
	ENTRIES IndexDefinitionKind = "ENTRIES"
	FULL    IndexDefinitionKind = "FULL"
	KEYS    IndexDefinitionKind = "KEYS"
	VALUES  IndexDefinitionKind = "VALUES"
)

// Defines values for IndexDefinitionType.
const (
	OrgApacheCassandraIndexSasiSASIIndex IndexDefinitionType = "org.apache.cassandra.index.sasi.SASIIndex"
	StorageAttachedIndex                 IndexDefinitionType = "StorageAttachedIndex"
)

// AuthTokenResponse defines model for AuthTokenResponse.
type AuthTokenResponse struct {
	AuthToken *string `json:"authToken,omitempty"`
}

// ClusteringExpression Order rows storage to make use of the on-disk sorting of columns. Specifying order can make query results more efficient.
type ClusteringExpression struct {
	// Column The name of the column to order by.
	Column string `json:"column"`

	// Order The clustering order.
	Order ClusteringExpressionOrder `json:"order"`
}

// ClusteringExpressionOrder The clustering order.
type ClusteringExpressionOrder string

// ColumnDefinition defines model for ColumnDefinition.
type ColumnDefinition struct {
	// Name Name for the column, which must be unique.
	Name string `json:"name"`

	// Static Denotes whether the column is shared by all rows of a partition.
	Static *bool `json:"static,omitempty"`

	// TypeDefinition The type of data allowed in the column.
	TypeDefinition ColumnDefinitionTypeDefinition `json:"typeDefinition"`
}

// ColumnDefinitionTypeDefinition The type of data allowed in the column.
type ColumnDefinitionTypeDefinition string

// Credentials User credentials for authenticating
type Credentials struct {
	// Password Password
	Password string `json:"password"`

	// Username Username
	Username string `json:"username"`
}

// Datacenter defines model for Datacenter.
type Datacenter struct {
	// Name The name of the datacenter.
	Name string `json:"name"`

	// Replicas The number of replicas in the datacenter. In other words, the number of copies of each row in the datacenter.
	Replicas int32 `json:"replicas"`
}

// Error A description of an error state
type Error struct {
	// Code The code referencing the error state
	Code *int32 `json:"code,omitempty"`

	// Description A human readable description of the error state
	Description  *string `json:"description,omitempty"`
	InternalTxId *string `json:"internalTxId,omitempty"`
}

// IndexDefinition defines model for IndexDefinition.
type IndexDefinition struct {
	// Column Column for which index will be created.
	Column string `json:"column"`

	// IfNotExists Determines creation of a new index, if an index with the same name exists. If an index exists, and this option is set to true, an error is returned.
	IfNotExists *bool `json:"ifNotExists,omitempty"`

	// Kind Index kind for collections.
	Kind *IndexDefinitionKind `json:"kind,omitempty"`

	// Name Optional name for the index, which must be unique. If no name is specified, the index is named as follows: tablename_columnname_idx.
	Name    *string            `json:"name,omitempty"`
	Options *map[string]string `json:"options,omitempty"`

	// Type Type of index, defined with a custom index class name or classpath. Secondary index is default, no type entered
	Type *IndexDefinitionType `json:"type,omitempty"`
}

// IndexDefinitionKind Index kind for collections.
type IndexDefinitionKind string

// IndexDefinitionType Type of index, defined with a custom index class name or classpath. Secondary index is default, no type entered
type IndexDefinitionType string

// IndexOptions defines model for IndexOptions.
type IndexOptions struct {
	Key   *string `json:"key,omitempty"`
	Value *string `json:"value,omitempty"`
}

// IndexResponse The data returned by the index fetch.
type IndexResponse = []struct {
	IndexName    *string         `json:"index_name,omitempty"`
	KeyspaceName *string         `json:"keyspace_name,omitempty"`
	Kind         *string         `json:"kind,omitempty"`
	Options      *[]IndexOptions `json:"options,omitempty"`
	TableName    *string         `json:"table_name,omitempty"`
}

// Keyspace defines model for Keyspace.
type Keyspace struct {
	// Datacenters The datacenters within a keyspace. Only applies for those keyspaces created with NetworkTopologyStrategy.
	Datacenters *[]Datacenter `json:"datacenters,omitempty"`

	// Name The name of the keyspace.
	Name string `json:"name"`
}

// PrimaryKey Defines a column list for the primary key. Can be either a single column, compound primary key, or composite partition key. Provide multiple columns for the partition key to define a composite partition key.
type PrimaryKey struct {
	// ClusteringKey Name of the column or columns that constitute the clustering key.
	ClusteringKey *[]string `json:"clusteringKey,omitempty"`

	// PartitionKey Name of the column or columns that constitute the partition key.
	PartitionKey []string `json:"partitionKey"`
}

// RenameTypeField defines model for RenameTypeField.
type RenameTypeField struct {
	// From Type's old field name
	From *string `json:"from,omitempty"`

	// To Type's new field name
	To *string `json:"to,omitempty"`
}

// RowsResponse defines model for RowsResponse.
type RowsResponse struct {
	Data *map[string]string `json:"data,omitempty"`
}

// Sort defines model for Sort.
type Sort map[string]string

// Table defines model for Table.
type Table struct {
	// ColumnDefinitions An array of column names with data type.
	ColumnDefinitions []ColumnDefinition `json:"columnDefinitions"`

	// Keyspace The name of the keyspace.
	Keyspace *string `json:"keyspace,omitempty"`

	// Name The name of the table.
	Name string `json:"name"`

	// PrimaryKey Defines a column list for the primary key. Can be either a single column, compound primary key, or composite partition key. Provide multiple columns for the partition key to define a composite partition key.
	PrimaryKey   PrimaryKey    `json:"primaryKey"`
	TableOptions *TableOptions `json:"tableOptions,omitempty"`
}

// TableAdd defines model for TableAdd.
type TableAdd struct {
	// ColumnDefinitions Definition of columns that belong to the table to be added.
	ColumnDefinitions []ColumnDefinition `json:"columnDefinitions"`

	// IfNotExists Determines whether to create a new table if a table with the same name exists. Attempting to create an existing table returns an error unless this option is true.
	IfNotExists *bool `json:"ifNotExists,omitempty"`

	// Name Name of the table.
	Name string `json:"name"`

	// PrimaryKey Defines a column list for the primary key. Can be either a single column, compound primary key, or composite partition key. Provide multiple columns for the partition key to define a composite partition key.
	PrimaryKey   PrimaryKey    `json:"primaryKey"`
	TableOptions *TableOptions `json:"tableOptions,omitempty"`
}

// TableArray defines model for TableArray.
type TableArray struct {
	Data *[]Table `json:"data,omitempty"`
}

// TableOptions defines model for TableOptions.
type TableOptions struct {
	ClusteringExpression *[]ClusteringExpression `json:"clusteringExpression,omitempty"`

	// DefaultTimeToLive Defines the Time To Live (TTL), which determines the time period (in seconds) to expire data. If the value is >0, TTL is enabled for the entire table and an expiration timestamp is added to each column. The maximum value is 630720000 (20 years). A new TTL timestamp is calculated each time the data is updated and the row is removed after the data expires.
	DefaultTimeToLive *int `json:"defaultTimeToLive,omitempty"`
}

// TypeAdd defines model for TypeAdd.
type TypeAdd struct {
	Fields []TypeField `json:"fields"`

	// IfNotExists Determines whether to create a new UDT if an UDT with the same name exists. Attempting to create an existing UDT returns an error unless this option is true.
	IfNotExists *bool  `json:"ifNotExists,omitempty"`
	Name        string `json:"name"`
}

// TypeField defines model for TypeField.
type TypeField struct {
	// Name Name for the type, which must be unique.
	Name string `json:"name"`

	// TypeDefinition A valid type of data (e.g, text, int, etc) allowed in the type.
	TypeDefinition string `json:"typeDefinition"`
}

// TypeResponse defines model for TypeResponse.
type TypeResponse struct {
	// Fields Definition of columns within the user defined type.
	Fields *[]TypeField `json:"fields,omitempty"`

	// Keyspace Name of the keyspace the user defined type belongs.
	Keyspace *string `json:"keyspace,omitempty"`
	Name     *string `json:"name,omitempty"`
}

// TypeUpdate defines model for TypeUpdate.
type TypeUpdate struct {
	// AddFields Type fields to add
	AddFields *[]TypeField `json:"addFields,omitempty"`
	Name      string       `json:"name"`

	// RenameFields User Defined Type fields to rename
	RenameFields *[]RenameTypeField `json:"renameFields,omitempty"`
}

// XCassandraToken defines model for X-Cassandra-Token.
type XCassandraToken = string

// ColumnId defines model for column-id.
type ColumnId = string

// Fields defines model for fields.
type Fields = string

// IndexId defines model for index-id.
type IndexId = string

// KeyspaceId defines model for keyspace-id.
type KeyspaceId = string

// PageSize defines model for page-size.
type PageSize = int32

// PageState defines model for page-state.
type PageState = string

// PrimaryKeyValue defines model for primary-key-value.
type PrimaryKeyValue = string

// Raw defines model for raw.
type Raw = bool

// SortKeys defines model for sort-keys.
type SortKeys = Sort

// TableId defines model for table-id.
type TableId = string

// TypeId defines model for type-id.
type TypeId = string

// Where defines model for where.
type Where = map[string]interface{}

// SearchTableParams defines parameters for SearchTable.
type SearchTableParams struct {
	// Where URL escaped JSON query using the following keys:
	//
	// | Key | Operation |
	// |---|---|
	// | $lt | Less Than |
	// | $lte | Less Than Or Equal To |
	// | $gt | Greater Than |
	// | $gte | Greater Than Or Equal To |
	// | $ne | Not Equal To |
	// | $in | Contained In |
	// | $exists | A value is set for the key |
	Where *Where `form:"where,omitempty" json:"where,omitempty"`

	// Fields URL escaped, comma delimited list of keys to include. Values listed restrict the fields returned
	// in the response object.
	Fields *Fields `form:"fields,omitempty" json:"fields,omitempty"`

	// PageSize restrict the number of returned items
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// PageState move the cursor to a particular result
	PageState *PageState `form:"page-state,omitempty" json:"page-state,omitempty"`

	// SortKeys keys to sort by
	SortKeys *SortKeys `form:"sort-keys,omitempty" json:"sort-keys,omitempty"`

	// Raw Unwrap results.
	Raw *Raw `form:"raw,omitempty" json:"raw,omitempty"`

	// XCassandraToken The token returned from the authorization endpoint. Use this token in each request.
	XCassandraToken XCassandraToken `json:"X-Cassandra-Token"`
}

// AddRowsJSONBody defines parameters for AddRows.
type AddRowsJSONBody map[string]string

// AddRowsParams defines parameters for AddRows.
type AddRowsParams struct {
	// XCassandraToken The token returned from the authorization endpoint. Use this token in each request.
	XCassandraToken XCassandraToken `json:"X-Cassandra-Token"`
}

// DeleteRowsParams defines parameters for DeleteRows.
type DeleteRowsParams struct {
	// XCassandraToken The token returned from the authorization endpoint. Use this token in each request.
	XCassandraToken XCassandraToken `json:"X-Cassandra-Token"`
}

// GetRowsParams defines parameters for GetRows.
type GetRowsParams struct {
	// Fields URL escaped, comma delimited list of keys to include. Values listed restrict the fields returned
	// in the response object.
	Fields *Fields `form:"fields,omitempty" json:"fields,omitempty"`

	// PageSize restrict the number of returned items
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// PageState move the cursor to a particular result
	PageState *PageState `form:"page-state,omitempty" json:"page-state,omitempty"`

	// SortKeys keys to sort by
	SortKeys *SortKeys `form:"sort-keys,omitempty" json:"sort-keys,omitempty"`

	// Raw Unwrap results.
	Raw *Raw `form:"raw,omitempty" json:"raw,omitempty"`

	// XCassandraToken The token returned from the authorization endpoint. Use this token in each request.
	XCassandraToken XCassandraToken `json:"X-Cassandra-Token"`
}

// UpdateRowsJSONBody defines parameters for UpdateRows.
type UpdateRowsJSONBody map[string]string

// UpdateRowsParams defines parameters for UpdateRows.
type UpdateRowsParams struct {
	// Raw Unwrap results.
	Raw *Raw `form:"raw,omitempty" json:"raw,omitempty"`

	// XCassandraToken The token returned from the authorization endpoint. Use this token in each request.
	XCassandraToken XCassandraToken `json:"X-Cassandra-Token"`
}

// ReplaceRowsJSONBody defines parameters for ReplaceRows.
type ReplaceRowsJSONBody map[string]string

// ReplaceRowsParams defines parameters for ReplaceRows.
type ReplaceRowsParams struct {
	// Raw Unwrap results.
	Raw *Raw `form:"raw,omitempty" json:"raw,omitempty"`

	// XCassandraToken The token returned from the authorization endpoint. Use this token in each request.
	XCassandraToken XCassandraToken `json:"X-Cassandra-Token"`
}

// GetAllKeyspacesParams defines parameters for GetAllKeyspaces.
type GetAllKeyspacesParams struct {
	// Raw Unwrap results.
	Raw *Raw `form:"raw,omitempty" json:"raw,omitempty"`

	// XCassandraToken The token returned from the authorization endpoint. Use this token in each request.
	XCassandraToken XCassandraToken `json:"X-Cassandra-Token"`
}

// CreateKeyspaceParams defines parameters for CreateKeyspace.
type CreateKeyspaceParams struct {
	// XCassandraToken The token returned from the authorization endpoint. Use this token in each request.
	XCassandraToken XCassandraToken `json:"X-Cassandra-Token"`
}

// DeleteKeyspaceParams defines parameters for DeleteKeyspace.
type DeleteKeyspaceParams struct {
	// XCassandraToken The token returned from the authorization endpoint. Use this token in each request.
	XCassandraToken XCassandraToken `json:"X-Cassandra-Token"`
}

// GetKeyspaceParams defines parameters for GetKeyspace.
type GetKeyspaceParams struct {
	// Raw Unwrap results.
	Raw *Raw `form:"raw,omitempty" json:"raw,omitempty"`

	// XCassandraToken The token returned from the authorization endpoint. Use this token in each request.
	XCassandraToken XCassandraToken `json:"X-Cassandra-Token"`
}

// GetTablesParams defines parameters for GetTables.
type GetTablesParams struct {
	// Raw Unwrap results.
	Raw *Raw `form:"raw,omitempty" json:"raw,omitempty"`

	// XCassandraToken The token returned from the authorization endpoint. Use this token in each request.
	XCassandraToken XCassandraToken `json:"X-Cassandra-Token"`
}

// CreateTableParams defines parameters for CreateTable.
type CreateTableParams struct {
	// XCassandraToken The token returned from the authorization endpoint. Use this token in each request.
	XCassandraToken XCassandraToken `json:"X-Cassandra-Token"`
}

// DeleteTableParams defines parameters for DeleteTable.
type DeleteTableParams struct {
	// XCassandraToken The token returned from the authorization endpoint. Use this token in each request.
	XCassandraToken XCassandraToken `json:"X-Cassandra-Token"`
}

// GetTableParams defines parameters for GetTable.
type GetTableParams struct {
	// Raw Unwrap results.
	Raw *Raw `form:"raw,omitempty" json:"raw,omitempty"`

	// XCassandraToken The token returned from the authorization endpoint. Use this token in each request.
	XCassandraToken XCassandraToken `json:"X-Cassandra-Token"`
}

// ReplaceTableParams defines parameters for ReplaceTable.
type ReplaceTableParams struct {
	// XCassandraToken The token returned from the authorization endpoint. Use this token in each request.
	XCassandraToken XCassandraToken `json:"X-Cassandra-Token"`
}

// GetColumnsParams defines parameters for GetColumns.
type GetColumnsParams struct {
	// Raw Unwrap results.
	Raw *Raw `form:"raw,omitempty" json:"raw,omitempty"`

	// XCassandraToken The token returned from the authorization endpoint. Use this token in each request.
	XCassandraToken XCassandraToken `json:"X-Cassandra-Token"`
}

// CreateColumnParams defines parameters for CreateColumn.
type CreateColumnParams struct {
	// XCassandraToken The token returned from the authorization endpoint. Use this token in each request.
	XCassandraToken XCassandraToken `json:"X-Cassandra-Token"`
}

// DeleteColumnParams defines parameters for DeleteColumn.
type DeleteColumnParams struct {
	// XCassandraToken The token returned from the authorization endpoint. Use this token in each request.
	XCassandraToken XCassandraToken `json:"X-Cassandra-Token"`
}

// GetColumnParams defines parameters for GetColumn.
type GetColumnParams struct {
	// Raw Unwrap results.
	Raw *Raw `form:"raw,omitempty" json:"raw,omitempty"`

	// XCassandraToken The token returned from the authorization endpoint. Use this token in each request.
	XCassandraToken XCassandraToken `json:"X-Cassandra-Token"`
}

// ReplaceColumnParams defines parameters for ReplaceColumn.
type ReplaceColumnParams struct {
	// XCassandraToken The token returned from the authorization endpoint. Use this token in each request.
	XCassandraToken XCassandraToken `json:"X-Cassandra-Token"`
}

// GetIndexesParams defines parameters for GetIndexes.
type GetIndexesParams struct {
	// Raw Unwrap results.
	Raw *Raw `form:"raw,omitempty" json:"raw,omitempty"`

	// XCassandraToken The token returned from the authorization endpoint. Use this token in each request.
	XCassandraToken XCassandraToken `json:"X-Cassandra-Token"`
}

// CreateIndexParams defines parameters for CreateIndex.
type CreateIndexParams struct {
	// XCassandraToken The token returned from the authorization endpoint. Use this token in each request.
	XCassandraToken XCassandraToken `json:"X-Cassandra-Token"`
}

// DeleteIndexParams defines parameters for DeleteIndex.
type DeleteIndexParams struct {
	// XCassandraToken The token returned from the authorization endpoint. Use this token in each request.
	XCassandraToken XCassandraToken `json:"X-Cassandra-Token"`
}

// GetTypesParams defines parameters for GetTypes.
type GetTypesParams struct {
	// Raw Unwrap results.
	Raw *Raw `form:"raw,omitempty" json:"raw,omitempty"`

	// XCassandraToken The token returned from the authorization endpoint. Use this token in each request.
	XCassandraToken XCassandraToken `json:"X-Cassandra-Token"`
}

// CreateTypeParams defines parameters for CreateType.
type CreateTypeParams struct {
	// XCassandraToken The token returned from the authorization endpoint. Use this token in each request.
	XCassandraToken XCassandraToken `json:"X-Cassandra-Token"`
}

// UpdateTypeParams defines parameters for UpdateType.
type UpdateTypeParams struct {
	// XCassandraToken The token returned from the authorization endpoint. Use this token in each request.
	XCassandraToken XCassandraToken `json:"X-Cassandra-Token"`
}

// DeleteTypeParams defines parameters for DeleteType.
type DeleteTypeParams struct {
	// XCassandraToken The token returned from the authorization endpoint. Use this token in each request.
	XCassandraToken XCassandraToken `json:"X-Cassandra-Token"`
}

// GetTypeParams defines parameters for GetType.
type GetTypeParams struct {
	// Raw Unwrap results.
	Raw *Raw `form:"raw,omitempty" json:"raw,omitempty"`

	// XCassandraToken The token returned from the authorization endpoint. Use this token in each request.
	XCassandraToken XCassandraToken `json:"X-Cassandra-Token"`
}

// CreateTokenJSONRequestBody defines body for CreateToken for application/json ContentType.
type CreateTokenJSONRequestBody = Credentials

// AddRowsJSONRequestBody defines body for AddRows for application/json ContentType.
type AddRowsJSONRequestBody AddRowsJSONBody

// UpdateRowsJSONRequestBody defines body for UpdateRows for application/json ContentType.
type UpdateRowsJSONRequestBody UpdateRowsJSONBody

// ReplaceRowsJSONRequestBody defines body for ReplaceRows for application/json ContentType.
type ReplaceRowsJSONRequestBody ReplaceRowsJSONBody

// CreateKeyspaceJSONRequestBody defines body for CreateKeyspace for application/json ContentType.
type CreateKeyspaceJSONRequestBody = Keyspace

// CreateTableJSONRequestBody defines body for CreateTable for application/json ContentType.
type CreateTableJSONRequestBody = TableAdd

// ReplaceTableJSONRequestBody defines body for ReplaceTable for application/json ContentType.
type ReplaceTableJSONRequestBody = TableAdd

// CreateColumnJSONRequestBody defines body for CreateColumn for application/json ContentType.
type CreateColumnJSONRequestBody = ColumnDefinition

// ReplaceColumnJSONRequestBody defines body for ReplaceColumn for application/json ContentType.
type ReplaceColumnJSONRequestBody = ColumnDefinition

// CreateIndexJSONRequestBody defines body for CreateIndex for application/json ContentType.
type CreateIndexJSONRequestBody = IndexDefinition

// CreateTypeJSONRequestBody defines body for CreateType for application/json ContentType.
type CreateTypeJSONRequestBody = TypeAdd

// UpdateTypeJSONRequestBody defines body for UpdateType for application/json ContentType.
type UpdateTypeJSONRequestBody = TypeUpdate

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// CreateTokenWithBody request with any body
	CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateToken(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchTable request
	SearchTable(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *SearchTableParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddRowsWithBody request with any body
	AddRowsWithBody(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *AddRowsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddRows(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *AddRowsParams, body AddRowsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRows request
	DeleteRows(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *DeleteRowsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRows request
	GetRows(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *GetRowsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRowsWithBody request with any body
	UpdateRowsWithBody(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *UpdateRowsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRows(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *UpdateRowsParams, body UpdateRowsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceRowsWithBody request with any body
	ReplaceRowsWithBody(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *ReplaceRowsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceRows(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *ReplaceRowsParams, body ReplaceRowsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllKeyspaces request
	GetAllKeyspaces(ctx context.Context, params *GetAllKeyspacesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKeyspaceWithBody request with any body
	CreateKeyspaceWithBody(ctx context.Context, params *CreateKeyspaceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateKeyspace(ctx context.Context, params *CreateKeyspaceParams, body CreateKeyspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteKeyspace request
	DeleteKeyspace(ctx context.Context, keyspaceId KeyspaceId, params *DeleteKeyspaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeyspace request
	GetKeyspace(ctx context.Context, keyspaceId KeyspaceId, params *GetKeyspaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTables request
	GetTables(ctx context.Context, keyspaceId KeyspaceId, params *GetTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTableWithBody request with any body
	CreateTableWithBody(ctx context.Context, keyspaceId KeyspaceId, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTable(ctx context.Context, keyspaceId KeyspaceId, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTable request
	DeleteTable(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *DeleteTableParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTable request
	GetTable(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *GetTableParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceTableWithBody request with any body
	ReplaceTableWithBody(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *ReplaceTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceTable(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *ReplaceTableParams, body ReplaceTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetColumns request
	GetColumns(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *GetColumnsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateColumnWithBody request with any body
	CreateColumnWithBody(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *CreateColumnParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateColumn(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *CreateColumnParams, body CreateColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteColumn request
	DeleteColumn(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, columnId ColumnId, params *DeleteColumnParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetColumn request
	GetColumn(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, columnId ColumnId, params *GetColumnParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceColumnWithBody request with any body
	ReplaceColumnWithBody(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, columnId ColumnId, params *ReplaceColumnParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceColumn(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, columnId ColumnId, params *ReplaceColumnParams, body ReplaceColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIndexes request
	GetIndexes(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *GetIndexesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIndexWithBody request with any body
	CreateIndexWithBody(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *CreateIndexParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIndex(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *CreateIndexParams, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIndex request
	DeleteIndex(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, indexId IndexId, params *DeleteIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTypes request
	GetTypes(ctx context.Context, keyspaceId KeyspaceId, params *GetTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTypeWithBody request with any body
	CreateTypeWithBody(ctx context.Context, keyspaceId KeyspaceId, params *CreateTypeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateType(ctx context.Context, keyspaceId KeyspaceId, params *CreateTypeParams, body CreateTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTypeWithBody request with any body
	UpdateTypeWithBody(ctx context.Context, keyspaceId KeyspaceId, params *UpdateTypeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateType(ctx context.Context, keyspaceId KeyspaceId, params *UpdateTypeParams, body UpdateTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteType request
	DeleteType(ctx context.Context, keyspaceId KeyspaceId, typeId TypeId, params *DeleteTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetType request
	GetType(ctx context.Context, keyspaceId KeyspaceId, typeId TypeId, params *GetTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateToken(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchTable(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *SearchTableParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchTableRequest(c.Server, keyspaceId, tableId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRowsWithBody(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *AddRowsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRowsRequestWithBody(c.Server, keyspaceId, tableId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRows(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *AddRowsParams, body AddRowsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRowsRequest(c.Server, keyspaceId, tableId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRows(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *DeleteRowsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRowsRequest(c.Server, keyspaceId, tableId, primaryKeyValue, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRows(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *GetRowsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRowsRequest(c.Server, keyspaceId, tableId, primaryKeyValue, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRowsWithBody(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *UpdateRowsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRowsRequestWithBody(c.Server, keyspaceId, tableId, primaryKeyValue, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRows(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *UpdateRowsParams, body UpdateRowsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRowsRequest(c.Server, keyspaceId, tableId, primaryKeyValue, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceRowsWithBody(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *ReplaceRowsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceRowsRequestWithBody(c.Server, keyspaceId, tableId, primaryKeyValue, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceRows(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *ReplaceRowsParams, body ReplaceRowsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceRowsRequest(c.Server, keyspaceId, tableId, primaryKeyValue, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllKeyspaces(ctx context.Context, params *GetAllKeyspacesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllKeyspacesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeyspaceWithBody(ctx context.Context, params *CreateKeyspaceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeyspaceRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeyspace(ctx context.Context, params *CreateKeyspaceParams, body CreateKeyspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeyspaceRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteKeyspace(ctx context.Context, keyspaceId KeyspaceId, params *DeleteKeyspaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteKeyspaceRequest(c.Server, keyspaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeyspace(ctx context.Context, keyspaceId KeyspaceId, params *GetKeyspaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeyspaceRequest(c.Server, keyspaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTables(ctx context.Context, keyspaceId KeyspaceId, params *GetTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTablesRequest(c.Server, keyspaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTableWithBody(ctx context.Context, keyspaceId KeyspaceId, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTableRequestWithBody(c.Server, keyspaceId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTable(ctx context.Context, keyspaceId KeyspaceId, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTableRequest(c.Server, keyspaceId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTable(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *DeleteTableParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTableRequest(c.Server, keyspaceId, tableId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTable(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *GetTableParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTableRequest(c.Server, keyspaceId, tableId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTableWithBody(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *ReplaceTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTableRequestWithBody(c.Server, keyspaceId, tableId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTable(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *ReplaceTableParams, body ReplaceTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTableRequest(c.Server, keyspaceId, tableId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetColumns(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *GetColumnsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetColumnsRequest(c.Server, keyspaceId, tableId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateColumnWithBody(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *CreateColumnParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateColumnRequestWithBody(c.Server, keyspaceId, tableId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateColumn(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *CreateColumnParams, body CreateColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateColumnRequest(c.Server, keyspaceId, tableId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteColumn(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, columnId ColumnId, params *DeleteColumnParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteColumnRequest(c.Server, keyspaceId, tableId, columnId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetColumn(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, columnId ColumnId, params *GetColumnParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetColumnRequest(c.Server, keyspaceId, tableId, columnId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceColumnWithBody(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, columnId ColumnId, params *ReplaceColumnParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceColumnRequestWithBody(c.Server, keyspaceId, tableId, columnId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceColumn(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, columnId ColumnId, params *ReplaceColumnParams, body ReplaceColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceColumnRequest(c.Server, keyspaceId, tableId, columnId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIndexes(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *GetIndexesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIndexesRequest(c.Server, keyspaceId, tableId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIndexWithBody(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *CreateIndexParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIndexRequestWithBody(c.Server, keyspaceId, tableId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIndex(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *CreateIndexParams, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIndexRequest(c.Server, keyspaceId, tableId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIndex(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, indexId IndexId, params *DeleteIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIndexRequest(c.Server, keyspaceId, tableId, indexId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTypes(ctx context.Context, keyspaceId KeyspaceId, params *GetTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTypesRequest(c.Server, keyspaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTypeWithBody(ctx context.Context, keyspaceId KeyspaceId, params *CreateTypeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTypeRequestWithBody(c.Server, keyspaceId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateType(ctx context.Context, keyspaceId KeyspaceId, params *CreateTypeParams, body CreateTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTypeRequest(c.Server, keyspaceId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTypeWithBody(ctx context.Context, keyspaceId KeyspaceId, params *UpdateTypeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTypeRequestWithBody(c.Server, keyspaceId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateType(ctx context.Context, keyspaceId KeyspaceId, params *UpdateTypeParams, body UpdateTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTypeRequest(c.Server, keyspaceId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteType(ctx context.Context, keyspaceId KeyspaceId, typeId TypeId, params *DeleteTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTypeRequest(c.Server, keyspaceId, typeId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetType(ctx context.Context, keyspaceId KeyspaceId, typeId TypeId, params *GetTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTypeRequest(c.Server, keyspaceId, typeId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCreateTokenRequest calls the generic CreateToken builder with application/json body
func NewCreateTokenRequest(server string, body CreateTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTokenRequestWithBody generates requests for CreateToken with any type of body
func NewCreateTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchTableRequest generates requests for SearchTable
func NewSearchTableRequest(server string, keyspaceId KeyspaceId, tableId TableId, params *SearchTableParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyspace-id", runtime.ParamLocationPath, keyspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "table-id", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/keyspaces/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Where != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "where", runtime.ParamLocationQuery, *params.Where); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageState != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-state", runtime.ParamLocationQuery, *params.PageState); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort-keys", runtime.ParamLocationQuery, *params.SortKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Raw != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "raw", runtime.ParamLocationQuery, *params.Raw); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Cassandra-Token", runtime.ParamLocationHeader, params.XCassandraToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Cassandra-Token", headerParam0)

	}

	return req, nil
}

// NewAddRowsRequest calls the generic AddRows builder with application/json body
func NewAddRowsRequest(server string, keyspaceId KeyspaceId, tableId TableId, params *AddRowsParams, body AddRowsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddRowsRequestWithBody(server, keyspaceId, tableId, params, "application/json", bodyReader)
}

// NewAddRowsRequestWithBody generates requests for AddRows with any type of body
func NewAddRowsRequestWithBody(server string, keyspaceId KeyspaceId, tableId TableId, params *AddRowsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyspace-id", runtime.ParamLocationPath, keyspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "table-id", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/keyspaces/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Cassandra-Token", runtime.ParamLocationHeader, params.XCassandraToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Cassandra-Token", headerParam0)

	}

	return req, nil
}

// NewDeleteRowsRequest generates requests for DeleteRows
func NewDeleteRowsRequest(server string, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *DeleteRowsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyspace-id", runtime.ParamLocationPath, keyspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "table-id", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "primary-key-value", runtime.ParamLocationPath, primaryKeyValue)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/keyspaces/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Cassandra-Token", runtime.ParamLocationHeader, params.XCassandraToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Cassandra-Token", headerParam0)

	}

	return req, nil
}

// NewGetRowsRequest generates requests for GetRows
func NewGetRowsRequest(server string, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *GetRowsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyspace-id", runtime.ParamLocationPath, keyspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "table-id", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "primary-key-value", runtime.ParamLocationPath, primaryKeyValue)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/keyspaces/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageState != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-state", runtime.ParamLocationQuery, *params.PageState); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort-keys", runtime.ParamLocationQuery, *params.SortKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Raw != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "raw", runtime.ParamLocationQuery, *params.Raw); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Cassandra-Token", runtime.ParamLocationHeader, params.XCassandraToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Cassandra-Token", headerParam0)

	}

	return req, nil
}

// NewUpdateRowsRequest calls the generic UpdateRows builder with application/json body
func NewUpdateRowsRequest(server string, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *UpdateRowsParams, body UpdateRowsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRowsRequestWithBody(server, keyspaceId, tableId, primaryKeyValue, params, "application/json", bodyReader)
}

// NewUpdateRowsRequestWithBody generates requests for UpdateRows with any type of body
func NewUpdateRowsRequestWithBody(server string, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *UpdateRowsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyspace-id", runtime.ParamLocationPath, keyspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "table-id", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "primary-key-value", runtime.ParamLocationPath, primaryKeyValue)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/keyspaces/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Raw != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "raw", runtime.ParamLocationQuery, *params.Raw); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Cassandra-Token", runtime.ParamLocationHeader, params.XCassandraToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Cassandra-Token", headerParam0)

	}

	return req, nil
}

// NewReplaceRowsRequest calls the generic ReplaceRows builder with application/json body
func NewReplaceRowsRequest(server string, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *ReplaceRowsParams, body ReplaceRowsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceRowsRequestWithBody(server, keyspaceId, tableId, primaryKeyValue, params, "application/json", bodyReader)
}

// NewReplaceRowsRequestWithBody generates requests for ReplaceRows with any type of body
func NewReplaceRowsRequestWithBody(server string, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *ReplaceRowsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyspace-id", runtime.ParamLocationPath, keyspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "table-id", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "primary-key-value", runtime.ParamLocationPath, primaryKeyValue)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/keyspaces/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Raw != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "raw", runtime.ParamLocationQuery, *params.Raw); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Cassandra-Token", runtime.ParamLocationHeader, params.XCassandraToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Cassandra-Token", headerParam0)

	}

	return req, nil
}

// NewGetAllKeyspacesRequest generates requests for GetAllKeyspaces
func NewGetAllKeyspacesRequest(server string, params *GetAllKeyspacesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/schemas/keyspaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Raw != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "raw", runtime.ParamLocationQuery, *params.Raw); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Cassandra-Token", runtime.ParamLocationHeader, params.XCassandraToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Cassandra-Token", headerParam0)

	}

	return req, nil
}

// NewCreateKeyspaceRequest calls the generic CreateKeyspace builder with application/json body
func NewCreateKeyspaceRequest(server string, params *CreateKeyspaceParams, body CreateKeyspaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateKeyspaceRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateKeyspaceRequestWithBody generates requests for CreateKeyspace with any type of body
func NewCreateKeyspaceRequestWithBody(server string, params *CreateKeyspaceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/schemas/keyspaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Cassandra-Token", runtime.ParamLocationHeader, params.XCassandraToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Cassandra-Token", headerParam0)

	}

	return req, nil
}

// NewDeleteKeyspaceRequest generates requests for DeleteKeyspace
func NewDeleteKeyspaceRequest(server string, keyspaceId KeyspaceId, params *DeleteKeyspaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyspace-id", runtime.ParamLocationPath, keyspaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/schemas/keyspaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Cassandra-Token", runtime.ParamLocationHeader, params.XCassandraToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Cassandra-Token", headerParam0)

	}

	return req, nil
}

// NewGetKeyspaceRequest generates requests for GetKeyspace
func NewGetKeyspaceRequest(server string, keyspaceId KeyspaceId, params *GetKeyspaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyspace-id", runtime.ParamLocationPath, keyspaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/schemas/keyspaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Raw != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "raw", runtime.ParamLocationQuery, *params.Raw); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Cassandra-Token", runtime.ParamLocationHeader, params.XCassandraToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Cassandra-Token", headerParam0)

	}

	return req, nil
}

// NewGetTablesRequest generates requests for GetTables
func NewGetTablesRequest(server string, keyspaceId KeyspaceId, params *GetTablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyspace-id", runtime.ParamLocationPath, keyspaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/schemas/keyspaces/%s/tables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Raw != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "raw", runtime.ParamLocationQuery, *params.Raw); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Cassandra-Token", runtime.ParamLocationHeader, params.XCassandraToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Cassandra-Token", headerParam0)

	}

	return req, nil
}

// NewCreateTableRequest calls the generic CreateTable builder with application/json body
func NewCreateTableRequest(server string, keyspaceId KeyspaceId, params *CreateTableParams, body CreateTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTableRequestWithBody(server, keyspaceId, params, "application/json", bodyReader)
}

// NewCreateTableRequestWithBody generates requests for CreateTable with any type of body
func NewCreateTableRequestWithBody(server string, keyspaceId KeyspaceId, params *CreateTableParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyspace-id", runtime.ParamLocationPath, keyspaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/schemas/keyspaces/%s/tables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Cassandra-Token", runtime.ParamLocationHeader, params.XCassandraToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Cassandra-Token", headerParam0)

	}

	return req, nil
}

// NewDeleteTableRequest generates requests for DeleteTable
func NewDeleteTableRequest(server string, keyspaceId KeyspaceId, tableId TableId, params *DeleteTableParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyspace-id", runtime.ParamLocationPath, keyspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "table-id", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/schemas/keyspaces/%s/tables/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Cassandra-Token", runtime.ParamLocationHeader, params.XCassandraToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Cassandra-Token", headerParam0)

	}

	return req, nil
}

// NewGetTableRequest generates requests for GetTable
func NewGetTableRequest(server string, keyspaceId KeyspaceId, tableId TableId, params *GetTableParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyspace-id", runtime.ParamLocationPath, keyspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "table-id", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/schemas/keyspaces/%s/tables/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Raw != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "raw", runtime.ParamLocationQuery, *params.Raw); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Cassandra-Token", runtime.ParamLocationHeader, params.XCassandraToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Cassandra-Token", headerParam0)

	}

	return req, nil
}

// NewReplaceTableRequest calls the generic ReplaceTable builder with application/json body
func NewReplaceTableRequest(server string, keyspaceId KeyspaceId, tableId TableId, params *ReplaceTableParams, body ReplaceTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceTableRequestWithBody(server, keyspaceId, tableId, params, "application/json", bodyReader)
}

// NewReplaceTableRequestWithBody generates requests for ReplaceTable with any type of body
func NewReplaceTableRequestWithBody(server string, keyspaceId KeyspaceId, tableId TableId, params *ReplaceTableParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyspace-id", runtime.ParamLocationPath, keyspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "table-id", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/schemas/keyspaces/%s/tables/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Cassandra-Token", runtime.ParamLocationHeader, params.XCassandraToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Cassandra-Token", headerParam0)

	}

	return req, nil
}

// NewGetColumnsRequest generates requests for GetColumns
func NewGetColumnsRequest(server string, keyspaceId KeyspaceId, tableId TableId, params *GetColumnsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyspace-id", runtime.ParamLocationPath, keyspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "table-id", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/schemas/keyspaces/%s/tables/%s/columns", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Raw != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "raw", runtime.ParamLocationQuery, *params.Raw); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Cassandra-Token", runtime.ParamLocationHeader, params.XCassandraToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Cassandra-Token", headerParam0)

	}

	return req, nil
}

// NewCreateColumnRequest calls the generic CreateColumn builder with application/json body
func NewCreateColumnRequest(server string, keyspaceId KeyspaceId, tableId TableId, params *CreateColumnParams, body CreateColumnJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateColumnRequestWithBody(server, keyspaceId, tableId, params, "application/json", bodyReader)
}

// NewCreateColumnRequestWithBody generates requests for CreateColumn with any type of body
func NewCreateColumnRequestWithBody(server string, keyspaceId KeyspaceId, tableId TableId, params *CreateColumnParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyspace-id", runtime.ParamLocationPath, keyspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "table-id", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/schemas/keyspaces/%s/tables/%s/columns", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Cassandra-Token", runtime.ParamLocationHeader, params.XCassandraToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Cassandra-Token", headerParam0)

	}

	return req, nil
}

// NewDeleteColumnRequest generates requests for DeleteColumn
func NewDeleteColumnRequest(server string, keyspaceId KeyspaceId, tableId TableId, columnId ColumnId, params *DeleteColumnParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyspace-id", runtime.ParamLocationPath, keyspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "table-id", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "column-id", runtime.ParamLocationPath, columnId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/schemas/keyspaces/%s/tables/%s/columns/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Cassandra-Token", runtime.ParamLocationHeader, params.XCassandraToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Cassandra-Token", headerParam0)

	}

	return req, nil
}

// NewGetColumnRequest generates requests for GetColumn
func NewGetColumnRequest(server string, keyspaceId KeyspaceId, tableId TableId, columnId ColumnId, params *GetColumnParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyspace-id", runtime.ParamLocationPath, keyspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "table-id", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "column-id", runtime.ParamLocationPath, columnId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/schemas/keyspaces/%s/tables/%s/columns/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Raw != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "raw", runtime.ParamLocationQuery, *params.Raw); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Cassandra-Token", runtime.ParamLocationHeader, params.XCassandraToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Cassandra-Token", headerParam0)

	}

	return req, nil
}

// NewReplaceColumnRequest calls the generic ReplaceColumn builder with application/json body
func NewReplaceColumnRequest(server string, keyspaceId KeyspaceId, tableId TableId, columnId ColumnId, params *ReplaceColumnParams, body ReplaceColumnJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceColumnRequestWithBody(server, keyspaceId, tableId, columnId, params, "application/json", bodyReader)
}

// NewReplaceColumnRequestWithBody generates requests for ReplaceColumn with any type of body
func NewReplaceColumnRequestWithBody(server string, keyspaceId KeyspaceId, tableId TableId, columnId ColumnId, params *ReplaceColumnParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyspace-id", runtime.ParamLocationPath, keyspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "table-id", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "column-id", runtime.ParamLocationPath, columnId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/schemas/keyspaces/%s/tables/%s/columns/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Cassandra-Token", runtime.ParamLocationHeader, params.XCassandraToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Cassandra-Token", headerParam0)

	}

	return req, nil
}

// NewGetIndexesRequest generates requests for GetIndexes
func NewGetIndexesRequest(server string, keyspaceId KeyspaceId, tableId TableId, params *GetIndexesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyspace-id", runtime.ParamLocationPath, keyspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "table-id", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/schemas/keyspaces/%s/tables/%s/indexes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Raw != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "raw", runtime.ParamLocationQuery, *params.Raw); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Cassandra-Token", runtime.ParamLocationHeader, params.XCassandraToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Cassandra-Token", headerParam0)

	}

	return req, nil
}

// NewCreateIndexRequest calls the generic CreateIndex builder with application/json body
func NewCreateIndexRequest(server string, keyspaceId KeyspaceId, tableId TableId, params *CreateIndexParams, body CreateIndexJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIndexRequestWithBody(server, keyspaceId, tableId, params, "application/json", bodyReader)
}

// NewCreateIndexRequestWithBody generates requests for CreateIndex with any type of body
func NewCreateIndexRequestWithBody(server string, keyspaceId KeyspaceId, tableId TableId, params *CreateIndexParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyspace-id", runtime.ParamLocationPath, keyspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "table-id", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/schemas/keyspaces/%s/tables/%s/indexes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Cassandra-Token", runtime.ParamLocationHeader, params.XCassandraToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Cassandra-Token", headerParam0)

	}

	return req, nil
}

// NewDeleteIndexRequest generates requests for DeleteIndex
func NewDeleteIndexRequest(server string, keyspaceId KeyspaceId, tableId TableId, indexId IndexId, params *DeleteIndexParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyspace-id", runtime.ParamLocationPath, keyspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "table-id", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "index-id", runtime.ParamLocationPath, indexId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/schemas/keyspaces/%s/tables/%s/indexes/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Cassandra-Token", runtime.ParamLocationHeader, params.XCassandraToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Cassandra-Token", headerParam0)

	}

	return req, nil
}

// NewGetTypesRequest generates requests for GetTypes
func NewGetTypesRequest(server string, keyspaceId KeyspaceId, params *GetTypesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyspace-id", runtime.ParamLocationPath, keyspaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/schemas/keyspaces/%s/types", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Raw != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "raw", runtime.ParamLocationQuery, *params.Raw); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Cassandra-Token", runtime.ParamLocationHeader, params.XCassandraToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Cassandra-Token", headerParam0)

	}

	return req, nil
}

// NewCreateTypeRequest calls the generic CreateType builder with application/json body
func NewCreateTypeRequest(server string, keyspaceId KeyspaceId, params *CreateTypeParams, body CreateTypeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTypeRequestWithBody(server, keyspaceId, params, "application/json", bodyReader)
}

// NewCreateTypeRequestWithBody generates requests for CreateType with any type of body
func NewCreateTypeRequestWithBody(server string, keyspaceId KeyspaceId, params *CreateTypeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyspace-id", runtime.ParamLocationPath, keyspaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/schemas/keyspaces/%s/types", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Cassandra-Token", runtime.ParamLocationHeader, params.XCassandraToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Cassandra-Token", headerParam0)

	}

	return req, nil
}

// NewUpdateTypeRequest calls the generic UpdateType builder with application/json body
func NewUpdateTypeRequest(server string, keyspaceId KeyspaceId, params *UpdateTypeParams, body UpdateTypeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTypeRequestWithBody(server, keyspaceId, params, "application/json", bodyReader)
}

// NewUpdateTypeRequestWithBody generates requests for UpdateType with any type of body
func NewUpdateTypeRequestWithBody(server string, keyspaceId KeyspaceId, params *UpdateTypeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyspace-id", runtime.ParamLocationPath, keyspaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/schemas/keyspaces/%s/types", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Cassandra-Token", runtime.ParamLocationHeader, params.XCassandraToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Cassandra-Token", headerParam0)

	}

	return req, nil
}

// NewDeleteTypeRequest generates requests for DeleteType
func NewDeleteTypeRequest(server string, keyspaceId KeyspaceId, typeId TypeId, params *DeleteTypeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyspace-id", runtime.ParamLocationPath, keyspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "type-id", runtime.ParamLocationPath, typeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/schemas/keyspaces/%s/types/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Cassandra-Token", runtime.ParamLocationHeader, params.XCassandraToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Cassandra-Token", headerParam0)

	}

	return req, nil
}

// NewGetTypeRequest generates requests for GetType
func NewGetTypeRequest(server string, keyspaceId KeyspaceId, typeId TypeId, params *GetTypeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyspace-id", runtime.ParamLocationPath, keyspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "type-id", runtime.ParamLocationPath, typeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/schemas/keyspaces/%s/types/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Raw != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "raw", runtime.ParamLocationQuery, *params.Raw); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Cassandra-Token", runtime.ParamLocationHeader, params.XCassandraToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Cassandra-Token", headerParam0)

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CreateTokenWithBodyWithResponse request with any body
	CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	CreateTokenWithResponse(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	// SearchTableWithResponse request
	SearchTableWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *SearchTableParams, reqEditors ...RequestEditorFn) (*SearchTableResponse, error)

	// AddRowsWithBodyWithResponse request with any body
	AddRowsWithBodyWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *AddRowsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRowsResponse, error)

	AddRowsWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *AddRowsParams, body AddRowsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRowsResponse, error)

	// DeleteRowsWithResponse request
	DeleteRowsWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *DeleteRowsParams, reqEditors ...RequestEditorFn) (*DeleteRowsResponse, error)

	// GetRowsWithResponse request
	GetRowsWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *GetRowsParams, reqEditors ...RequestEditorFn) (*GetRowsResponse, error)

	// UpdateRowsWithBodyWithResponse request with any body
	UpdateRowsWithBodyWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *UpdateRowsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRowsResponse, error)

	UpdateRowsWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *UpdateRowsParams, body UpdateRowsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRowsResponse, error)

	// ReplaceRowsWithBodyWithResponse request with any body
	ReplaceRowsWithBodyWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *ReplaceRowsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceRowsResponse, error)

	ReplaceRowsWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *ReplaceRowsParams, body ReplaceRowsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceRowsResponse, error)

	// GetAllKeyspacesWithResponse request
	GetAllKeyspacesWithResponse(ctx context.Context, params *GetAllKeyspacesParams, reqEditors ...RequestEditorFn) (*GetAllKeyspacesResponse, error)

	// CreateKeyspaceWithBodyWithResponse request with any body
	CreateKeyspaceWithBodyWithResponse(ctx context.Context, params *CreateKeyspaceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeyspaceResponse, error)

	CreateKeyspaceWithResponse(ctx context.Context, params *CreateKeyspaceParams, body CreateKeyspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeyspaceResponse, error)

	// DeleteKeyspaceWithResponse request
	DeleteKeyspaceWithResponse(ctx context.Context, keyspaceId KeyspaceId, params *DeleteKeyspaceParams, reqEditors ...RequestEditorFn) (*DeleteKeyspaceResponse, error)

	// GetKeyspaceWithResponse request
	GetKeyspaceWithResponse(ctx context.Context, keyspaceId KeyspaceId, params *GetKeyspaceParams, reqEditors ...RequestEditorFn) (*GetKeyspaceResponse, error)

	// GetTablesWithResponse request
	GetTablesWithResponse(ctx context.Context, keyspaceId KeyspaceId, params *GetTablesParams, reqEditors ...RequestEditorFn) (*GetTablesResponse, error)

	// CreateTableWithBodyWithResponse request with any body
	CreateTableWithBodyWithResponse(ctx context.Context, keyspaceId KeyspaceId, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTableResponse, error)

	CreateTableWithResponse(ctx context.Context, keyspaceId KeyspaceId, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTableResponse, error)

	// DeleteTableWithResponse request
	DeleteTableWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *DeleteTableParams, reqEditors ...RequestEditorFn) (*DeleteTableResponse, error)

	// GetTableWithResponse request
	GetTableWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *GetTableParams, reqEditors ...RequestEditorFn) (*GetTableResponse, error)

	// ReplaceTableWithBodyWithResponse request with any body
	ReplaceTableWithBodyWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *ReplaceTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTableResponse, error)

	ReplaceTableWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *ReplaceTableParams, body ReplaceTableJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTableResponse, error)

	// GetColumnsWithResponse request
	GetColumnsWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *GetColumnsParams, reqEditors ...RequestEditorFn) (*GetColumnsResponse, error)

	// CreateColumnWithBodyWithResponse request with any body
	CreateColumnWithBodyWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *CreateColumnParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateColumnResponse, error)

	CreateColumnWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *CreateColumnParams, body CreateColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateColumnResponse, error)

	// DeleteColumnWithResponse request
	DeleteColumnWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, columnId ColumnId, params *DeleteColumnParams, reqEditors ...RequestEditorFn) (*DeleteColumnResponse, error)

	// GetColumnWithResponse request
	GetColumnWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, columnId ColumnId, params *GetColumnParams, reqEditors ...RequestEditorFn) (*GetColumnResponse, error)

	// ReplaceColumnWithBodyWithResponse request with any body
	ReplaceColumnWithBodyWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, columnId ColumnId, params *ReplaceColumnParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceColumnResponse, error)

	ReplaceColumnWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, columnId ColumnId, params *ReplaceColumnParams, body ReplaceColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceColumnResponse, error)

	// GetIndexesWithResponse request
	GetIndexesWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *GetIndexesParams, reqEditors ...RequestEditorFn) (*GetIndexesResponse, error)

	// CreateIndexWithBodyWithResponse request with any body
	CreateIndexWithBodyWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *CreateIndexParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error)

	CreateIndexWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *CreateIndexParams, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error)

	// DeleteIndexWithResponse request
	DeleteIndexWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, indexId IndexId, params *DeleteIndexParams, reqEditors ...RequestEditorFn) (*DeleteIndexResponse, error)

	// GetTypesWithResponse request
	GetTypesWithResponse(ctx context.Context, keyspaceId KeyspaceId, params *GetTypesParams, reqEditors ...RequestEditorFn) (*GetTypesResponse, error)

	// CreateTypeWithBodyWithResponse request with any body
	CreateTypeWithBodyWithResponse(ctx context.Context, keyspaceId KeyspaceId, params *CreateTypeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTypeResponse, error)

	CreateTypeWithResponse(ctx context.Context, keyspaceId KeyspaceId, params *CreateTypeParams, body CreateTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTypeResponse, error)

	// UpdateTypeWithBodyWithResponse request with any body
	UpdateTypeWithBodyWithResponse(ctx context.Context, keyspaceId KeyspaceId, params *UpdateTypeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTypeResponse, error)

	UpdateTypeWithResponse(ctx context.Context, keyspaceId KeyspaceId, params *UpdateTypeParams, body UpdateTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTypeResponse, error)

	// DeleteTypeWithResponse request
	DeleteTypeWithResponse(ctx context.Context, keyspaceId KeyspaceId, typeId TypeId, params *DeleteTypeParams, reqEditors ...RequestEditorFn) (*DeleteTypeResponse, error)

	// GetTypeWithResponse request
	GetTypeWithResponse(ctx context.Context, keyspaceId KeyspaceId, typeId TypeId, params *GetTypeParams, reqEditors ...RequestEditorFn) (*GetTypeResponse, error)
}

type CreateTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AuthTokenResponse
}

// Status returns HTTPResponse.Status
func (r CreateTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Count *int                 `json:"count,omitempty"`
		Data  *[]map[string]string `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddRowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *map[string]string
}

// Status returns HTTPResponse.Status
func (r AddRowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddRowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteRowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Count *int                 `json:"count,omitempty"`
		Data  *[]map[string]string `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RowsResponse
}

// Status returns HTTPResponse.Status
func (r UpdateRowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceRowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RowsResponse
}

// Status returns HTTPResponse.Status
func (r ReplaceRowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceRowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllKeyspacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Keyspace
}

// Status returns HTTPResponse.Status
func (r GetAllKeyspacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllKeyspacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKeyspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Name *string `json:"name,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateKeyspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKeyspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteKeyspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteKeyspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteKeyspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeyspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Keyspace
}

// Status returns HTTPResponse.Status
func (r GetKeyspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeyspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TableArray
}

// Status returns HTTPResponse.Status
func (r GetTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Name *string `json:"name,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Table
}

// Status returns HTTPResponse.Status
func (r GetTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Name *string `json:"name,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ReplaceTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetColumnsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ColumnDefinition `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetColumnsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetColumnsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateColumnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Name *string `json:"name,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateColumnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateColumnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteColumnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteColumnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteColumnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetColumnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ColumnDefinition
}

// Status returns HTTPResponse.Status
func (r GetColumnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetColumnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceColumnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Name *string `json:"name,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ReplaceColumnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceColumnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIndexesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]IndexResponse
}

// Status returns HTTPResponse.Status
func (r GetIndexesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIndexesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *string
}

// Status returns HTTPResponse.Status
func (r CreateIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TypeResponse
}

// Status returns HTTPResponse.Status
func (r GetTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Name *string `json:"name,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TypeResponse
}

// Status returns HTTPResponse.Status
func (r GetTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CreateTokenWithBodyWithResponse request with arbitrary body returning *CreateTokenResponse
func (c *ClientWithResponses) CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateTokenWithResponse(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

// SearchTableWithResponse request returning *SearchTableResponse
func (c *ClientWithResponses) SearchTableWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *SearchTableParams, reqEditors ...RequestEditorFn) (*SearchTableResponse, error) {
	rsp, err := c.SearchTable(ctx, keyspaceId, tableId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchTableResponse(rsp)
}

// AddRowsWithBodyWithResponse request with arbitrary body returning *AddRowsResponse
func (c *ClientWithResponses) AddRowsWithBodyWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *AddRowsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRowsResponse, error) {
	rsp, err := c.AddRowsWithBody(ctx, keyspaceId, tableId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRowsResponse(rsp)
}

func (c *ClientWithResponses) AddRowsWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *AddRowsParams, body AddRowsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRowsResponse, error) {
	rsp, err := c.AddRows(ctx, keyspaceId, tableId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRowsResponse(rsp)
}

// DeleteRowsWithResponse request returning *DeleteRowsResponse
func (c *ClientWithResponses) DeleteRowsWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *DeleteRowsParams, reqEditors ...RequestEditorFn) (*DeleteRowsResponse, error) {
	rsp, err := c.DeleteRows(ctx, keyspaceId, tableId, primaryKeyValue, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRowsResponse(rsp)
}

// GetRowsWithResponse request returning *GetRowsResponse
func (c *ClientWithResponses) GetRowsWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *GetRowsParams, reqEditors ...RequestEditorFn) (*GetRowsResponse, error) {
	rsp, err := c.GetRows(ctx, keyspaceId, tableId, primaryKeyValue, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRowsResponse(rsp)
}

// UpdateRowsWithBodyWithResponse request with arbitrary body returning *UpdateRowsResponse
func (c *ClientWithResponses) UpdateRowsWithBodyWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *UpdateRowsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRowsResponse, error) {
	rsp, err := c.UpdateRowsWithBody(ctx, keyspaceId, tableId, primaryKeyValue, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRowsResponse(rsp)
}

func (c *ClientWithResponses) UpdateRowsWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *UpdateRowsParams, body UpdateRowsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRowsResponse, error) {
	rsp, err := c.UpdateRows(ctx, keyspaceId, tableId, primaryKeyValue, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRowsResponse(rsp)
}

// ReplaceRowsWithBodyWithResponse request with arbitrary body returning *ReplaceRowsResponse
func (c *ClientWithResponses) ReplaceRowsWithBodyWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *ReplaceRowsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceRowsResponse, error) {
	rsp, err := c.ReplaceRowsWithBody(ctx, keyspaceId, tableId, primaryKeyValue, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceRowsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceRowsWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, primaryKeyValue PrimaryKeyValue, params *ReplaceRowsParams, body ReplaceRowsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceRowsResponse, error) {
	rsp, err := c.ReplaceRows(ctx, keyspaceId, tableId, primaryKeyValue, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceRowsResponse(rsp)
}

// GetAllKeyspacesWithResponse request returning *GetAllKeyspacesResponse
func (c *ClientWithResponses) GetAllKeyspacesWithResponse(ctx context.Context, params *GetAllKeyspacesParams, reqEditors ...RequestEditorFn) (*GetAllKeyspacesResponse, error) {
	rsp, err := c.GetAllKeyspaces(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllKeyspacesResponse(rsp)
}

// CreateKeyspaceWithBodyWithResponse request with arbitrary body returning *CreateKeyspaceResponse
func (c *ClientWithResponses) CreateKeyspaceWithBodyWithResponse(ctx context.Context, params *CreateKeyspaceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeyspaceResponse, error) {
	rsp, err := c.CreateKeyspaceWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeyspaceResponse(rsp)
}

func (c *ClientWithResponses) CreateKeyspaceWithResponse(ctx context.Context, params *CreateKeyspaceParams, body CreateKeyspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeyspaceResponse, error) {
	rsp, err := c.CreateKeyspace(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeyspaceResponse(rsp)
}

// DeleteKeyspaceWithResponse request returning *DeleteKeyspaceResponse
func (c *ClientWithResponses) DeleteKeyspaceWithResponse(ctx context.Context, keyspaceId KeyspaceId, params *DeleteKeyspaceParams, reqEditors ...RequestEditorFn) (*DeleteKeyspaceResponse, error) {
	rsp, err := c.DeleteKeyspace(ctx, keyspaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteKeyspaceResponse(rsp)
}

// GetKeyspaceWithResponse request returning *GetKeyspaceResponse
func (c *ClientWithResponses) GetKeyspaceWithResponse(ctx context.Context, keyspaceId KeyspaceId, params *GetKeyspaceParams, reqEditors ...RequestEditorFn) (*GetKeyspaceResponse, error) {
	rsp, err := c.GetKeyspace(ctx, keyspaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeyspaceResponse(rsp)
}

// GetTablesWithResponse request returning *GetTablesResponse
func (c *ClientWithResponses) GetTablesWithResponse(ctx context.Context, keyspaceId KeyspaceId, params *GetTablesParams, reqEditors ...RequestEditorFn) (*GetTablesResponse, error) {
	rsp, err := c.GetTables(ctx, keyspaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTablesResponse(rsp)
}

// CreateTableWithBodyWithResponse request with arbitrary body returning *CreateTableResponse
func (c *ClientWithResponses) CreateTableWithBodyWithResponse(ctx context.Context, keyspaceId KeyspaceId, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTableResponse, error) {
	rsp, err := c.CreateTableWithBody(ctx, keyspaceId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTableResponse(rsp)
}

func (c *ClientWithResponses) CreateTableWithResponse(ctx context.Context, keyspaceId KeyspaceId, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTableResponse, error) {
	rsp, err := c.CreateTable(ctx, keyspaceId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTableResponse(rsp)
}

// DeleteTableWithResponse request returning *DeleteTableResponse
func (c *ClientWithResponses) DeleteTableWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *DeleteTableParams, reqEditors ...RequestEditorFn) (*DeleteTableResponse, error) {
	rsp, err := c.DeleteTable(ctx, keyspaceId, tableId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTableResponse(rsp)
}

// GetTableWithResponse request returning *GetTableResponse
func (c *ClientWithResponses) GetTableWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *GetTableParams, reqEditors ...RequestEditorFn) (*GetTableResponse, error) {
	rsp, err := c.GetTable(ctx, keyspaceId, tableId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTableResponse(rsp)
}

// ReplaceTableWithBodyWithResponse request with arbitrary body returning *ReplaceTableResponse
func (c *ClientWithResponses) ReplaceTableWithBodyWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *ReplaceTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTableResponse, error) {
	rsp, err := c.ReplaceTableWithBody(ctx, keyspaceId, tableId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTableResponse(rsp)
}

func (c *ClientWithResponses) ReplaceTableWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *ReplaceTableParams, body ReplaceTableJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTableResponse, error) {
	rsp, err := c.ReplaceTable(ctx, keyspaceId, tableId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTableResponse(rsp)
}

// GetColumnsWithResponse request returning *GetColumnsResponse
func (c *ClientWithResponses) GetColumnsWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *GetColumnsParams, reqEditors ...RequestEditorFn) (*GetColumnsResponse, error) {
	rsp, err := c.GetColumns(ctx, keyspaceId, tableId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetColumnsResponse(rsp)
}

// CreateColumnWithBodyWithResponse request with arbitrary body returning *CreateColumnResponse
func (c *ClientWithResponses) CreateColumnWithBodyWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *CreateColumnParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateColumnResponse, error) {
	rsp, err := c.CreateColumnWithBody(ctx, keyspaceId, tableId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateColumnResponse(rsp)
}

func (c *ClientWithResponses) CreateColumnWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *CreateColumnParams, body CreateColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateColumnResponse, error) {
	rsp, err := c.CreateColumn(ctx, keyspaceId, tableId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateColumnResponse(rsp)
}

// DeleteColumnWithResponse request returning *DeleteColumnResponse
func (c *ClientWithResponses) DeleteColumnWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, columnId ColumnId, params *DeleteColumnParams, reqEditors ...RequestEditorFn) (*DeleteColumnResponse, error) {
	rsp, err := c.DeleteColumn(ctx, keyspaceId, tableId, columnId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteColumnResponse(rsp)
}

// GetColumnWithResponse request returning *GetColumnResponse
func (c *ClientWithResponses) GetColumnWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, columnId ColumnId, params *GetColumnParams, reqEditors ...RequestEditorFn) (*GetColumnResponse, error) {
	rsp, err := c.GetColumn(ctx, keyspaceId, tableId, columnId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetColumnResponse(rsp)
}

// ReplaceColumnWithBodyWithResponse request with arbitrary body returning *ReplaceColumnResponse
func (c *ClientWithResponses) ReplaceColumnWithBodyWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, columnId ColumnId, params *ReplaceColumnParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceColumnResponse, error) {
	rsp, err := c.ReplaceColumnWithBody(ctx, keyspaceId, tableId, columnId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceColumnResponse(rsp)
}

func (c *ClientWithResponses) ReplaceColumnWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, columnId ColumnId, params *ReplaceColumnParams, body ReplaceColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceColumnResponse, error) {
	rsp, err := c.ReplaceColumn(ctx, keyspaceId, tableId, columnId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceColumnResponse(rsp)
}

// GetIndexesWithResponse request returning *GetIndexesResponse
func (c *ClientWithResponses) GetIndexesWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *GetIndexesParams, reqEditors ...RequestEditorFn) (*GetIndexesResponse, error) {
	rsp, err := c.GetIndexes(ctx, keyspaceId, tableId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIndexesResponse(rsp)
}

// CreateIndexWithBodyWithResponse request with arbitrary body returning *CreateIndexResponse
func (c *ClientWithResponses) CreateIndexWithBodyWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *CreateIndexParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error) {
	rsp, err := c.CreateIndexWithBody(ctx, keyspaceId, tableId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIndexResponse(rsp)
}

func (c *ClientWithResponses) CreateIndexWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, params *CreateIndexParams, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error) {
	rsp, err := c.CreateIndex(ctx, keyspaceId, tableId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIndexResponse(rsp)
}

// DeleteIndexWithResponse request returning *DeleteIndexResponse
func (c *ClientWithResponses) DeleteIndexWithResponse(ctx context.Context, keyspaceId KeyspaceId, tableId TableId, indexId IndexId, params *DeleteIndexParams, reqEditors ...RequestEditorFn) (*DeleteIndexResponse, error) {
	rsp, err := c.DeleteIndex(ctx, keyspaceId, tableId, indexId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIndexResponse(rsp)
}

// GetTypesWithResponse request returning *GetTypesResponse
func (c *ClientWithResponses) GetTypesWithResponse(ctx context.Context, keyspaceId KeyspaceId, params *GetTypesParams, reqEditors ...RequestEditorFn) (*GetTypesResponse, error) {
	rsp, err := c.GetTypes(ctx, keyspaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTypesResponse(rsp)
}

// CreateTypeWithBodyWithResponse request with arbitrary body returning *CreateTypeResponse
func (c *ClientWithResponses) CreateTypeWithBodyWithResponse(ctx context.Context, keyspaceId KeyspaceId, params *CreateTypeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTypeResponse, error) {
	rsp, err := c.CreateTypeWithBody(ctx, keyspaceId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTypeResponse(rsp)
}

func (c *ClientWithResponses) CreateTypeWithResponse(ctx context.Context, keyspaceId KeyspaceId, params *CreateTypeParams, body CreateTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTypeResponse, error) {
	rsp, err := c.CreateType(ctx, keyspaceId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTypeResponse(rsp)
}

// UpdateTypeWithBodyWithResponse request with arbitrary body returning *UpdateTypeResponse
func (c *ClientWithResponses) UpdateTypeWithBodyWithResponse(ctx context.Context, keyspaceId KeyspaceId, params *UpdateTypeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTypeResponse, error) {
	rsp, err := c.UpdateTypeWithBody(ctx, keyspaceId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTypeResponse(rsp)
}

func (c *ClientWithResponses) UpdateTypeWithResponse(ctx context.Context, keyspaceId KeyspaceId, params *UpdateTypeParams, body UpdateTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTypeResponse, error) {
	rsp, err := c.UpdateType(ctx, keyspaceId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTypeResponse(rsp)
}

// DeleteTypeWithResponse request returning *DeleteTypeResponse
func (c *ClientWithResponses) DeleteTypeWithResponse(ctx context.Context, keyspaceId KeyspaceId, typeId TypeId, params *DeleteTypeParams, reqEditors ...RequestEditorFn) (*DeleteTypeResponse, error) {
	rsp, err := c.DeleteType(ctx, keyspaceId, typeId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTypeResponse(rsp)
}

// GetTypeWithResponse request returning *GetTypeResponse
func (c *ClientWithResponses) GetTypeWithResponse(ctx context.Context, keyspaceId KeyspaceId, typeId TypeId, params *GetTypeParams, reqEditors ...RequestEditorFn) (*GetTypeResponse, error) {
	rsp, err := c.GetType(ctx, keyspaceId, typeId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTypeResponse(rsp)
}

// ParseCreateTokenResponse parses an HTTP response from a CreateTokenWithResponse call
func ParseCreateTokenResponse(rsp *http.Response) (*CreateTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AuthTokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseSearchTableResponse parses an HTTP response from a SearchTableWithResponse call
func ParseSearchTableResponse(rsp *http.Response) (*SearchTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Count *int                 `json:"count,omitempty"`
			Data  *[]map[string]string `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddRowsResponse parses an HTTP response from a AddRowsWithResponse call
func ParseAddRowsResponse(rsp *http.Response) (*AddRowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddRowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest map[string]string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteRowsResponse parses an HTTP response from a DeleteRowsWithResponse call
func ParseDeleteRowsResponse(rsp *http.Response) (*DeleteRowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRowsResponse parses an HTTP response from a GetRowsWithResponse call
func ParseGetRowsResponse(rsp *http.Response) (*GetRowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Count *int                 `json:"count,omitempty"`
			Data  *[]map[string]string `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateRowsResponse parses an HTTP response from a UpdateRowsWithResponse call
func ParseUpdateRowsResponse(rsp *http.Response) (*UpdateRowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RowsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReplaceRowsResponse parses an HTTP response from a ReplaceRowsWithResponse call
func ParseReplaceRowsResponse(rsp *http.Response) (*ReplaceRowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceRowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RowsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllKeyspacesResponse parses an HTTP response from a GetAllKeyspacesWithResponse call
func ParseGetAllKeyspacesResponse(rsp *http.Response) (*GetAllKeyspacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllKeyspacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Keyspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateKeyspaceResponse parses an HTTP response from a CreateKeyspaceWithResponse call
func ParseCreateKeyspaceResponse(rsp *http.Response) (*CreateKeyspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKeyspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Name *string `json:"name,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteKeyspaceResponse parses an HTTP response from a DeleteKeyspaceWithResponse call
func ParseDeleteKeyspaceResponse(rsp *http.Response) (*DeleteKeyspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteKeyspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetKeyspaceResponse parses an HTTP response from a GetKeyspaceWithResponse call
func ParseGetKeyspaceResponse(rsp *http.Response) (*GetKeyspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeyspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Keyspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTablesResponse parses an HTTP response from a GetTablesWithResponse call
func ParseGetTablesResponse(rsp *http.Response) (*GetTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TableArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateTableResponse parses an HTTP response from a CreateTableWithResponse call
func ParseCreateTableResponse(rsp *http.Response) (*CreateTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Name *string `json:"name,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteTableResponse parses an HTTP response from a DeleteTableWithResponse call
func ParseDeleteTableResponse(rsp *http.Response) (*DeleteTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTableResponse parses an HTTP response from a GetTableWithResponse call
func ParseGetTableResponse(rsp *http.Response) (*GetTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Table
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReplaceTableResponse parses an HTTP response from a ReplaceTableWithResponse call
func ParseReplaceTableResponse(rsp *http.Response) (*ReplaceTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Name *string `json:"name,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetColumnsResponse parses an HTTP response from a GetColumnsWithResponse call
func ParseGetColumnsResponse(rsp *http.Response) (*GetColumnsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetColumnsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ColumnDefinition `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateColumnResponse parses an HTTP response from a CreateColumnWithResponse call
func ParseCreateColumnResponse(rsp *http.Response) (*CreateColumnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateColumnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Name *string `json:"name,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteColumnResponse parses an HTTP response from a DeleteColumnWithResponse call
func ParseDeleteColumnResponse(rsp *http.Response) (*DeleteColumnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteColumnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetColumnResponse parses an HTTP response from a GetColumnWithResponse call
func ParseGetColumnResponse(rsp *http.Response) (*GetColumnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetColumnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ColumnDefinition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReplaceColumnResponse parses an HTTP response from a ReplaceColumnWithResponse call
func ParseReplaceColumnResponse(rsp *http.Response) (*ReplaceColumnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceColumnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Name *string `json:"name,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetIndexesResponse parses an HTTP response from a GetIndexesWithResponse call
func ParseGetIndexesResponse(rsp *http.Response) (*GetIndexesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIndexesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []IndexResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateIndexResponse parses an HTTP response from a CreateIndexWithResponse call
func ParseCreateIndexResponse(rsp *http.Response) (*CreateIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteIndexResponse parses an HTTP response from a DeleteIndexWithResponse call
func ParseDeleteIndexResponse(rsp *http.Response) (*DeleteIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTypesResponse parses an HTTP response from a GetTypesWithResponse call
func ParseGetTypesResponse(rsp *http.Response) (*GetTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TypeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateTypeResponse parses an HTTP response from a CreateTypeWithResponse call
func ParseCreateTypeResponse(rsp *http.Response) (*CreateTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Name *string `json:"name,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseUpdateTypeResponse parses an HTTP response from a UpdateTypeWithResponse call
func ParseUpdateTypeResponse(rsp *http.Response) (*UpdateTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteTypeResponse parses an HTTP response from a DeleteTypeWithResponse call
func ParseDeleteTypeResponse(rsp *http.Response) (*DeleteTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTypeResponse parses an HTTP response from a GetTypeWithResponse call
func ParseGetTypeResponse(rsp *http.Response) (*GetTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TypeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
