// Package astrastreaming provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package astrastreaming

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
)

const (
	BearerScopes = "Bearer.Scopes"
)

// Defines values for CryptoConfigConsumerCryptoFailureAction.
const (
	CryptoConfigConsumerCryptoFailureActionCONSUME CryptoConfigConsumerCryptoFailureAction = "CONSUME"
	CryptoConfigConsumerCryptoFailureActionDISCARD CryptoConfigConsumerCryptoFailureAction = "DISCARD"
	CryptoConfigConsumerCryptoFailureActionFAIL    CryptoConfigConsumerCryptoFailureAction = "FAIL"
)

// Defines values for CryptoConfigProducerCryptoFailureAction.
const (
	CryptoConfigProducerCryptoFailureActionFAIL CryptoConfigProducerCryptoFailureAction = "FAIL"
	CryptoConfigProducerCryptoFailureActionSEND CryptoConfigProducerCryptoFailureAction = "SEND"
)

// Defines values for DatabaseAvailableActions.
const (
	AddDatacenters       DatabaseAvailableActions = "addDatacenters"
	AddKeyspace          DatabaseAvailableActions = "addKeyspace"
	AddTable             DatabaseAvailableActions = "addTable"
	GetCreds             DatabaseAvailableActions = "getCreds"
	LaunchMigrationProxy DatabaseAvailableActions = "launchMigrationProxy"
	Park                 DatabaseAvailableActions = "park"
	RemoveKeyspace       DatabaseAvailableActions = "removeKeyspace"
	RemoveMigrationProxy DatabaseAvailableActions = "removeMigrationProxy"
	ResetPassword        DatabaseAvailableActions = "resetPassword"
	Resize               DatabaseAvailableActions = "resize"
	Terminate            DatabaseAvailableActions = "terminate"
	TerminateDatacenter  DatabaseAvailableActions = "terminateDatacenter"
	Unpark               DatabaseAvailableActions = "unpark"
)

// Defines values for DatabaseInfoCloudProvider.
const (
	DatabaseInfoCloudProviderAWS DatabaseInfoCloudProvider = "AWS"
	DatabaseInfoCloudProviderGCP DatabaseInfoCloudProvider = "GCP"
)

// Defines values for DatabaseInfoTier.
const (
	DatabaseInfoTierServerless DatabaseInfoTier = "serverless"
)

// Defines values for DatabaseInfoCreateCloudProvider.
const (
	DatabaseInfoCreateCloudProviderAWS DatabaseInfoCreateCloudProvider = "AWS"
	DatabaseInfoCreateCloudProviderGCP DatabaseInfoCreateCloudProvider = "GCP"
)

// Defines values for DatabaseInfoCreateTier.
const (
	DatabaseInfoCreateTierServerless DatabaseInfoCreateTier = "serverless"
)

// Defines values for PolicyActions.
const (
	DbAllKeyspaceCreate      PolicyActions = "db-all-keyspace-create"
	DbAllKeyspaceDescribe    PolicyActions = "db-all-keyspace-describe"
	DbCql                    PolicyActions = "db-cql"
	DbGraphql                PolicyActions = "db-graphql"
	DbKeyspaceAlter          PolicyActions = "db-keyspace-alter"
	DbKeyspaceAuthorize      PolicyActions = "db-keyspace-authorize"
	DbKeyspaceCreate         PolicyActions = "db-keyspace-create"
	DbKeyspaceDescribe       PolicyActions = "db-keyspace-describe"
	DbKeyspaceDrop           PolicyActions = "db-keyspace-drop"
	DbKeyspaceGrant          PolicyActions = "db-keyspace-grant"
	DbKeyspaceModify         PolicyActions = "db-keyspace-modify"
	DbRest                   PolicyActions = "db-rest"
	DbTableAlter             PolicyActions = "db-table-alter"
	DbTableAuthorize         PolicyActions = "db-table-authorize"
	DbTableCreate            PolicyActions = "db-table-create"
	DbTableDescribe          PolicyActions = "db-table-describe"
	DbTableDrop              PolicyActions = "db-table-drop"
	DbTableGrant             PolicyActions = "db-table-grant"
	DbTableModify            PolicyActions = "db-table-modify"
	DbTableSelect            PolicyActions = "db-table-select"
	OrgAuditsRead            PolicyActions = "org-audits-read"
	OrgBillingRead           PolicyActions = "org-billing-read"
	OrgBillingWrite          PolicyActions = "org-billing-write"
	OrgDbAddpeering          PolicyActions = "org-db-addpeering"
	OrgDbCreate              PolicyActions = "org-db-create"
	OrgDbExpand              PolicyActions = "org-db-expand"
	OrgDbManagemigratorproxy PolicyActions = "org-db-managemigratorproxy"
	OrgDbPasswordreset       PolicyActions = "org-db-passwordreset"
	OrgDbSuspend             PolicyActions = "org-db-suspend"
	OrgDbTerminate           PolicyActions = "org-db-terminate"
	OrgDbView                PolicyActions = "org-db-view"
	OrgExternalAuthRead      PolicyActions = "org-external-auth-read"
	OrgExternalAuthWrite     PolicyActions = "org-external-auth-write"
	OrgNotificationWrite     PolicyActions = "org-notification-write"
	OrgRead                  PolicyActions = "org-read"
	OrgRoleDelete            PolicyActions = "org-role-delete"
	OrgRoleRead              PolicyActions = "org-role-read"
	OrgRoleWrite             PolicyActions = "org-role-write"
	OrgTokenRead             PolicyActions = "org-token-read"
	OrgTokenWrite            PolicyActions = "org-token-write"
	OrgUserRead              PolicyActions = "org-user-read"
	OrgUserWrite             PolicyActions = "org-user-write"
	OrgWrite                 PolicyActions = "org-write"
)

// Defines values for PolicyEffect.
const (
	Allow PolicyEffect = "allow"
)

// Defines values for SinkConfigProcessingGuarantees.
const (
	SinkConfigProcessingGuaranteesATLEASTONCE     SinkConfigProcessingGuarantees = "ATLEAST_ONCE"
	SinkConfigProcessingGuaranteesATMOSTONCE      SinkConfigProcessingGuarantees = "ATMOST_ONCE"
	SinkConfigProcessingGuaranteesEFFECTIVELYONCE SinkConfigProcessingGuarantees = "EFFECTIVELY_ONCE"
)

// Defines values for SinkConfigSourceSubscriptionPosition.
const (
	Earliest SinkConfigSourceSubscriptionPosition = "Earliest"
	Latest   SinkConfigSourceSubscriptionPosition = "Latest"
)

// Defines values for SourceConfigProcessingGuarantees.
const (
	SourceConfigProcessingGuaranteesATLEASTONCE     SourceConfigProcessingGuarantees = "ATLEAST_ONCE"
	SourceConfigProcessingGuaranteesATMOSTONCE      SourceConfigProcessingGuarantees = "ATMOST_ONCE"
	SourceConfigProcessingGuaranteesEFFECTIVELYONCE SourceConfigProcessingGuarantees = "EFFECTIVELY_ONCE"
)

// Defines values for StatusEnum.
const (
	ACTIVE       StatusEnum = "ACTIVE"
	ERROR        StatusEnum = "ERROR"
	HIBERNATED   StatusEnum = "HIBERNATED"
	HIBERNATING  StatusEnum = "HIBERNATING"
	INITIALIZING StatusEnum = "INITIALIZING"
	MAINTENANCE  StatusEnum = "MAINTENANCE"
	PARKED       StatusEnum = "PARKED"
	PARKING      StatusEnum = "PARKING"
	PENDING      StatusEnum = "PENDING"
	PREPARED     StatusEnum = "PREPARED"
	PREPARING    StatusEnum = "PREPARING"
	RESIZING     StatusEnum = "RESIZING"
	RESUMING     StatusEnum = "RESUMING"
	TERMINATED   StatusEnum = "TERMINATED"
	TERMINATING  StatusEnum = "TERMINATING"
	UNKNOWN      StatusEnum = "UNKNOWN"
	UNPARKING    StatusEnum = "UNPARKING"
)

// AccessListConfigurations defines model for AccessListConfigurations.
type AccessListConfigurations struct {
	AccessListEnabled bool `json:"accessListEnabled"`
}

// The model used to build an access list.
type AccessListRequest struct {
	// A listing of the allowed addresses
	Addresses      *[]AddressRequest         `json:"addresses,omitempty"`
	Configurations *AccessListConfigurations `json:"configurations,omitempty"`
}

// The response for a requested access list.
type AccessListResponse struct {
	// A listing of the allowed addresses
	Addresses      *[]AddressResponse        `json:"addresses,omitempty"`
	Configurations *AccessListConfigurations `json:"configurations,omitempty"`

	// The unique identifier of the database
	DatabaseId *openapi_types.UUID `json:"databaseId,omitempty"`

	// The unique identifier of the organization
	OrganizationId *openapi_types.UUID `json:"organizationId,omitempty"`
}

// The model used to build an address for an access list.
type AddressRequest struct {
	// The address (IP address and subnet mask in CIDR notation) of the address to allow
	Address string `json:"address"`

	// Description of this addresses use
	Description string `json:"description"`

	// The indication if the access address is enabled or not
	Enabled bool `json:"enabled"`
}

// The response for a requested address in an access list.
type AddressResponse struct {
	// The address (IP address and subnet mask in CIDR notation) of the address to allow.
	Address *string `json:"address,omitempty"`

	// Description of this addresses use
	Description *string `json:"description,omitempty"`

	// The indication if the access address is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`

	// The last update date/time for the access list.
	LastUpdateDateTime *time.Time `json:"lastUpdateDateTime,omitempty"`
}

// AvailableRegionCombination defines a tier, cloud provider, and region combination.
type AvailableRegionCombination struct {
	CapacityUnitsLimit              int    `json:"capacityUnitsLimit"`
	CapacityUnitsUsed               int    `json:"capacityUnitsUsed"`
	CloudProvider                   string `json:"cloudProvider"`
	Cost                            Costs  `json:"cost"`
	DatabaseCountLimit              int    `json:"databaseCountLimit"`
	DatabaseCountUsed               int    `json:"databaseCountUsed"`
	DefaultStoragePerCapacityUnitGb int    `json:"defaultStoragePerCapacityUnitGb"`
	Region                          string `json:"region"`
	Tier                            string `json:"tier"`
}

// BatchSourceConfig defines model for BatchSourceConfig.
type BatchSourceConfig struct {
	DiscoveryTriggererClassName *string                                     `json:"discoveryTriggererClassName,omitempty"`
	DiscoveryTriggererConfig    *BatchSourceConfig_DiscoveryTriggererConfig `json:"discoveryTriggererConfig,omitempty"`
}

// BatchSourceConfig_DiscoveryTriggererConfig defines model for BatchSourceConfig.DiscoveryTriggererConfig.
type BatchSourceConfig_DiscoveryTriggererConfig struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// CapacityUnits is used to horizontally scale a database.
type CapacityUnits struct {
	// CapacityUnits can be increased by a max of three additional capacity units per operation. Reducing capacity units is not currently supported.
	CapacityUnits *int `json:"capacityUnits,omitempty"`
}

// An individual clientID and associated roles.
type ClientRole struct {
	// the clientID
	ClientId *string   `json:"clientId,omitempty"`
	Roles    *[]string `json:"roles,omitempty"`
}

// The response for a requested token.
type ClientRoleList struct {
	// a list of clientId and associated roles.
	Clients *[]ClientRole `json:"clients,omitempty"`
}

// ClusterResponse is the response struct for a cluster
type ClusterResponse struct {
	PulsarURL           *string `json:"brokerServiceUrl,omitempty"`
	CloudProvider       *string `json:"cloudProvider,omitempty"`
	CloudProviderRegion *string `json:"cloudRegion,omitempty"`
	ClusterName         *string `json:"clusterName,omitempty"`
	ClusterType         *string `json:"clusterType,omitempty"`
	AdminURL            *string `json:"webServiceUrl,omitempty"`
	WebsocketURL        *string `json:"websocketUrl,omitempty"`
}

// ConsumerConfig defines model for ConsumerConfig.
type ConsumerConfig struct {
	ConsumerProperties *ConsumerConfig_ConsumerProperties `json:"consumerProperties,omitempty"`
	CryptoConfig       *CryptoConfig                      `json:"cryptoConfig,omitempty"`
	PoolMessages       *bool                              `json:"poolMessages,omitempty"`
	ReceiverQueueSize  *int32                             `json:"receiverQueueSize,omitempty"`
	RegexPattern       *bool                              `json:"regexPattern,omitempty"`
	SchemaProperties   *ConsumerConfig_SchemaProperties   `json:"schemaProperties,omitempty"`
	SchemaType         *string                            `json:"schemaType,omitempty"`
	SerdeClassName     *string                            `json:"serdeClassName,omitempty"`
}

// ConsumerConfig_ConsumerProperties defines model for ConsumerConfig.ConsumerProperties.
type ConsumerConfig_ConsumerProperties struct {
	AdditionalProperties map[string]string `json:"-"`
}

// ConsumerConfig_SchemaProperties defines model for ConsumerConfig.SchemaProperties.
type ConsumerConfig_SchemaProperties struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Costs defines model for Costs.
type Costs struct {
	CostPerDayCents         *float64 `json:"costPerDayCents,omitempty"`
	CostPerDayParkedCents   *float64 `json:"costPerDayParkedCents,omitempty"`
	CostPerHourCents        *float64 `json:"costPerHourCents,omitempty"`
	CostPerHourParkedCents  *float64 `json:"costPerHourParkedCents,omitempty"`
	CostPerMinCents         *float64 `json:"costPerMinCents,omitempty"`
	CostPerMinParkedCents   *float64 `json:"costPerMinParkedCents,omitempty"`
	CostPerMonthCents       *float64 `json:"costPerMonthCents,omitempty"`
	CostPerMonthParkedCents *float64 `json:"costPerMonthParkedCents,omitempty"`
}

// The createRole model.
type CreateRoleRequest struct {
	// The name for your custom role in your organization.
	Name string `json:"name"`

	// A policy for a role in Astra.
	Policy Policy `json:"policy"`
}

// CredsURL from which the creds zip may be downloaded.
type CredsURL struct {
	// DownloadURL is only valid for about 5 minutes.
	DownloadURL string `json:"downloadURL"`

	// Internal DownloadURL is only valid for about 5 minutes.
	DownloadURLInternal *string `json:"downloadURLInternal,omitempty"`

	// Migration Proxy DownloadURL is only valid for about 5 minutes.
	DownloadURLMigrationProxy *string `json:"downloadURLMigrationProxy,omitempty"`

	// Internal Migration Proxy DownloadURL is only valid for about 5 minutes.
	DownloadURLMigrationProxyInternal *string `json:"downloadURLMigrationProxyInternal,omitempty"`
}

// CryptoConfig defines model for CryptoConfig.
type CryptoConfig struct {
	ConsumerCryptoFailureAction *CryptoConfigConsumerCryptoFailureAction `json:"consumerCryptoFailureAction,omitempty"`
	CryptoKeyReaderClassName    *string                                  `json:"cryptoKeyReaderClassName,omitempty"`
	CryptoKeyReaderConfig       *CryptoConfig_CryptoKeyReaderConfig      `json:"cryptoKeyReaderConfig,omitempty"`
	EncryptionKeys              *[]string                                `json:"encryptionKeys,omitempty"`
	ProducerCryptoFailureAction *CryptoConfigProducerCryptoFailureAction `json:"producerCryptoFailureAction,omitempty"`
}

// CryptoConfigConsumerCryptoFailureAction defines model for CryptoConfig.ConsumerCryptoFailureAction.
type CryptoConfigConsumerCryptoFailureAction string

// CryptoConfig_CryptoKeyReaderConfig defines model for CryptoConfig.CryptoKeyReaderConfig.
type CryptoConfig_CryptoKeyReaderConfig struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// CryptoConfigProducerCryptoFailureAction defines model for CryptoConfig.ProducerCryptoFailureAction.
type CryptoConfigProducerCryptoFailureAction string

// Database contains the key information about a database.
type Database struct {
	AvailableActions *[]DatabaseAvailableActions `json:"availableActions,omitempty"`
	CqlshUrl         *string                     `json:"cqlshUrl,omitempty"`

	// CreationTime in ISO RFC3339 format
	CreationTime    *string `json:"creationTime,omitempty"`
	DataEndpointUrl *string `json:"dataEndpointUrl,omitempty"`
	GrafanaUrl      *string `json:"grafanaUrl,omitempty"`
	GraphqlUrl      *string `json:"graphqlUrl,omitempty"`
	Id              string  `json:"id"`

	// DatabaseInfo is the user-provided information describing a database.
	Info DatabaseInfo `json:"info"`

	// Message to the customer about the cluster.
	Message *string    `json:"message,omitempty"`
	OrgId   string     `json:"orgId"`
	OwnerId string     `json:"ownerId"`
	Status  StatusEnum `json:"status"`

	// Storage contains the information about how much storage space a cluster has available.
	Storage   *Storage `json:"storage,omitempty"`
	StudioUrl *string  `json:"studioUrl,omitempty"`

	// TerminationTime in ISO RFC3339 format
	TerminationTime *string `json:"terminationTime,omitempty"`
}

// DatabaseAvailableActions defines model for Database.AvailableActions.
type DatabaseAvailableActions string

// DatabaseInfo is the user-provided information describing a database.
type DatabaseInfo struct {
	// Additional keyspaces names in database.
	AdditionalKeyspaces *[]string `json:"additionalKeyspaces,omitempty"`

	// Capacity units were used for classic databases, but are not used for serverless databases. Enter 1 CU for serverless databases. Classic databases can no longer be created with the DevOps API.
	CapacityUnits *int `json:"capacityUnits,omitempty"`

	// This is the cloud provider where the database lives.
	CloudProvider *DatabaseInfoCloudProvider `json:"cloudProvider,omitempty"`

	// Keyspace name in database.
	Keyspace *string `json:"keyspace,omitempty"`

	// Name of the database--user friendly identifier.
	Name *string `json:"name,omitempty"`

	// Password for the user to access the database.
	Password *string `json:"password,omitempty"`

	// Region refers to the cloud region.
	Region *string `json:"region,omitempty"`

	// With the exception of classic databases, all databases are serverless. Classic databases can no longer be created with the DevOps API.
	Tier *DatabaseInfoTier `json:"tier,omitempty"`

	// User is the user to access the database.
	User *string `json:"user,omitempty"`
}

// This is the cloud provider where the database lives.
type DatabaseInfoCloudProvider string

// With the exception of classic databases, all databases are serverless. Classic databases can no longer be created with the DevOps API.
type DatabaseInfoTier string

// DatabaseInfo is the user-provided information describing a database.
type DatabaseInfoCreate struct {
	// Capacity units were used for classic databases, but are not used for serverless databases. Enter 1 CU for serverless databases. Classic databases can no longer be created with the DevOps API.
	CapacityUnits int `json:"capacityUnits"`

	// This is the cloud provider where the database lives.
	CloudProvider DatabaseInfoCreateCloudProvider `json:"cloudProvider"`

	// Keyspace name in database.
	Keyspace string `json:"keyspace"`

	// Name of the database--user friendly identifier.
	Name string `json:"name"`

	// Region refers to the cloud region.
	Region string `json:"region"`

	// With the exception of classic databases, all databases are serverless. Classic databases can no longer be created with the DevOps API.
	Tier DatabaseInfoCreateTier `json:"tier"`
}

// This is the cloud provider where the database lives.
type DatabaseInfoCreateCloudProvider string

// With the exception of classic databases, all databases are serverless. Classic databases can no longer be created with the DevOps API.
type DatabaseInfoCreateTier string

// ModelError information that is returned to users.
type Error struct {
	// API specific error code.
	ID *int `json:"ID,omitempty"`

	// User-friendly description of error.
	Message string `json:"message"`
}

// Errors is a collection of individual Error objects.
type Errors struct {
	Errors []Error `json:"errors"`
}

// The POST body to generate a token.
type GenerateTokenBody struct {
	// The roles for which the token will be generated.
	Roles []string `json:"roles"`
}

// The response for a requested token.
type GenerateTokenResponse struct {
	// The ID of the client (UUID).
	ClientId string `json:"clientId"`

	// The UUID of the organization.
	OrgId string `json:"orgId"`

	// The roles for which the token will be generated.
	Roles []string `json:"roles"`

	// The secret token.
	Secret string `json:"secret"`

	// AstraCS:clientId:hex(sha256(secret))
	Token *string `json:"token,omitempty"`
}

// GetOrgUsersResponse defines model for GetOrgUsersResponse.
type GetOrgUsersResponse struct {
	OrgID   string `json:"orgID"`
	OrgName string `json:"orgName"`

	// an array of users in the organization
	Users []UserResponse `json:"users"`
}

// LimitResponse is a response for tenant limits
type LimitResponse struct {
	NamespaceLimit         *int64                       `json:"namespace_limit,omitempty"`
	TopicPerNamespaceLimit *int64                       `json:"topic_per_namespace_limit,omitempty"`
	Usage                  *[]TenantNamespaceLimitUsage `json:"usage,omitempty"`
}

// An organization.
type Organization struct {
	// The organization UUID.
	Id string `json:"id"`
}

// A policy for a role in Astra.
type Policy struct {
	// The actions this policy can take. Example actions: 'org-billing-write' 'db-keyspace-create'.
	Actions []PolicyActions `json:"actions"`

	// A description of this policy.
	Description string `json:"description"`

	// Effect this policy will have on the provided resource.
	Effect PolicyEffect `json:"effect"`

	// The resources this policy can manipulate.
	Resources []string `json:"resources"`
}

// PolicyActions defines model for Policy.Actions.
type PolicyActions string

// Effect this policy will have on the provided resource.
type PolicyEffect string

// ProducerConfig defines model for ProducerConfig.
type ProducerConfig struct {
	BatchBuilder                       *string       `json:"batchBuilder,omitempty"`
	CryptoConfig                       *CryptoConfig `json:"cryptoConfig,omitempty"`
	MaxPendingMessages                 *int32        `json:"maxPendingMessages,omitempty"`
	MaxPendingMessagesAcrossPartitions *int32        `json:"maxPendingMessagesAcrossPartitions,omitempty"`
	UseThreadLocalProducers            *bool         `json:"useThreadLocalProducers,omitempty"`
}

// Resources defines model for Resources.
type Resources struct {
	Cpu  *float64 `json:"cpu,omitempty"`
	Disk *int64   `json:"disk,omitempty"`
	Ram  *int64   `json:"ram,omitempty"`
}

// ResponseErr error struct for Pulsar compliant HTTP responses
type ResponseErr struct {
	Error *string `json:"reason,omitempty"`
}

// Details of a user role and its policy details.
type Role struct {
	// The unique system generated identifier of the role.
	Id *string `json:"id,omitempty"`

	// The date and time of the last update on the role.
	LastUpdateDatetime *time.Time `json:"last_update_datetime,omitempty"`

	// The userID of the user who last updated the role.
	LastUpdateUserid *string `json:"last_update_userid,omitempty"`

	// The name of the role.
	Name *string `json:"name,omitempty"`

	// A policy for a role in Astra.
	Policy *Policy `json:"policy,omitempty"`
}

// The roleInvite model.
type RoleInviteRequest struct {
	Roles []string `json:"roles"`
}

// An array of roles.
type Roles = []Role

// SinkConfig defines model for SinkConfig.
type SinkConfig struct {
	Archive                      *string                               `json:"archive,omitempty"`
	AutoAck                      *bool                                 `json:"autoAck,omitempty"`
	ClassName                    *string                               `json:"className,omitempty"`
	CleanupSubscription          *bool                                 `json:"cleanupSubscription,omitempty"`
	Configs                      *map[string]interface{}               `json:"configs,omitempty"`
	CustomRuntimeOptions         *string                               `json:"customRuntimeOptions,omitempty"`
	DeadLetterTopic              *string                               `json:"deadLetterTopic,omitempty"`
	InputSpecs                   *SinkConfig_InputSpecs                `json:"inputSpecs,omitempty"`
	Inputs                       *[]string                             `json:"inputs,omitempty"`
	MaxMessageRetries            *int32                                `json:"maxMessageRetries,omitempty"`
	Name                         *string                               `json:"name,omitempty"`
	Namespace                    *string                               `json:"namespace,omitempty"`
	NegativeAckRedeliveryDelayMs *int64                                `json:"negativeAckRedeliveryDelayMs,omitempty"`
	Parallelism                  *int32                                `json:"parallelism,omitempty"`
	ProcessingGuarantees         *SinkConfigProcessingGuarantees       `json:"processingGuarantees,omitempty"`
	Resources                    *Resources                            `json:"resources,omitempty"`
	RetainKeyOrdering            *bool                                 `json:"retainKeyOrdering,omitempty"`
	RetainOrdering               *bool                                 `json:"retainOrdering,omitempty"`
	RuntimeFlags                 *string                               `json:"runtimeFlags,omitempty"`
	Secrets                      *SinkConfig_Secrets                   `json:"secrets,omitempty"`
	SinkType                     *string                               `json:"sinkType,omitempty"`
	SourceSubscriptionName       *string                               `json:"sourceSubscriptionName,omitempty"`
	SourceSubscriptionPosition   *SinkConfigSourceSubscriptionPosition `json:"sourceSubscriptionPosition,omitempty"`
	Tenant                       *string                               `json:"tenant,omitempty"`
	TimeoutMs                    *int64                                `json:"timeoutMs,omitempty"`
	TopicToSchemaProperties      *SinkConfig_TopicToSchemaProperties   `json:"topicToSchemaProperties,omitempty"`
	TopicToSchemaType            *SinkConfig_TopicToSchemaType         `json:"topicToSchemaType,omitempty"`
	TopicToSerdeClassName        *SinkConfig_TopicToSerdeClassName     `json:"topicToSerdeClassName,omitempty"`
	TopicsPattern                *string                               `json:"topicsPattern,omitempty"`
}

// SinkConfig_InputSpecs defines model for SinkConfig.InputSpecs.
type SinkConfig_InputSpecs struct {
	AdditionalProperties map[string]ConsumerConfig `json:"-"`
}

// SinkConfigProcessingGuarantees defines model for SinkConfig.ProcessingGuarantees.
type SinkConfigProcessingGuarantees string

// SinkConfig_Secrets defines model for SinkConfig.Secrets.
type SinkConfig_Secrets struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// SinkConfigSourceSubscriptionPosition defines model for SinkConfig.SourceSubscriptionPosition.
type SinkConfigSourceSubscriptionPosition string

// SinkConfig_TopicToSchemaProperties defines model for SinkConfig.TopicToSchemaProperties.
type SinkConfig_TopicToSchemaProperties struct {
	AdditionalProperties map[string]string `json:"-"`
}

// SinkConfig_TopicToSchemaType defines model for SinkConfig.TopicToSchemaType.
type SinkConfig_TopicToSchemaType struct {
	AdditionalProperties map[string]string `json:"-"`
}

// SinkConfig_TopicToSerdeClassName defines model for SinkConfig.TopicToSerdeClassName.
type SinkConfig_TopicToSerdeClassName struct {
	AdditionalProperties map[string]string `json:"-"`
}

// SourceConfig defines model for SourceConfig.
type SourceConfig struct {
	Archive              *string                           `json:"archive,omitempty"`
	BatchBuilder         *string                           `json:"batchBuilder,omitempty"`
	BatchSourceConfig    *BatchSourceConfig                `json:"batchSourceConfig,omitempty"`
	ClassName            *string                           `json:"className,omitempty"`
	Configs              *SourceConfig_Configs             `json:"configs,omitempty"`
	CustomRuntimeOptions *string                           `json:"customRuntimeOptions,omitempty"`
	Name                 *string                           `json:"name,omitempty"`
	Namespace            *string                           `json:"namespace,omitempty"`
	Parallelism          *int32                            `json:"parallelism,omitempty"`
	ProcessingGuarantees *SourceConfigProcessingGuarantees `json:"processingGuarantees,omitempty"`
	ProducerConfig       *ProducerConfig                   `json:"producerConfig,omitempty"`
	Resources            *Resources                        `json:"resources,omitempty"`
	RuntimeFlags         *string                           `json:"runtimeFlags,omitempty"`
	SchemaType           *string                           `json:"schemaType,omitempty"`
	Secrets              *SourceConfig_Secrets             `json:"secrets,omitempty"`
	SerdeClassName       *string                           `json:"serdeClassName,omitempty"`
	Tenant               *string                           `json:"tenant,omitempty"`
	TopicName            *string                           `json:"topicName,omitempty"`
}

// SourceConfig_Configs defines model for SourceConfig.Configs.
type SourceConfig_Configs struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// SourceConfigProcessingGuarantees defines model for SourceConfig.ProcessingGuarantees.
type SourceConfigProcessingGuarantees string

// SourceConfig_Secrets defines model for SourceConfig.Secrets.
type SourceConfig_Secrets struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// StatusEnum defines model for StatusEnum.
type StatusEnum string

// Storage contains the information about how much storage space a cluster has available.
type Storage struct {
	// NodeCount for the cluster.
	NodeCount int `json:"nodeCount"`

	// ReplicationFactor is the number of nodes storing a piece of data.
	ReplicationFactor int `json:"replicationFactor"`

	// TotalStorage of the cluster in GB.
	TotalStorage int `json:"totalStorage"`

	// UsedStorage in GB.
	UsedStorage *int `json:"usedStorage,omitempty"`
}

// TenantClusterPlanResponse tenant per cluster access
// For initial creation so namespace and topic are added
type TenantClusterPlanResponse struct {
	OrgName                *string `json:"astraOrgGUID,omitempty"`
	PulsarURL              *string `json:"brokerServiceUrl,omitempty"`
	CloudProvider          *string `json:"cloudProvider,omitempty"`
	CloudProviderCode      *string `json:"cloudProviderCode,omitempty"`
	CloudProviderRegion    *string `json:"cloudRegion,omitempty"`
	ClusterName            *string `json:"clusterName,omitempty"`
	PulsarJVMVersion       *string `json:"jvmVersion,omitempty"`
	Namespace              *string `json:"namespace,omitempty"`
	Plan                   *string `json:"plan,omitempty"`
	PlanCode               *string `json:"planCode,omitempty"`
	TenantPulsarToken      *string `json:"pulsarToken,omitempty"`
	PulsarVersion          *string `json:"pulsarVersion,omitempty"`
	Status                 *string `json:"status,omitempty"`
	TenantName             *string `json:"tenantName,omitempty"`
	TopicName              *string `json:"topic,omitempty"`
	AdminURL               *string `json:"webServiceUrl,omitempty"`
	WebsocketQueryParamURL *string `json:"websocketQueryParamUrl,omitempty"`
	WebsocketURL           *string `json:"websocketUrl,omitempty"`
}

// TenantNamespaceLimitUsage holds usages for enforcing limits
type TenantNamespaceLimitUsage struct {
	Namespace *string   `json:"namespace,omitempty"`
	Topics    *[]string `json:"topics,omitempty"`
}

// The updateRole model
type UpdateRoleRequest struct {
	// The name of the custom role you want to update in your organization.
	Name string `json:"name"`

	// A policy for a role in Astra.
	Policy Policy `json:"policy"`
}

// Usage is the data usage per single tenant
type Usage struct {
	BacklogStorageSize  *float64   `json:"backlogStorageByteSize,omitempty"`
	ConsumerCount       *float64   `json:"consumerCount,omitempty"`
	MsgBacklog          *float64   `json:"msgBacklogNumber,omitempty"`
	MsgRateIn           *float64   `json:"msgRateIn,omitempty"`
	MsgRateOut          *float64   `json:"msgRateOut,omitempty"`
	Name                *string    `json:"name,omitempty"`
	ProducerCount       *float64   `json:"producerCount,omitempty"`
	StorageSize         *float64   `json:"storageSize,omitempty"`
	SubscriptionCount   *float64   `json:"subscriptionCount,omitempty"`
	SubscriptionDelayed *float64   `json:"subscriptionDelayed,omitempty"`
	ThroughputIn        *float64   `json:"throughputIn,omitempty"`
	ThroughputOut       *float64   `json:"throughputOut,omitempty"`
	TotalBytesIn        *float64   `json:"totalBytesIn,omitempty"`
	TotalBytesOut       *float64   `json:"totalBytesOut,omitempty"`
	TotalMessagesIn     *float64   `json:"totalMessagesIn,omitempty"`
	TotalMessagesOut    *float64   `json:"totalMessagesOut,omitempty"`
	UpdatedAt           *time.Time `json:"updatedAt,omitempty"`
}

// The userInvite model
type UserInvite struct {
	// The email of the user being invited
	Email string `json:"email"`

	// The unique system generated identifier of the organization
	OrgID string   `json:"orgID"`
	Roles []string `json:"roles"`
}

// UserPassword specifies a username and new password. The specified password will be updated for the specified database user.
type UserPassword struct {
	// New password (min 6 characters)
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UserResponse defines model for UserResponse.
type UserResponse struct {
	Email *string `json:"email,omitempty"`

	// an array of roles the user belongs to for an organization
	Roles *[]Role `json:"roles,omitempty"`

	// The status of a user within an organization either active or invited
	Status *string `json:"status,omitempty"`
	UserID string  `json:"userID"`
}

// The response for validation checks.
type ValidationResponse struct {
	Valid              *bool     `json:"valid,omitempty"`
	ValidationFailures *[]string `json:"validationFailures,omitempty"`
}

// cdcRequest model
type CdcRequest struct {
	// Astra database id
	DatabaseId string `json:"databaseId"`

	// Astra database name
	DatabaseName string `json:"databaseName"`

	// keyspace
	Keyspace string `json:"keyspace"`

	// The unique system generated identifier of the organization
	OrgId string `json:"orgId"`

	// tableName
	TableName string `json:"tableName"`

	// Number of partitions for pulsar topic (e.g. 3)
	TopicPartitions int `json:"topicPartitions"`
}

// CreatedTenantResponse defines model for createdTenantResponse.
type CreatedTenantResponse struct {
	// TenantClusterPlanResponse tenant per cluster access
	// For initial creation so namespace and topic are added
	Body *TenantClusterPlanResponse `json:"Body,omitempty"`
}

// ErrorResponse defines model for errorResponse.
type ErrorResponse struct {
	// ResponseErr error struct for Pulsar compliant HTTP responses
	Body ResponseErr `json:"Body"`
}

// ListOfMaps defines model for listOfMaps.
type ListOfMaps = []struct {
	AdditionalProperties map[string]string `json:"-"`
}

// ProviderRegionsResponse defines model for providerRegionsResponse.
type ProviderRegionsResponse struct {
	Body *ProviderRegionsResponse_Body `json:"Body,omitempty"`
}

// ProviderRegionsResponse_Body defines model for ProviderRegionsResponse.Body.
type ProviderRegionsResponse_Body struct {
	AdditionalProperties map[string][]string `json:"-"`
}

// PulsarClustersResponse defines model for pulsarClustersResponse.
type PulsarClustersResponse struct {
	Body *[]ClusterResponse `json:"Body,omitempty"`
}

// StatsResponse defines model for statsResponse.
type StatsResponse struct {
	Body *StatsResponse_Body `json:"Body,omitempty"`
}

// StatsResponse_Body defines model for StatsResponse.Body.
type StatsResponse_Body struct {
	AdditionalProperties map[string]Usage `json:"-"`
}

// TenantClusterPlansResponse defines model for tenantClusterPlansResponse.
type TenantClusterPlansResponse = []interface{}

// TenantLimitResponse defines model for tenantLimitResponse.
type TenantLimitResponse struct {
	// LimitResponse is a response for tenant limits
	Body *LimitResponse `json:"Body,omitempty"`
}

// TenantRequest defines model for tenantRequest.
type TenantRequest struct {
	CloudProvider *string `json:"cloudProvider,omitempty"`
	CloudRegion   *string `json:"cloudRegion,omitempty"`
	OrgID         *string `json:"orgID,omitempty"`
	OrgName       *string `json:"orgName,omitempty"`
	TenantName    *string `json:"tenantName,omitempty"`
	UserEmail     *string `json:"userEmail,omitempty"`
}

// AddressesQueryParam defines model for AddressesQueryParam.
type AddressesQueryParam = []string

// ClientIdParam defines model for ClientIdParam.
type ClientIdParam = string

// DatabaseIdParam defines model for DatabaseIdParam.
type DatabaseIdParam = string

// KeyspaceNameParam defines model for KeyspaceNameParam.
type KeyspaceNameParam = string

// RoleIdParam defines model for RoleIdParam.
type RoleIdParam = string

// UserIdParam defines model for UserIdParam.
type UserIdParam = string

// Errors is a collection of individual Error objects.
type BadRequest = Errors

// Errors is a collection of individual Error objects.
type Conflict = Errors

// Errors is a collection of individual Error objects.
type Forbidden = Errors

// Errors is a collection of individual Error objects.
type NotFound = Errors

// Errors is a collection of individual Error objects.
type ServerError = Errors

// Errors is a collection of individual Error objects.
type Unauthorized = Errors

// Errors is a collection of individual Error objects.
type UnprocessableEntity = Errors

// GetTenantsParams defines parameters for GetTenants.
type GetTenantsParams struct {
	// Astra JWT token
	Authorization string `json:"Authorization"`

	// Astra Streaming Cluster Name.
	XDataStaxPulsarCluster *string `json:"X-DataStax-Pulsar-Cluster,omitempty"`
}

// DeleteTopicParams defines parameters for DeleteTopic.
type DeleteTopicParams struct {
	// Astra Org ID.
	XDataStaxCurrentOrg *string `json:"X-DataStax-Current-Org,omitempty"`

	// Astra JWT token
	Authorization string `json:"Authorization"`

	// Astra Streaming Cluster Name.
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
}

// CreateTopicParams defines parameters for CreateTopic.
type CreateTopicParams struct {
	// Astra Org ID.
	XDataStaxCurrentOrg *string `json:"X-DataStax-Current-Org,omitempty"`

	// Astra JWT token
	Authorization string `json:"Authorization"`

	// Astra Streaming Cluster Name.
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
}

// DeleteCDCJSONBody defines parameters for DeleteCDC.
type DeleteCDCJSONBody = CdcRequest

// DeleteCDCParams defines parameters for DeleteCDC.
type DeleteCDCParams struct {
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
	Authorization          string `json:"authorization"`
}

// GetCDCParams defines parameters for GetCDC.
type GetCDCParams struct {
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
	Authorization          string `json:"authorization"`
}

// EnableCDCJSONBody defines parameters for EnableCDC.
type EnableCDCJSONBody = CdcRequest

// EnableCDCParams defines parameters for EnableCDC.
type EnableCDCParams struct {
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
	Authorization          string `json:"authorization"`
}

// DeleteSinkParams defines parameters for DeleteSink.
type DeleteSinkParams struct {
	// Astra Org ID.
	XDataStaxCurrentOrg string `json:"X-DataStax-Current-Org"`

	// Astra JWT token
	Authorization string `json:"Authorization"`

	// Astra Streaming Cluster Name.
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
}

// GetSinksParams defines parameters for GetSinks.
type GetSinksParams struct {
	// Astra JWT token
	Authorization string `json:"Authorization"`

	// Astra Streaming Cluster Name.
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
}

// CreateSinkJSONJSONBody defines parameters for CreateSinkJSON.
type CreateSinkJSONJSONBody = SinkConfig

// CreateSinkJSONParams defines parameters for CreateSinkJSON.
type CreateSinkJSONParams struct {
	// Astra JWT token
	Authorization string `json:"Authorization"`

	// Astra Org ID.
	XDataStaxCurrentOrg string `json:"X-DataStax-Current-Org"`

	// Astra Streaming Cluster Name.
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
}

// UpdateSinkJSONJSONBody defines parameters for UpdateSinkJSON.
type UpdateSinkJSONJSONBody = SinkConfig

// UpdateSinkJSONParams defines parameters for UpdateSinkJSON.
type UpdateSinkJSONParams struct {
	// Astra JWT token
	Authorization string `json:"Authorization"`

	// Astra Org ID.
	XDataStaxCurrentOrg string `json:"X-DataStax-Current-Org"`

	// Astra Streaming Cluster Name.
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
}

// CreateSourceJSONJSONBody defines parameters for CreateSourceJSON.
type CreateSourceJSONJSONBody = SourceConfig

// CreateSourceJSONParams defines parameters for CreateSourceJSON.
type CreateSourceJSONParams struct {
	// Astra JWT token
	Authorization string `json:"Authorization"`

	// Astra Org ID.
	XDataStaxCurrentOrg string `json:"X-DataStax-Current-Org"`

	// Astra Streaming Cluster Name.
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
}

// UpdateSourceJSONJSONBody defines parameters for UpdateSourceJSON.
type UpdateSourceJSONJSONBody = SourceConfig

// UpdateSourceJSONParams defines parameters for UpdateSourceJSON.
type UpdateSourceJSONParams struct {
	// Astra JWT token
	Authorization string `json:"Authorization"`

	// Astra Org ID.
	XDataStaxCurrentOrg string `json:"X-DataStax-Current-Org"`

	// Astra Streaming Cluster Name.
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
}

// GetBuiltInSinksParams defines parameters for GetBuiltInSinks.
type GetBuiltInSinksParams struct {
	// Astra JWT token
	Authorization string `json:"Authorization"`

	// Astra Streaming Cluster Name.
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
}

// GenerateTokenForClientJSONBody defines parameters for GenerateTokenForClient.
type GenerateTokenForClientJSONBody = GenerateTokenBody

// ListDatabasesParams defines parameters for ListDatabases.
type ListDatabasesParams struct {
	// Allows filtering so that databases in listed states are returned.
	Include *ListDatabasesParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Allows filtering so that databases from a given provider are returned.
	Provider *ListDatabasesParamsProvider `form:"provider,omitempty" json:"provider,omitempty"`

	// Optional parameter for pagination purposes. Used as this value for starting retrieving a specific page of results.
	StartingAfter *string `form:"starting_after,omitempty" json:"starting_after,omitempty"`

	// Optional parameter for pagination purposes. Specify the number of items for one page of data.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ListDatabasesParamsInclude defines parameters for ListDatabases.
type ListDatabasesParamsInclude string

// ListDatabasesParamsProvider defines parameters for ListDatabases.
type ListDatabasesParamsProvider string

// CreateDatabaseJSONBody defines parameters for CreateDatabase.
type CreateDatabaseJSONBody = DatabaseInfoCreate

// DeleteAddressesOrAccessListForDatabaseParams defines parameters for DeleteAddressesOrAccessListForDatabase.
type DeleteAddressesOrAccessListForDatabaseParams struct {
	// Array of addresses
	Addresses *AddressesQueryParam `form:"addresses,omitempty" json:"addresses,omitempty"`
}

// UpdateAccessListForDatabaseJSONBody defines parameters for UpdateAccessListForDatabase.
type UpdateAccessListForDatabaseJSONBody = AccessListRequest

// AddAddressesToAccessListForDatabaseJSONBody defines parameters for AddAddressesToAccessListForDatabase.
type AddAddressesToAccessListForDatabaseJSONBody = []AddressRequest

// UpsertAccessListForDatabaseJSONBody defines parameters for UpsertAccessListForDatabase.
type UpsertAccessListForDatabaseJSONBody = AccessListRequest

// ResetPasswordJSONBody defines parameters for ResetPassword.
type ResetPasswordJSONBody = UserPassword

// ResizeDatabaseJSONBody defines parameters for ResizeDatabase.
type ResizeDatabaseJSONBody = CapacityUnits

// TerminateDatabaseParams defines parameters for TerminateDatabase.
type TerminateDatabaseParams struct {
	// For internal use only. Used to safely terminate prepared databases.
	PreparedStateOnly *bool `form:"preparedStateOnly,omitempty" json:"preparedStateOnly,omitempty"`
}

// AddOrganizationRoleJSONBody defines parameters for AddOrganizationRole.
type AddOrganizationRoleJSONBody = CreateRoleRequest

// UpdateRoleJSONBody defines parameters for UpdateRole.
type UpdateRoleJSONBody = UpdateRoleRequest

// InviteUserToOrganizationJSONBody defines parameters for InviteUserToOrganization.
type InviteUserToOrganizationJSONBody = UserInvite

// UpdateRolesForUserInOrganizationJSONBody defines parameters for UpdateRolesForUserInOrganization.
type UpdateRolesForUserInOrganizationJSONBody = RoleInviteRequest

// IdOfTenantParams defines parameters for IdOfTenant.
type IdOfTenantParams struct {
	// Cloud provider. For example, aws, gcp, azure, or digital+ocean
	Provider *string `form:"provider,omitempty" json:"provider,omitempty"`

	// Cloud provider region. For example, us-east1, us-west1, toronto
	Region *string `form:"region,omitempty" json:"region,omitempty"`
}

// IdOfCreateTenantEndpointJSONBody defines parameters for IdOfCreateTenantEndpoint.
type IdOfCreateTenantEndpointJSONBody = TenantRequest

// IdOfCreateTenantEndpointParams defines parameters for IdOfCreateTenantEndpoint.
type IdOfCreateTenantEndpointParams struct {
	// A topic name for auto-creation (if not specified, no topic is created)
	Topic *string `form:"topic,omitempty" json:"topic,omitempty"`
}

// GetTeneantLimitUsageParams defines parameters for GetTeneantLimitUsage.
type GetTeneantLimitUsageParams struct {
	// Cloud provider, for example, aws, gcp, azure; this is required to evaluate whether a tenant has been reserved by its org owner
	Provider *string `form:"provider,omitempty" json:"provider,omitempty"`

	// Cloud provider region, for example, us-east1, us-west1; this is required to evaluate whether a tenant has been reserved by its org owner
	Region *string `form:"region,omitempty" json:"region,omitempty"`
}

// DeleteStreamingTenantParams defines parameters for DeleteStreamingTenant.
type DeleteStreamingTenantParams struct {
	// Performs a soft delete that only marks the tenant as deleted in the database (opt=soft)
	Opt *string `form:"opt,omitempty" json:"opt,omitempty"`
}

// IdListTenantTokensParams defines parameters for IdListTenantTokens.
type IdListTenantTokensParams struct {
	// Bearer Astra Keycloak token or AstraCS token.
	Authorization string `json:"Authorization"`

	// Astra Org ID.
	XDataStaxCurrentOrg string `json:"X-DataStax-Current-Org"`

	// Astra Streaming Cluster Name.
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
}

// GetTokenByIDParams defines parameters for GetTokenByID.
type GetTokenByIDParams struct {
	// Bearer Astra Keycloak token or AstraCS token.
	Authorization string `json:"Authorization"`

	// Astra Org ID.
	XDataStaxCurrentOrg string `json:"X-DataStax-Current-Org"`

	// Astra Streaming Cluster Name.
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
}

// DeleteCDCJSONRequestBody defines body for DeleteCDC for application/json ContentType.
type DeleteCDCJSONRequestBody = DeleteCDCJSONBody

// EnableCDCJSONRequestBody defines body for EnableCDC for application/json ContentType.
type EnableCDCJSONRequestBody = EnableCDCJSONBody

// CreateSinkJSONJSONRequestBody defines body for CreateSinkJSON for application/json ContentType.
type CreateSinkJSONJSONRequestBody = CreateSinkJSONJSONBody

// UpdateSinkJSONJSONRequestBody defines body for UpdateSinkJSON for application/json ContentType.
type UpdateSinkJSONJSONRequestBody = UpdateSinkJSONJSONBody

// CreateSourceJSONJSONRequestBody defines body for CreateSourceJSON for application/json ContentType.
type CreateSourceJSONJSONRequestBody = CreateSourceJSONJSONBody

// UpdateSourceJSONJSONRequestBody defines body for UpdateSourceJSON for application/json ContentType.
type UpdateSourceJSONJSONRequestBody = UpdateSourceJSONJSONBody

// GenerateTokenForClientJSONRequestBody defines body for GenerateTokenForClient for application/json ContentType.
type GenerateTokenForClientJSONRequestBody = GenerateTokenForClientJSONBody

// CreateDatabaseJSONRequestBody defines body for CreateDatabase for application/json ContentType.
type CreateDatabaseJSONRequestBody = CreateDatabaseJSONBody

// UpdateAccessListForDatabaseJSONRequestBody defines body for UpdateAccessListForDatabase for application/json ContentType.
type UpdateAccessListForDatabaseJSONRequestBody = UpdateAccessListForDatabaseJSONBody

// AddAddressesToAccessListForDatabaseJSONRequestBody defines body for AddAddressesToAccessListForDatabase for application/json ContentType.
type AddAddressesToAccessListForDatabaseJSONRequestBody = AddAddressesToAccessListForDatabaseJSONBody

// UpsertAccessListForDatabaseJSONRequestBody defines body for UpsertAccessListForDatabase for application/json ContentType.
type UpsertAccessListForDatabaseJSONRequestBody = UpsertAccessListForDatabaseJSONBody

// ResetPasswordJSONRequestBody defines body for ResetPassword for application/json ContentType.
type ResetPasswordJSONRequestBody = ResetPasswordJSONBody

// ResizeDatabaseJSONRequestBody defines body for ResizeDatabase for application/json ContentType.
type ResizeDatabaseJSONRequestBody = ResizeDatabaseJSONBody

// AddOrganizationRoleJSONRequestBody defines body for AddOrganizationRole for application/json ContentType.
type AddOrganizationRoleJSONRequestBody = AddOrganizationRoleJSONBody

// UpdateRoleJSONRequestBody defines body for UpdateRole for application/json ContentType.
type UpdateRoleJSONRequestBody = UpdateRoleJSONBody

// InviteUserToOrganizationJSONRequestBody defines body for InviteUserToOrganization for application/json ContentType.
type InviteUserToOrganizationJSONRequestBody = InviteUserToOrganizationJSONBody

// UpdateRolesForUserInOrganizationJSONRequestBody defines body for UpdateRolesForUserInOrganization for application/json ContentType.
type UpdateRolesForUserInOrganizationJSONRequestBody = UpdateRolesForUserInOrganizationJSONBody

// IdOfCreateTenantEndpointJSONRequestBody defines body for IdOfCreateTenantEndpoint for application/json ContentType.
type IdOfCreateTenantEndpointJSONRequestBody = IdOfCreateTenantEndpointJSONBody

// Getter for additional properties for BatchSourceConfig_DiscoveryTriggererConfig. Returns the specified
// element and whether it was found
func (a BatchSourceConfig_DiscoveryTriggererConfig) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for BatchSourceConfig_DiscoveryTriggererConfig
func (a *BatchSourceConfig_DiscoveryTriggererConfig) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for BatchSourceConfig_DiscoveryTriggererConfig to handle AdditionalProperties
func (a *BatchSourceConfig_DiscoveryTriggererConfig) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for BatchSourceConfig_DiscoveryTriggererConfig to handle AdditionalProperties
func (a BatchSourceConfig_DiscoveryTriggererConfig) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ConsumerConfig_ConsumerProperties. Returns the specified
// element and whether it was found
func (a ConsumerConfig_ConsumerProperties) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ConsumerConfig_ConsumerProperties
func (a *ConsumerConfig_ConsumerProperties) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ConsumerConfig_ConsumerProperties to handle AdditionalProperties
func (a *ConsumerConfig_ConsumerProperties) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ConsumerConfig_ConsumerProperties to handle AdditionalProperties
func (a ConsumerConfig_ConsumerProperties) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ConsumerConfig_SchemaProperties. Returns the specified
// element and whether it was found
func (a ConsumerConfig_SchemaProperties) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ConsumerConfig_SchemaProperties
func (a *ConsumerConfig_SchemaProperties) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ConsumerConfig_SchemaProperties to handle AdditionalProperties
func (a *ConsumerConfig_SchemaProperties) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ConsumerConfig_SchemaProperties to handle AdditionalProperties
func (a ConsumerConfig_SchemaProperties) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CryptoConfig_CryptoKeyReaderConfig. Returns the specified
// element and whether it was found
func (a CryptoConfig_CryptoKeyReaderConfig) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CryptoConfig_CryptoKeyReaderConfig
func (a *CryptoConfig_CryptoKeyReaderConfig) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CryptoConfig_CryptoKeyReaderConfig to handle AdditionalProperties
func (a *CryptoConfig_CryptoKeyReaderConfig) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CryptoConfig_CryptoKeyReaderConfig to handle AdditionalProperties
func (a CryptoConfig_CryptoKeyReaderConfig) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SinkConfig_InputSpecs. Returns the specified
// element and whether it was found
func (a SinkConfig_InputSpecs) Get(fieldName string) (value ConsumerConfig, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SinkConfig_InputSpecs
func (a *SinkConfig_InputSpecs) Set(fieldName string, value ConsumerConfig) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]ConsumerConfig)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SinkConfig_InputSpecs to handle AdditionalProperties
func (a *SinkConfig_InputSpecs) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]ConsumerConfig)
		for fieldName, fieldBuf := range object {
			var fieldVal ConsumerConfig
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SinkConfig_InputSpecs to handle AdditionalProperties
func (a SinkConfig_InputSpecs) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SinkConfig_Secrets. Returns the specified
// element and whether it was found
func (a SinkConfig_Secrets) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SinkConfig_Secrets
func (a *SinkConfig_Secrets) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SinkConfig_Secrets to handle AdditionalProperties
func (a *SinkConfig_Secrets) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SinkConfig_Secrets to handle AdditionalProperties
func (a SinkConfig_Secrets) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SinkConfig_TopicToSchemaProperties. Returns the specified
// element and whether it was found
func (a SinkConfig_TopicToSchemaProperties) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SinkConfig_TopicToSchemaProperties
func (a *SinkConfig_TopicToSchemaProperties) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SinkConfig_TopicToSchemaProperties to handle AdditionalProperties
func (a *SinkConfig_TopicToSchemaProperties) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SinkConfig_TopicToSchemaProperties to handle AdditionalProperties
func (a SinkConfig_TopicToSchemaProperties) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SinkConfig_TopicToSchemaType. Returns the specified
// element and whether it was found
func (a SinkConfig_TopicToSchemaType) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SinkConfig_TopicToSchemaType
func (a *SinkConfig_TopicToSchemaType) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SinkConfig_TopicToSchemaType to handle AdditionalProperties
func (a *SinkConfig_TopicToSchemaType) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SinkConfig_TopicToSchemaType to handle AdditionalProperties
func (a SinkConfig_TopicToSchemaType) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SinkConfig_TopicToSerdeClassName. Returns the specified
// element and whether it was found
func (a SinkConfig_TopicToSerdeClassName) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SinkConfig_TopicToSerdeClassName
func (a *SinkConfig_TopicToSerdeClassName) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SinkConfig_TopicToSerdeClassName to handle AdditionalProperties
func (a *SinkConfig_TopicToSerdeClassName) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SinkConfig_TopicToSerdeClassName to handle AdditionalProperties
func (a SinkConfig_TopicToSerdeClassName) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SourceConfig_Configs. Returns the specified
// element and whether it was found
func (a SourceConfig_Configs) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SourceConfig_Configs
func (a *SourceConfig_Configs) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SourceConfig_Configs to handle AdditionalProperties
func (a *SourceConfig_Configs) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SourceConfig_Configs to handle AdditionalProperties
func (a SourceConfig_Configs) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SourceConfig_Secrets. Returns the specified
// element and whether it was found
func (a SourceConfig_Secrets) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SourceConfig_Secrets
func (a *SourceConfig_Secrets) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SourceConfig_Secrets to handle AdditionalProperties
func (a *SourceConfig_Secrets) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SourceConfig_Secrets to handle AdditionalProperties
func (a SourceConfig_Secrets) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ProviderRegionsResponse_Body. Returns the specified
// element and whether it was found
func (a ProviderRegionsResponse_Body) Get(fieldName string) (value []string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProviderRegionsResponse_Body
func (a *ProviderRegionsResponse_Body) Set(fieldName string, value []string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProviderRegionsResponse_Body to handle AdditionalProperties
func (a *ProviderRegionsResponse_Body) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]string)
		for fieldName, fieldBuf := range object {
			var fieldVal []string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProviderRegionsResponse_Body to handle AdditionalProperties
func (a ProviderRegionsResponse_Body) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for StatsResponse_Body. Returns the specified
// element and whether it was found
func (a StatsResponse_Body) Get(fieldName string) (value Usage, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for StatsResponse_Body
func (a *StatsResponse_Body) Set(fieldName string, value Usage) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Usage)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for StatsResponse_Body to handle AdditionalProperties
func (a *StatsResponse_Body) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Usage)
		for fieldName, fieldBuf := range object {
			var fieldVal Usage
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for StatsResponse_Body to handle AdditionalProperties
func (a StatsResponse_Body) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetTenants request
	GetTenants(ctx context.Context, tenant string, namespace string, params *GetTenantsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTopic request
	DeleteTopic(ctx context.Context, tenant string, namespace string, topic string, params *DeleteTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTopic request
	CreateTopic(ctx context.Context, tenant string, namespace string, topic string, params *CreateTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IdNamespaceStatsTenant request
	IdNamespaceStatsTenant(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IdNamespaceStatsTenantNamespace request
	IdNamespaceStatsTenantNamespace(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IdTopicStatsTenant request
	IdTopicStatsTenant(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IdTopicStatsTenantNamespace request
	IdTopicStatsTenantNamespace(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCDC request with any body
	DeleteCDCWithBody(ctx context.Context, tenantName string, params *DeleteCDCParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteCDC(ctx context.Context, tenantName string, params *DeleteCDCParams, body DeleteCDCJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCDC request
	GetCDC(ctx context.Context, tenantName string, params *GetCDCParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnableCDC request with any body
	EnableCDCWithBody(ctx context.Context, tenantName string, params *EnableCDCParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EnableCDC(ctx context.Context, tenantName string, params *EnableCDCParams, body EnableCDCJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSink request
	DeleteSink(ctx context.Context, tenant string, namespace string, sinkName string, params *DeleteSinkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSinks request
	GetSinks(ctx context.Context, tenant string, namespace string, sinkName string, params *GetSinksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSinkJSON request with any body
	CreateSinkJSONWithBody(ctx context.Context, tenant string, namespace string, sinkName string, params *CreateSinkJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSinkJSON(ctx context.Context, tenant string, namespace string, sinkName string, params *CreateSinkJSONParams, body CreateSinkJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSinkJSON request with any body
	UpdateSinkJSONWithBody(ctx context.Context, tenant string, namespace string, sinkName string, params *UpdateSinkJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSinkJSON(ctx context.Context, tenant string, namespace string, sinkName string, params *UpdateSinkJSONParams, body UpdateSinkJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSourceJSON request with any body
	CreateSourceJSONWithBody(ctx context.Context, tenant string, namespace string, sourceName string, params *CreateSourceJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSourceJSON(ctx context.Context, tenant string, namespace string, sourceName string, params *CreateSourceJSONParams, body CreateSourceJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSourceJSON request with any body
	UpdateSourceJSONWithBody(ctx context.Context, tenant string, namespace string, sourceName string, params *UpdateSourceJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSourceJSON(ctx context.Context, tenant string, namespace string, sourceName string, params *UpdateSourceJSONParams, body UpdateSourceJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBuiltInSinks request
	GetBuiltInSinks(ctx context.Context, params *GetBuiltInSinksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccessListTemplate request
	GetAccessListTemplate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateAccessList request
	ValidateAccessList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllAccessListsForOrganization request
	GetAllAccessListsForOrganization(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAvailableRegions request
	ListAvailableRegions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTokenForClient request
	DeleteTokenForClient(ctx context.Context, clientId ClientIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientsForOrg request
	GetClientsForOrg(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateTokenForClient request with any body
	GenerateTokenForClientWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateTokenForClient(ctx context.Context, body GenerateTokenForClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentOrganization request
	GetCurrentOrganization(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDatabases request
	ListDatabases(ctx context.Context, params *ListDatabasesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDatabase request with any body
	CreateDatabaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDatabase(ctx context.Context, body CreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatabase request
	GetDatabase(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAddressesOrAccessListForDatabase request
	DeleteAddressesOrAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, params *DeleteAddressesOrAccessListForDatabaseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccessListForDatabase request
	GetAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAccessListForDatabase request with any body
	UpdateAccessListForDatabaseWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, body UpdateAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddAddressesToAccessListForDatabase request with any body
	AddAddressesToAccessListForDatabaseWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddAddressesToAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, body AddAddressesToAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertAccessListForDatabase request with any body
	UpsertAccessListForDatabaseWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, body UpsertAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddKeyspace request
	AddKeyspace(ctx context.Context, databaseId DatabaseIdParam, keyspaceName KeyspaceNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ParkDatabase request
	ParkDatabase(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetPassword request with any body
	ResetPasswordWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResetPassword(ctx context.Context, databaseId DatabaseIdParam, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResizeDatabase request with any body
	ResizeDatabaseWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResizeDatabase(ctx context.Context, databaseId DatabaseIdParam, body ResizeDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateSecureBundleURL request
	GenerateSecureBundleURL(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TerminateDatabase request
	TerminateDatabase(ctx context.Context, databaseId DatabaseIdParam, params *TerminateDatabaseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnparkDatabase request
	UnparkDatabase(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationRoles request
	GetOrganizationRoles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddOrganizationRole request with any body
	AddOrganizationRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddOrganizationRole(ctx context.Context, body AddOrganizationRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOrganizationRole request
	DeleteOrganizationRole(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationRole request
	GetOrganizationRole(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRole request with any body
	UpdateRoleWithBody(ctx context.Context, roleID RoleIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRole(ctx context.Context, roleID RoleIdParam, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationUsers request
	GetOrganizationUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InviteUserToOrganization request with any body
	InviteUserToOrganizationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InviteUserToOrganization(ctx context.Context, body InviteUserToOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveUserFromOrganization request
	RemoveUserFromOrganization(ctx context.Context, userID UserIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationUser request
	GetOrganizationUser(ctx context.Context, userID UserIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRolesForUserInOrganization request with any body
	UpdateRolesForUserInOrganizationWithBody(ctx context.Context, userID UserIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRolesForUserInOrganization(ctx context.Context, userID UserIdParam, body UpdateRolesForUserInOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IdOfTenant request
	IdOfTenant(ctx context.Context, params *IdOfTenantParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPulsarClusters request
	GetPulsarClusters(ctx context.Context, org string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamingTenant request
	GetStreamingTenant(ctx context.Context, org string, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamingProviders request
	GetStreamingProviders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTenants request
	GetTenants(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IdOfCreateTenantEndpoint request with any body
	IdOfCreateTenantEndpointWithBody(ctx context.Context, params *IdOfCreateTenantEndpointParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IdOfCreateTenantEndpoint(ctx context.Context, params *IdOfCreateTenantEndpointParams, body IdOfCreateTenantEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeneantLimitUsage request
	GetTeneantLimitUsage(ctx context.Context, tenantName string, params *GetTeneantLimitUsageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStreamingTenant request
	DeleteStreamingTenant(ctx context.Context, tenant string, cluster string, params *DeleteStreamingTenantParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLimits request
	GetLimits(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IdListTenantTokens request
	IdListTenantTokens(ctx context.Context, tenant string, params *IdListTenantTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTokenByID request
	GetTokenByID(ctx context.Context, tenant string, tokenId string, params *GetTokenByIDParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetTenants(ctx context.Context, tenant string, namespace string, params *GetTenantsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTenantsRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTopic(ctx context.Context, tenant string, namespace string, topic string, params *DeleteTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTopic(ctx context.Context, tenant string, namespace string, topic string, params *CreateTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IdNamespaceStatsTenant(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIdNamespaceStatsTenantRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IdNamespaceStatsTenantNamespace(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIdNamespaceStatsTenantNamespaceRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IdTopicStatsTenant(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIdTopicStatsTenantRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IdTopicStatsTenantNamespace(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIdTopicStatsTenantNamespaceRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCDCWithBody(ctx context.Context, tenantName string, params *DeleteCDCParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCDCRequestWithBody(c.Server, tenantName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCDC(ctx context.Context, tenantName string, params *DeleteCDCParams, body DeleteCDCJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCDCRequest(c.Server, tenantName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCDC(ctx context.Context, tenantName string, params *GetCDCParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCDCRequest(c.Server, tenantName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableCDCWithBody(ctx context.Context, tenantName string, params *EnableCDCParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableCDCRequestWithBody(c.Server, tenantName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableCDC(ctx context.Context, tenantName string, params *EnableCDCParams, body EnableCDCJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableCDCRequest(c.Server, tenantName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSink(ctx context.Context, tenant string, namespace string, sinkName string, params *DeleteSinkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSinkRequest(c.Server, tenant, namespace, sinkName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSinks(ctx context.Context, tenant string, namespace string, sinkName string, params *GetSinksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSinksRequest(c.Server, tenant, namespace, sinkName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSinkJSONWithBody(ctx context.Context, tenant string, namespace string, sinkName string, params *CreateSinkJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSinkJSONRequestWithBody(c.Server, tenant, namespace, sinkName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSinkJSON(ctx context.Context, tenant string, namespace string, sinkName string, params *CreateSinkJSONParams, body CreateSinkJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSinkJSONRequest(c.Server, tenant, namespace, sinkName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSinkJSONWithBody(ctx context.Context, tenant string, namespace string, sinkName string, params *UpdateSinkJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSinkJSONRequestWithBody(c.Server, tenant, namespace, sinkName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSinkJSON(ctx context.Context, tenant string, namespace string, sinkName string, params *UpdateSinkJSONParams, body UpdateSinkJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSinkJSONRequest(c.Server, tenant, namespace, sinkName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSourceJSONWithBody(ctx context.Context, tenant string, namespace string, sourceName string, params *CreateSourceJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSourceJSONRequestWithBody(c.Server, tenant, namespace, sourceName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSourceJSON(ctx context.Context, tenant string, namespace string, sourceName string, params *CreateSourceJSONParams, body CreateSourceJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSourceJSONRequest(c.Server, tenant, namespace, sourceName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSourceJSONWithBody(ctx context.Context, tenant string, namespace string, sourceName string, params *UpdateSourceJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSourceJSONRequestWithBody(c.Server, tenant, namespace, sourceName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSourceJSON(ctx context.Context, tenant string, namespace string, sourceName string, params *UpdateSourceJSONParams, body UpdateSourceJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSourceJSONRequest(c.Server, tenant, namespace, sourceName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBuiltInSinks(ctx context.Context, params *GetBuiltInSinksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBuiltInSinksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccessListTemplate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccessListTemplateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateAccessList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateAccessListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllAccessListsForOrganization(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllAccessListsForOrganizationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAvailableRegions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAvailableRegionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTokenForClient(ctx context.Context, clientId ClientIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTokenForClientRequest(c.Server, clientId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientsForOrg(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientsForOrgRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateTokenForClientWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateTokenForClientRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateTokenForClient(ctx context.Context, body GenerateTokenForClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateTokenForClientRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentOrganization(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentOrganizationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDatabases(ctx context.Context, params *ListDatabasesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDatabasesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabase(ctx context.Context, body CreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatabase(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatabaseRequest(c.Server, databaseId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAddressesOrAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, params *DeleteAddressesOrAccessListForDatabaseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAddressesOrAccessListForDatabaseRequest(c.Server, databaseId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccessListForDatabaseRequest(c.Server, databaseId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccessListForDatabaseWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccessListForDatabaseRequestWithBody(c.Server, databaseId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, body UpdateAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccessListForDatabaseRequest(c.Server, databaseId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddAddressesToAccessListForDatabaseWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddAddressesToAccessListForDatabaseRequestWithBody(c.Server, databaseId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddAddressesToAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, body AddAddressesToAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddAddressesToAccessListForDatabaseRequest(c.Server, databaseId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertAccessListForDatabaseWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertAccessListForDatabaseRequestWithBody(c.Server, databaseId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, body UpsertAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertAccessListForDatabaseRequest(c.Server, databaseId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddKeyspace(ctx context.Context, databaseId DatabaseIdParam, keyspaceName KeyspaceNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddKeyspaceRequest(c.Server, databaseId, keyspaceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ParkDatabase(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewParkDatabaseRequest(c.Server, databaseId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPasswordWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPasswordRequestWithBody(c.Server, databaseId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPassword(ctx context.Context, databaseId DatabaseIdParam, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPasswordRequest(c.Server, databaseId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResizeDatabaseWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResizeDatabaseRequestWithBody(c.Server, databaseId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResizeDatabase(ctx context.Context, databaseId DatabaseIdParam, body ResizeDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResizeDatabaseRequest(c.Server, databaseId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateSecureBundleURL(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateSecureBundleURLRequest(c.Server, databaseId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TerminateDatabase(ctx context.Context, databaseId DatabaseIdParam, params *TerminateDatabaseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTerminateDatabaseRequest(c.Server, databaseId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnparkDatabase(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnparkDatabaseRequest(c.Server, databaseId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationRoles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationRolesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrganizationRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrganizationRoleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrganizationRole(ctx context.Context, body AddOrganizationRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrganizationRoleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOrganizationRole(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOrganizationRoleRequest(c.Server, roleID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationRole(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationRoleRequest(c.Server, roleID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRoleWithBody(ctx context.Context, roleID RoleIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleRequestWithBody(c.Server, roleID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRole(ctx context.Context, roleID RoleIdParam, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleRequest(c.Server, roleID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationUsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteUserToOrganizationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteUserToOrganizationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteUserToOrganization(ctx context.Context, body InviteUserToOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteUserToOrganizationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUserFromOrganization(ctx context.Context, userID UserIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUserFromOrganizationRequest(c.Server, userID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationUser(ctx context.Context, userID UserIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationUserRequest(c.Server, userID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRolesForUserInOrganizationWithBody(ctx context.Context, userID UserIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRolesForUserInOrganizationRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRolesForUserInOrganization(ctx context.Context, userID UserIdParam, body UpdateRolesForUserInOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRolesForUserInOrganizationRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IdOfTenant(ctx context.Context, params *IdOfTenantParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIdOfTenantRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPulsarClusters(ctx context.Context, org string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPulsarClustersRequest(c.Server, org)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamingTenant(ctx context.Context, org string, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamingTenantRequest(c.Server, org, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamingProviders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamingProvidersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTenants(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTenantsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IdOfCreateTenantEndpointWithBody(ctx context.Context, params *IdOfCreateTenantEndpointParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIdOfCreateTenantEndpointRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IdOfCreateTenantEndpoint(ctx context.Context, params *IdOfCreateTenantEndpointParams, body IdOfCreateTenantEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIdOfCreateTenantEndpointRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeneantLimitUsage(ctx context.Context, tenantName string, params *GetTeneantLimitUsageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeneantLimitUsageRequest(c.Server, tenantName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStreamingTenant(ctx context.Context, tenant string, cluster string, params *DeleteStreamingTenantParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStreamingTenantRequest(c.Server, tenant, cluster, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLimits(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLimitsRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IdListTenantTokens(ctx context.Context, tenant string, params *IdListTenantTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIdListTenantTokensRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTokenByID(ctx context.Context, tenant string, tokenId string, params *GetTokenByIDParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTokenByIDRequest(c.Server, tenant, tokenId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetTenantsRequest generates requests for GetTenants
func NewGetTenantsRequest(server string, tenant string, namespace string, params *GetTenantsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v2/non-persistent/%s/%s/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam0)

	if params.XDataStaxPulsarCluster != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, *params.XDataStaxPulsarCluster)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam1)
	}

	return req, nil
}

// NewDeleteTopicRequest generates requests for DeleteTopic
func NewDeleteTopicRequest(server string, tenant string, namespace string, topic string, params *DeleteTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v2/non-persistent/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XDataStaxCurrentOrg != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Current-Org", runtime.ParamLocationHeader, *params.XDataStaxCurrentOrg)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Current-Org", headerParam0)
	}

	var headerParam1 string

	headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam1)

	var headerParam2 string

	headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam2)

	return req, nil
}

// NewCreateTopicRequest generates requests for CreateTopic
func NewCreateTopicRequest(server string, tenant string, namespace string, topic string, params *CreateTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v2/non-persistent/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XDataStaxCurrentOrg != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Current-Org", runtime.ParamLocationHeader, *params.XDataStaxCurrentOrg)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Current-Org", headerParam0)
	}

	var headerParam1 string

	headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam1)

	var headerParam2 string

	headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam2)

	return req, nil
}

// NewIdNamespaceStatsTenantRequest generates requests for IdNamespaceStatsTenant
func NewIdNamespaceStatsTenantRequest(server string, tenant string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v2/stats/namespaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIdNamespaceStatsTenantNamespaceRequest generates requests for IdNamespaceStatsTenantNamespace
func NewIdNamespaceStatsTenantNamespaceRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v2/stats/namespaces/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIdTopicStatsTenantRequest generates requests for IdTopicStatsTenant
func NewIdTopicStatsTenantRequest(server string, tenant string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v2/stats/topics/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIdTopicStatsTenantNamespaceRequest generates requests for IdTopicStatsTenantNamespace
func NewIdTopicStatsTenantNamespaceRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v2/stats/topics/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCDCRequest calls the generic DeleteCDC builder with application/json body
func NewDeleteCDCRequest(server string, tenantName string, params *DeleteCDCParams, body DeleteCDCJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteCDCRequestWithBody(server, tenantName, params, "application/json", bodyReader)
}

// NewDeleteCDCRequestWithBody generates requests for DeleteCDC with any type of body
func NewDeleteCDCRequestWithBody(server string, tenantName string, params *DeleteCDCParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantName", runtime.ParamLocationPath, tenantName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v3/astra/tenants/%s/cdc", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam0)

	var headerParam1 string

	headerParam1, err = runtime.StyleParamWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("authorization", headerParam1)

	return req, nil
}

// NewGetCDCRequest generates requests for GetCDC
func NewGetCDCRequest(server string, tenantName string, params *GetCDCParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantName", runtime.ParamLocationPath, tenantName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v3/astra/tenants/%s/cdc", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam0)

	var headerParam1 string

	headerParam1, err = runtime.StyleParamWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("authorization", headerParam1)

	return req, nil
}

// NewEnableCDCRequest calls the generic EnableCDC builder with application/json body
func NewEnableCDCRequest(server string, tenantName string, params *EnableCDCParams, body EnableCDCJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEnableCDCRequestWithBody(server, tenantName, params, "application/json", bodyReader)
}

// NewEnableCDCRequestWithBody generates requests for EnableCDC with any type of body
func NewEnableCDCRequestWithBody(server string, tenantName string, params *EnableCDCParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantName", runtime.ParamLocationPath, tenantName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v3/astra/tenants/%s/cdc", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam0)

	var headerParam1 string

	headerParam1, err = runtime.StyleParamWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("authorization", headerParam1)

	return req, nil
}

// NewDeleteSinkRequest generates requests for DeleteSink
func NewDeleteSinkRequest(server string, tenant string, namespace string, sinkName string, params *DeleteSinkParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "sinkName", runtime.ParamLocationPath, sinkName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v3/astrasinks/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Current-Org", runtime.ParamLocationHeader, params.XDataStaxCurrentOrg)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-DataStax-Current-Org", headerParam0)

	var headerParam1 string

	headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam1)

	var headerParam2 string

	headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam2)

	return req, nil
}

// NewGetSinksRequest generates requests for GetSinks
func NewGetSinksRequest(server string, tenant string, namespace string, sinkName string, params *GetSinksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "sinkName", runtime.ParamLocationPath, sinkName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v3/astrasinks/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam0)

	var headerParam1 string

	headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam1)

	return req, nil
}

// NewCreateSinkJSONRequest calls the generic CreateSinkJSON builder with application/json body
func NewCreateSinkJSONRequest(server string, tenant string, namespace string, sinkName string, params *CreateSinkJSONParams, body CreateSinkJSONJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSinkJSONRequestWithBody(server, tenant, namespace, sinkName, params, "application/json", bodyReader)
}

// NewCreateSinkJSONRequestWithBody generates requests for CreateSinkJSON with any type of body
func NewCreateSinkJSONRequestWithBody(server string, tenant string, namespace string, sinkName string, params *CreateSinkJSONParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "sinkName", runtime.ParamLocationPath, sinkName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v3/astrasinks/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam0)

	var headerParam1 string

	headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Current-Org", runtime.ParamLocationHeader, params.XDataStaxCurrentOrg)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-DataStax-Current-Org", headerParam1)

	var headerParam2 string

	headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam2)

	return req, nil
}

// NewUpdateSinkJSONRequest calls the generic UpdateSinkJSON builder with application/json body
func NewUpdateSinkJSONRequest(server string, tenant string, namespace string, sinkName string, params *UpdateSinkJSONParams, body UpdateSinkJSONJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSinkJSONRequestWithBody(server, tenant, namespace, sinkName, params, "application/json", bodyReader)
}

// NewUpdateSinkJSONRequestWithBody generates requests for UpdateSinkJSON with any type of body
func NewUpdateSinkJSONRequestWithBody(server string, tenant string, namespace string, sinkName string, params *UpdateSinkJSONParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "sinkName", runtime.ParamLocationPath, sinkName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v3/astrasinks/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam0)

	var headerParam1 string

	headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Current-Org", runtime.ParamLocationHeader, params.XDataStaxCurrentOrg)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-DataStax-Current-Org", headerParam1)

	var headerParam2 string

	headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam2)

	return req, nil
}

// NewCreateSourceJSONRequest calls the generic CreateSourceJSON builder with application/json body
func NewCreateSourceJSONRequest(server string, tenant string, namespace string, sourceName string, params *CreateSourceJSONParams, body CreateSourceJSONJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSourceJSONRequestWithBody(server, tenant, namespace, sourceName, params, "application/json", bodyReader)
}

// NewCreateSourceJSONRequestWithBody generates requests for CreateSourceJSON with any type of body
func NewCreateSourceJSONRequestWithBody(server string, tenant string, namespace string, sourceName string, params *CreateSourceJSONParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "sourceName", runtime.ParamLocationPath, sourceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v3/astrasources/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam0)

	var headerParam1 string

	headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Current-Org", runtime.ParamLocationHeader, params.XDataStaxCurrentOrg)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-DataStax-Current-Org", headerParam1)

	var headerParam2 string

	headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam2)

	return req, nil
}

// NewUpdateSourceJSONRequest calls the generic UpdateSourceJSON builder with application/json body
func NewUpdateSourceJSONRequest(server string, tenant string, namespace string, sourceName string, params *UpdateSourceJSONParams, body UpdateSourceJSONJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSourceJSONRequestWithBody(server, tenant, namespace, sourceName, params, "application/json", bodyReader)
}

// NewUpdateSourceJSONRequestWithBody generates requests for UpdateSourceJSON with any type of body
func NewUpdateSourceJSONRequestWithBody(server string, tenant string, namespace string, sourceName string, params *UpdateSourceJSONParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "sourceName", runtime.ParamLocationPath, sourceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v3/astrasources/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam0)

	var headerParam1 string

	headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Current-Org", runtime.ParamLocationHeader, params.XDataStaxCurrentOrg)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-DataStax-Current-Org", headerParam1)

	var headerParam2 string

	headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam2)

	return req, nil
}

// NewGetBuiltInSinksRequest generates requests for GetBuiltInSinks
func NewGetBuiltInSinksRequest(server string, params *GetBuiltInSinksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v3/sinks/builtinsinks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam0)

	var headerParam1 string

	headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam1)

	return req, nil
}

// NewGetAccessListTemplateRequest generates requests for GetAccessListTemplate
func NewGetAccessListTemplateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/access-list/template")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewValidateAccessListRequest generates requests for ValidateAccessList
func NewValidateAccessListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/access-list/validate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllAccessListsForOrganizationRequest generates requests for GetAllAccessListsForOrganization
func NewGetAllAccessListsForOrganizationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/access-lists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAvailableRegionsRequest generates requests for ListAvailableRegions
func NewListAvailableRegionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/availableRegions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteTokenForClientRequest generates requests for DeleteTokenForClient
func NewDeleteTokenForClientRequest(server string, clientId ClientIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/clientIdSecret/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClientsForOrgRequest generates requests for GetClientsForOrg
func NewGetClientsForOrgRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/clientIdSecrets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateTokenForClientRequest calls the generic GenerateTokenForClient builder with application/json body
func NewGenerateTokenForClientRequest(server string, body GenerateTokenForClientJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateTokenForClientRequestWithBody(server, "application/json", bodyReader)
}

// NewGenerateTokenForClientRequestWithBody generates requests for GenerateTokenForClient with any type of body
func NewGenerateTokenForClientRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/clientIdSecrets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCurrentOrganizationRequest generates requests for GetCurrentOrganization
func NewGetCurrentOrganizationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/currentOrg")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDatabasesRequest generates requests for ListDatabases
func NewListDatabasesRequest(server string, params *ListDatabasesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Provider != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "provider", runtime.ParamLocationQuery, *params.Provider); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartingAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDatabaseRequest calls the generic CreateDatabase builder with application/json body
func NewCreateDatabaseRequest(server string, body CreateDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDatabaseRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDatabaseRequestWithBody generates requests for CreateDatabase with any type of body
func NewCreateDatabaseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDatabaseRequest generates requests for GetDatabase
func NewGetDatabaseRequest(server string, databaseId DatabaseIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteAddressesOrAccessListForDatabaseRequest generates requests for DeleteAddressesOrAccessListForDatabase
func NewDeleteAddressesOrAccessListForDatabaseRequest(server string, databaseId DatabaseIdParam, params *DeleteAddressesOrAccessListForDatabaseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/access-list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Addresses != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addresses", runtime.ParamLocationQuery, *params.Addresses); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAccessListForDatabaseRequest generates requests for GetAccessListForDatabase
func NewGetAccessListForDatabaseRequest(server string, databaseId DatabaseIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/access-list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAccessListForDatabaseRequest calls the generic UpdateAccessListForDatabase builder with application/json body
func NewUpdateAccessListForDatabaseRequest(server string, databaseId DatabaseIdParam, body UpdateAccessListForDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAccessListForDatabaseRequestWithBody(server, databaseId, "application/json", bodyReader)
}

// NewUpdateAccessListForDatabaseRequestWithBody generates requests for UpdateAccessListForDatabase with any type of body
func NewUpdateAccessListForDatabaseRequestWithBody(server string, databaseId DatabaseIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/access-list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddAddressesToAccessListForDatabaseRequest calls the generic AddAddressesToAccessListForDatabase builder with application/json body
func NewAddAddressesToAccessListForDatabaseRequest(server string, databaseId DatabaseIdParam, body AddAddressesToAccessListForDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddAddressesToAccessListForDatabaseRequestWithBody(server, databaseId, "application/json", bodyReader)
}

// NewAddAddressesToAccessListForDatabaseRequestWithBody generates requests for AddAddressesToAccessListForDatabase with any type of body
func NewAddAddressesToAccessListForDatabaseRequestWithBody(server string, databaseId DatabaseIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/access-list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpsertAccessListForDatabaseRequest calls the generic UpsertAccessListForDatabase builder with application/json body
func NewUpsertAccessListForDatabaseRequest(server string, databaseId DatabaseIdParam, body UpsertAccessListForDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertAccessListForDatabaseRequestWithBody(server, databaseId, "application/json", bodyReader)
}

// NewUpsertAccessListForDatabaseRequestWithBody generates requests for UpsertAccessListForDatabase with any type of body
func NewUpsertAccessListForDatabaseRequestWithBody(server string, databaseId DatabaseIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/access-list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddKeyspaceRequest generates requests for AddKeyspace
func NewAddKeyspaceRequest(server string, databaseId DatabaseIdParam, keyspaceName KeyspaceNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "keyspaceName", runtime.ParamLocationPath, keyspaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/keyspaces/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewParkDatabaseRequest generates requests for ParkDatabase
func NewParkDatabaseRequest(server string, databaseId DatabaseIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/park", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResetPasswordRequest calls the generic ResetPassword builder with application/json body
func NewResetPasswordRequest(server string, databaseId DatabaseIdParam, body ResetPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResetPasswordRequestWithBody(server, databaseId, "application/json", bodyReader)
}

// NewResetPasswordRequestWithBody generates requests for ResetPassword with any type of body
func NewResetPasswordRequestWithBody(server string, databaseId DatabaseIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/resetPassword", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResizeDatabaseRequest calls the generic ResizeDatabase builder with application/json body
func NewResizeDatabaseRequest(server string, databaseId DatabaseIdParam, body ResizeDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResizeDatabaseRequestWithBody(server, databaseId, "application/json", bodyReader)
}

// NewResizeDatabaseRequestWithBody generates requests for ResizeDatabase with any type of body
func NewResizeDatabaseRequestWithBody(server string, databaseId DatabaseIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/resize", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenerateSecureBundleURLRequest generates requests for GenerateSecureBundleURL
func NewGenerateSecureBundleURLRequest(server string, databaseId DatabaseIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/secureBundleURL", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTerminateDatabaseRequest generates requests for TerminateDatabase
func NewTerminateDatabaseRequest(server string, databaseId DatabaseIdParam, params *TerminateDatabaseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/terminate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PreparedStateOnly != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preparedStateOnly", runtime.ParamLocationQuery, *params.PreparedStateOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnparkDatabaseRequest generates requests for UnparkDatabase
func NewUnparkDatabaseRequest(server string, databaseId DatabaseIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/unpark", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationRolesRequest generates requests for GetOrganizationRoles
func NewGetOrganizationRolesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddOrganizationRoleRequest calls the generic AddOrganizationRole builder with application/json body
func NewAddOrganizationRoleRequest(server string, body AddOrganizationRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddOrganizationRoleRequestWithBody(server, "application/json", bodyReader)
}

// NewAddOrganizationRoleRequestWithBody generates requests for AddOrganizationRole with any type of body
func NewAddOrganizationRoleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOrganizationRoleRequest generates requests for DeleteOrganizationRole
func NewDeleteOrganizationRoleRequest(server string, roleID RoleIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleID", runtime.ParamLocationPath, roleID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationRoleRequest generates requests for GetOrganizationRole
func NewGetOrganizationRoleRequest(server string, roleID RoleIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleID", runtime.ParamLocationPath, roleID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRoleRequest calls the generic UpdateRole builder with application/json body
func NewUpdateRoleRequest(server string, roleID RoleIdParam, body UpdateRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRoleRequestWithBody(server, roleID, "application/json", bodyReader)
}

// NewUpdateRoleRequestWithBody generates requests for UpdateRole with any type of body
func NewUpdateRoleRequestWithBody(server string, roleID RoleIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleID", runtime.ParamLocationPath, roleID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOrganizationUsersRequest generates requests for GetOrganizationUsers
func NewGetOrganizationUsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInviteUserToOrganizationRequest calls the generic InviteUserToOrganization builder with application/json body
func NewInviteUserToOrganizationRequest(server string, body InviteUserToOrganizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInviteUserToOrganizationRequestWithBody(server, "application/json", bodyReader)
}

// NewInviteUserToOrganizationRequestWithBody generates requests for InviteUserToOrganization with any type of body
func NewInviteUserToOrganizationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveUserFromOrganizationRequest generates requests for RemoveUserFromOrganization
func NewRemoveUserFromOrganizationRequest(server string, userID UserIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationUserRequest generates requests for GetOrganizationUser
func NewGetOrganizationUserRequest(server string, userID UserIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRolesForUserInOrganizationRequest calls the generic UpdateRolesForUserInOrganization builder with application/json body
func NewUpdateRolesForUserInOrganizationRequest(server string, userID UserIdParam, body UpdateRolesForUserInOrganizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRolesForUserInOrganizationRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewUpdateRolesForUserInOrganizationRequestWithBody generates requests for UpdateRolesForUserInOrganization with any type of body
func NewUpdateRolesForUserInOrganizationRequestWithBody(server string, userID UserIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/users/%s/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIdOfTenantRequest generates requests for IdOfTenant
func NewIdOfTenantRequest(server string, params *IdOfTenantParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/streaming/clusters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Provider != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "provider", runtime.ParamLocationQuery, *params.Provider); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Region != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPulsarClustersRequest generates requests for GetPulsarClusters
func NewGetPulsarClustersRequest(server string, org string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/streaming/orgs/%s/tenants", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamingTenantRequest generates requests for GetStreamingTenant
func NewGetStreamingTenantRequest(server string, org string, tenant string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/streaming/orgs/%s/tenants/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamingProvidersRequest generates requests for GetStreamingProviders
func NewGetStreamingProvidersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/streaming/providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTenantsRequest generates requests for GetTenants
func NewGetTenantsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/streaming/tenants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIdOfCreateTenantEndpointRequest calls the generic IdOfCreateTenantEndpoint builder with application/json body
func NewIdOfCreateTenantEndpointRequest(server string, params *IdOfCreateTenantEndpointParams, body IdOfCreateTenantEndpointJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIdOfCreateTenantEndpointRequestWithBody(server, params, "application/json", bodyReader)
}

// NewIdOfCreateTenantEndpointRequestWithBody generates requests for IdOfCreateTenantEndpoint with any type of body
func NewIdOfCreateTenantEndpointRequestWithBody(server string, params *IdOfCreateTenantEndpointParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/streaming/tenants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Topic != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "topic", runtime.ParamLocationQuery, *params.Topic); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTeneantLimitUsageRequest generates requests for GetTeneantLimitUsage
func NewGetTeneantLimitUsageRequest(server string, tenantName string, params *GetTeneantLimitUsageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantName", runtime.ParamLocationPath, tenantName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/streaming/tenants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Provider != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "provider", runtime.ParamLocationQuery, *params.Provider); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Region != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteStreamingTenantRequest generates requests for DeleteStreamingTenant
func NewDeleteStreamingTenantRequest(server string, tenant string, cluster string, params *DeleteStreamingTenantParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/streaming/tenants/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Opt != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "opt", runtime.ParamLocationQuery, *params.Opt); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLimitsRequest generates requests for GetLimits
func NewGetLimitsRequest(server string, tenant string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/streaming/tenants/%s/limits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIdListTenantTokensRequest generates requests for IdListTenantTokens
func NewIdListTenantTokensRequest(server string, tenant string, params *IdListTenantTokensParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/streaming/tenants/%s/tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam0)

	var headerParam1 string

	headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Current-Org", runtime.ParamLocationHeader, params.XDataStaxCurrentOrg)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-DataStax-Current-Org", headerParam1)

	var headerParam2 string

	headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam2)

	return req, nil
}

// NewGetTokenByIDRequest generates requests for GetTokenByID
func NewGetTokenByIDRequest(server string, tenant string, tokenId string, params *GetTokenByIDParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenId", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/streaming/tenants/%s/tokens/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam0)

	var headerParam1 string

	headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Current-Org", runtime.ParamLocationHeader, params.XDataStaxCurrentOrg)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-DataStax-Current-Org", headerParam1)

	var headerParam2 string

	headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam2)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetTenants request
	GetTenantsWithResponse(ctx context.Context, tenant string, namespace string, params *GetTenantsParams, reqEditors ...RequestEditorFn) (*GetTenantsResponse, error)

	// DeleteTopic request
	DeleteTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteTopicParams, reqEditors ...RequestEditorFn) (*DeleteTopicResponse, error)

	// CreateTopic request
	CreateTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CreateTopicParams, reqEditors ...RequestEditorFn) (*CreateTopicResponse, error)

	// IdNamespaceStatsTenant request
	IdNamespaceStatsTenantWithResponse(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*IdNamespaceStatsTenantResponse, error)

	// IdNamespaceStatsTenantNamespace request
	IdNamespaceStatsTenantNamespaceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*IdNamespaceStatsTenantNamespaceResponse, error)

	// IdTopicStatsTenant request
	IdTopicStatsTenantWithResponse(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*IdTopicStatsTenantResponse, error)

	// IdTopicStatsTenantNamespace request
	IdTopicStatsTenantNamespaceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*IdTopicStatsTenantNamespaceResponse, error)

	// DeleteCDC request with any body
	DeleteCDCWithBodyWithResponse(ctx context.Context, tenantName string, params *DeleteCDCParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteCDCResponse, error)

	DeleteCDCWithResponse(ctx context.Context, tenantName string, params *DeleteCDCParams, body DeleteCDCJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteCDCResponse, error)

	// GetCDC request
	GetCDCWithResponse(ctx context.Context, tenantName string, params *GetCDCParams, reqEditors ...RequestEditorFn) (*GetCDCResponse, error)

	// EnableCDC request with any body
	EnableCDCWithBodyWithResponse(ctx context.Context, tenantName string, params *EnableCDCParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableCDCResponse, error)

	EnableCDCWithResponse(ctx context.Context, tenantName string, params *EnableCDCParams, body EnableCDCJSONRequestBody, reqEditors ...RequestEditorFn) (*EnableCDCResponse, error)

	// DeleteSink request
	DeleteSinkWithResponse(ctx context.Context, tenant string, namespace string, sinkName string, params *DeleteSinkParams, reqEditors ...RequestEditorFn) (*DeleteSinkResponse, error)

	// GetSinks request
	GetSinksWithResponse(ctx context.Context, tenant string, namespace string, sinkName string, params *GetSinksParams, reqEditors ...RequestEditorFn) (*GetSinksResponse, error)

	// CreateSinkJSON request with any body
	CreateSinkJSONWithBodyWithResponse(ctx context.Context, tenant string, namespace string, sinkName string, params *CreateSinkJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSinkJSONResponse, error)

	CreateSinkJSONWithResponse(ctx context.Context, tenant string, namespace string, sinkName string, params *CreateSinkJSONParams, body CreateSinkJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSinkJSONResponse, error)

	// UpdateSinkJSON request with any body
	UpdateSinkJSONWithBodyWithResponse(ctx context.Context, tenant string, namespace string, sinkName string, params *UpdateSinkJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSinkJSONResponse, error)

	UpdateSinkJSONWithResponse(ctx context.Context, tenant string, namespace string, sinkName string, params *UpdateSinkJSONParams, body UpdateSinkJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSinkJSONResponse, error)

	// CreateSourceJSON request with any body
	CreateSourceJSONWithBodyWithResponse(ctx context.Context, tenant string, namespace string, sourceName string, params *CreateSourceJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSourceJSONResponse, error)

	CreateSourceJSONWithResponse(ctx context.Context, tenant string, namespace string, sourceName string, params *CreateSourceJSONParams, body CreateSourceJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSourceJSONResponse, error)

	// UpdateSourceJSON request with any body
	UpdateSourceJSONWithBodyWithResponse(ctx context.Context, tenant string, namespace string, sourceName string, params *UpdateSourceJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSourceJSONResponse, error)

	UpdateSourceJSONWithResponse(ctx context.Context, tenant string, namespace string, sourceName string, params *UpdateSourceJSONParams, body UpdateSourceJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSourceJSONResponse, error)

	// GetBuiltInSinks request
	GetBuiltInSinksWithResponse(ctx context.Context, params *GetBuiltInSinksParams, reqEditors ...RequestEditorFn) (*GetBuiltInSinksResponse, error)

	// GetAccessListTemplate request
	GetAccessListTemplateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAccessListTemplateResponse, error)

	// ValidateAccessList request
	ValidateAccessListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ValidateAccessListResponse, error)

	// GetAllAccessListsForOrganization request
	GetAllAccessListsForOrganizationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllAccessListsForOrganizationResponse, error)

	// ListAvailableRegions request
	ListAvailableRegionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAvailableRegionsResponse, error)

	// DeleteTokenForClient request
	DeleteTokenForClientWithResponse(ctx context.Context, clientId ClientIdParam, reqEditors ...RequestEditorFn) (*DeleteTokenForClientResponse, error)

	// GetClientsForOrg request
	GetClientsForOrgWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClientsForOrgResponse, error)

	// GenerateTokenForClient request with any body
	GenerateTokenForClientWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateTokenForClientResponse, error)

	GenerateTokenForClientWithResponse(ctx context.Context, body GenerateTokenForClientJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateTokenForClientResponse, error)

	// GetCurrentOrganization request
	GetCurrentOrganizationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentOrganizationResponse, error)

	// ListDatabases request
	ListDatabasesWithResponse(ctx context.Context, params *ListDatabasesParams, reqEditors ...RequestEditorFn) (*ListDatabasesResponse, error)

	// CreateDatabase request with any body
	CreateDatabaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseResponse, error)

	CreateDatabaseWithResponse(ctx context.Context, body CreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseResponse, error)

	// GetDatabase request
	GetDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*GetDatabaseResponse, error)

	// DeleteAddressesOrAccessListForDatabase request
	DeleteAddressesOrAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, params *DeleteAddressesOrAccessListForDatabaseParams, reqEditors ...RequestEditorFn) (*DeleteAddressesOrAccessListForDatabaseResponse, error)

	// GetAccessListForDatabase request
	GetAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*GetAccessListForDatabaseResponse, error)

	// UpdateAccessListForDatabase request with any body
	UpdateAccessListForDatabaseWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccessListForDatabaseResponse, error)

	UpdateAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, body UpdateAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccessListForDatabaseResponse, error)

	// AddAddressesToAccessListForDatabase request with any body
	AddAddressesToAccessListForDatabaseWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddAddressesToAccessListForDatabaseResponse, error)

	AddAddressesToAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, body AddAddressesToAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*AddAddressesToAccessListForDatabaseResponse, error)

	// UpsertAccessListForDatabase request with any body
	UpsertAccessListForDatabaseWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertAccessListForDatabaseResponse, error)

	UpsertAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, body UpsertAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertAccessListForDatabaseResponse, error)

	// AddKeyspace request
	AddKeyspaceWithResponse(ctx context.Context, databaseId DatabaseIdParam, keyspaceName KeyspaceNameParam, reqEditors ...RequestEditorFn) (*AddKeyspaceResponse, error)

	// ParkDatabase request
	ParkDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*ParkDatabaseResponse, error)

	// ResetPassword request with any body
	ResetPasswordWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error)

	ResetPasswordWithResponse(ctx context.Context, databaseId DatabaseIdParam, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error)

	// ResizeDatabase request with any body
	ResizeDatabaseWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResizeDatabaseResponse, error)

	ResizeDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, body ResizeDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*ResizeDatabaseResponse, error)

	// GenerateSecureBundleURL request
	GenerateSecureBundleURLWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*GenerateSecureBundleURLResponse, error)

	// TerminateDatabase request
	TerminateDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, params *TerminateDatabaseParams, reqEditors ...RequestEditorFn) (*TerminateDatabaseResponse, error)

	// UnparkDatabase request
	UnparkDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*UnparkDatabaseResponse, error)

	// GetOrganizationRoles request
	GetOrganizationRolesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOrganizationRolesResponse, error)

	// AddOrganizationRole request with any body
	AddOrganizationRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrganizationRoleResponse, error)

	AddOrganizationRoleWithResponse(ctx context.Context, body AddOrganizationRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrganizationRoleResponse, error)

	// DeleteOrganizationRole request
	DeleteOrganizationRoleWithResponse(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*DeleteOrganizationRoleResponse, error)

	// GetOrganizationRole request
	GetOrganizationRoleWithResponse(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*GetOrganizationRoleResponse, error)

	// UpdateRole request with any body
	UpdateRoleWithBodyWithResponse(ctx context.Context, roleID RoleIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error)

	UpdateRoleWithResponse(ctx context.Context, roleID RoleIdParam, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error)

	// GetOrganizationUsers request
	GetOrganizationUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOrganizationUsersResponse, error)

	// InviteUserToOrganization request with any body
	InviteUserToOrganizationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteUserToOrganizationResponse, error)

	InviteUserToOrganizationWithResponse(ctx context.Context, body InviteUserToOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteUserToOrganizationResponse, error)

	// RemoveUserFromOrganization request
	RemoveUserFromOrganizationWithResponse(ctx context.Context, userID UserIdParam, reqEditors ...RequestEditorFn) (*RemoveUserFromOrganizationResponse, error)

	// GetOrganizationUser request
	GetOrganizationUserWithResponse(ctx context.Context, userID UserIdParam, reqEditors ...RequestEditorFn) (*GetOrganizationUserResponse, error)

	// UpdateRolesForUserInOrganization request with any body
	UpdateRolesForUserInOrganizationWithBodyWithResponse(ctx context.Context, userID UserIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRolesForUserInOrganizationResponse, error)

	UpdateRolesForUserInOrganizationWithResponse(ctx context.Context, userID UserIdParam, body UpdateRolesForUserInOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRolesForUserInOrganizationResponse, error)

	// IdOfTenant request
	IdOfTenantWithResponse(ctx context.Context, params *IdOfTenantParams, reqEditors ...RequestEditorFn) (*IdOfTenantResponse, error)

	// GetPulsarClusters request
	GetPulsarClustersWithResponse(ctx context.Context, org string, reqEditors ...RequestEditorFn) (*GetPulsarClustersResponse, error)

	// GetStreamingTenant request
	GetStreamingTenantWithResponse(ctx context.Context, org string, tenant string, reqEditors ...RequestEditorFn) (*GetStreamingTenantResponse, error)

	// GetStreamingProviders request
	GetStreamingProvidersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStreamingProvidersResponse, error)

	// GetTenants request
	GetTenantsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTenantsResponse, error)

	// IdOfCreateTenantEndpoint request with any body
	IdOfCreateTenantEndpointWithBodyWithResponse(ctx context.Context, params *IdOfCreateTenantEndpointParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IdOfCreateTenantEndpointResponse, error)

	IdOfCreateTenantEndpointWithResponse(ctx context.Context, params *IdOfCreateTenantEndpointParams, body IdOfCreateTenantEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*IdOfCreateTenantEndpointResponse, error)

	// GetTeneantLimitUsage request
	GetTeneantLimitUsageWithResponse(ctx context.Context, tenantName string, params *GetTeneantLimitUsageParams, reqEditors ...RequestEditorFn) (*GetTeneantLimitUsageResponse, error)

	// DeleteStreamingTenant request
	DeleteStreamingTenantWithResponse(ctx context.Context, tenant string, cluster string, params *DeleteStreamingTenantParams, reqEditors ...RequestEditorFn) (*DeleteStreamingTenantResponse, error)

	// GetLimits request
	GetLimitsWithResponse(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*GetLimitsResponse, error)

	// IdListTenantTokens request
	IdListTenantTokensWithResponse(ctx context.Context, tenant string, params *IdListTenantTokensParams, reqEditors ...RequestEditorFn) (*IdListTenantTokensResponse, error)

	// GetTokenByID request
	GetTokenByIDWithResponse(ctx context.Context, tenant string, tokenId string, params *GetTokenByIDParams, reqEditors ...RequestEditorFn) (*GetTokenByIDResponse, error)
}

type GetTenantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetTenantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTenantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IdNamespaceStatsTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatsResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r IdNamespaceStatsTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IdNamespaceStatsTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IdNamespaceStatsTenantNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatsResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r IdNamespaceStatsTenantNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IdNamespaceStatsTenantNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IdTopicStatsTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatsResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r IdTopicStatsTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IdTopicStatsTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IdTopicStatsTenantNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatsResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r IdTopicStatsTenantNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IdTopicStatsTenantNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCDCResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreatedTenantResponse
	JSON401      *ErrorResponse
	JSON409      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteCDCResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCDCResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCDCResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreatedTenantResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCDCResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCDCResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnableCDCResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreatedTenantResponse
	JSON401      *ErrorResponse
	JSON409      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r EnableCDCResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnableCDCResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSinkJSONResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateSinkJSONResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSinkJSONResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSinkJSONResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateSinkJSONResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSinkJSONResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSourceJSONResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateSourceJSONResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSourceJSONResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSourceJSONResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateSourceJSONResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSourceJSONResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBuiltInSinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetBuiltInSinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBuiltInSinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccessListTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccessListRequest
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r GetAccessListTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccessListTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateAccessListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ValidationResponse
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r ValidateAccessListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateAccessListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllAccessListsForOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AccessListResponse
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r GetAllAccessListsForOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllAccessListsForOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAvailableRegionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AvailableRegionCombination
	JSON401      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r ListAvailableRegionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAvailableRegionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTokenForClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON403      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r DeleteTokenForClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTokenForClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientsForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *Errors
	JSON403      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r GetClientsForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientsForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateTokenForClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *Errors
	JSON403      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r GenerateTokenForClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateTokenForClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *Errors
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r GetCurrentOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDatabasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Database
	JSON400      *Errors
	JSON401      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r ListDatabasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDatabasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON401      *Errors
	JSON422      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r CreateDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Database
	JSON400      *Errors
	JSON401      *Errors
	JSON404      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r GetDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAddressesOrAccessListForDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r DeleteAddressesOrAccessListForDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAddressesOrAccessListForDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccessListForDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccessListResponse
	JSON400      *Errors
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r GetAccessListForDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccessListForDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAccessListForDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r UpdateAccessListForDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAccessListForDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddAddressesToAccessListForDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r AddAddressesToAccessListForDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddAddressesToAccessListForDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertAccessListForDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r UpsertAccessListForDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertAccessListForDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddKeyspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Errors
	JSON404      *Errors
	JSON422      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r AddKeyspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddKeyspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ParkDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON401      *Errors
	JSON404      *Errors
	JSON409      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r ParkDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ParkDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON401      *Errors
	JSON404      *Errors
	JSON409      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r ResetPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResizeDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON401      *Errors
	JSON404      *Errors
	JSON409      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r ResizeDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResizeDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateSecureBundleURLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CredsURL
	JSON400      *Errors
	JSON401      *Errors
	JSON404      *Errors
	JSON409      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r GenerateSecureBundleURLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateSecureBundleURLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TerminateDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON401      *Errors
	JSON404      *Errors
	JSON409      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r TerminateDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TerminateDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnparkDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON401      *Errors
	JSON404      *Errors
	JSON409      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r UnparkDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnparkDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r GetOrganizationRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddOrganizationRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON403      *Errors
	JSON404      *Errors
	JSON409      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r AddOrganizationRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddOrganizationRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOrganizationRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r DeleteOrganizationRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOrganizationRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *Errors
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r GetOrganizationRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *Errors
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r UpdateRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOrgUsersResponse
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r GetOrganizationUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InviteUserToOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r InviteUserToOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InviteUserToOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveUserFromOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r RemoveUserFromOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveUserFromOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserResponse
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r GetOrganizationUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRolesForUserInOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r UpdateRolesForUserInOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRolesForUserInOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IdOfTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PulsarClustersResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r IdOfTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IdOfTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPulsarClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantClusterPlansResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetPulsarClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPulsarClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamingTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantClusterPlanResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetStreamingTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamingTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamingProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProviderRegionsResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetStreamingProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamingProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTenantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantClusterPlansResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTenantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTenantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IdOfCreateTenantEndpointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantClusterPlanResponse
	JSON401      *ErrorResponse
	JSON409      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r IdOfCreateTenantEndpointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IdOfCreateTenantEndpointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeneantLimitUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetTeneantLimitUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeneantLimitUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStreamingTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteStreamingTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStreamingTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLimitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantLimitResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetLimitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLimitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IdListTenantTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListOfMaps
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r IdListTenantTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IdListTenantTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTokenByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTokenByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTokenByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetTenantsWithResponse request returning *GetTenantsResponse
func (c *ClientWithResponses) GetTenantsWithResponse(ctx context.Context, tenant string, namespace string, params *GetTenantsParams, reqEditors ...RequestEditorFn) (*GetTenantsResponse, error) {
	rsp, err := c.GetTenants(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTenantsResponse(rsp)
}

// DeleteTopicWithResponse request returning *DeleteTopicResponse
func (c *ClientWithResponses) DeleteTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteTopicParams, reqEditors ...RequestEditorFn) (*DeleteTopicResponse, error) {
	rsp, err := c.DeleteTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTopicResponse(rsp)
}

// CreateTopicWithResponse request returning *CreateTopicResponse
func (c *ClientWithResponses) CreateTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CreateTopicParams, reqEditors ...RequestEditorFn) (*CreateTopicResponse, error) {
	rsp, err := c.CreateTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTopicResponse(rsp)
}

// IdNamespaceStatsTenantWithResponse request returning *IdNamespaceStatsTenantResponse
func (c *ClientWithResponses) IdNamespaceStatsTenantWithResponse(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*IdNamespaceStatsTenantResponse, error) {
	rsp, err := c.IdNamespaceStatsTenant(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIdNamespaceStatsTenantResponse(rsp)
}

// IdNamespaceStatsTenantNamespaceWithResponse request returning *IdNamespaceStatsTenantNamespaceResponse
func (c *ClientWithResponses) IdNamespaceStatsTenantNamespaceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*IdNamespaceStatsTenantNamespaceResponse, error) {
	rsp, err := c.IdNamespaceStatsTenantNamespace(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIdNamespaceStatsTenantNamespaceResponse(rsp)
}

// IdTopicStatsTenantWithResponse request returning *IdTopicStatsTenantResponse
func (c *ClientWithResponses) IdTopicStatsTenantWithResponse(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*IdTopicStatsTenantResponse, error) {
	rsp, err := c.IdTopicStatsTenant(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIdTopicStatsTenantResponse(rsp)
}

// IdTopicStatsTenantNamespaceWithResponse request returning *IdTopicStatsTenantNamespaceResponse
func (c *ClientWithResponses) IdTopicStatsTenantNamespaceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*IdTopicStatsTenantNamespaceResponse, error) {
	rsp, err := c.IdTopicStatsTenantNamespace(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIdTopicStatsTenantNamespaceResponse(rsp)
}

// DeleteCDCWithBodyWithResponse request with arbitrary body returning *DeleteCDCResponse
func (c *ClientWithResponses) DeleteCDCWithBodyWithResponse(ctx context.Context, tenantName string, params *DeleteCDCParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteCDCResponse, error) {
	rsp, err := c.DeleteCDCWithBody(ctx, tenantName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCDCResponse(rsp)
}

func (c *ClientWithResponses) DeleteCDCWithResponse(ctx context.Context, tenantName string, params *DeleteCDCParams, body DeleteCDCJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteCDCResponse, error) {
	rsp, err := c.DeleteCDC(ctx, tenantName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCDCResponse(rsp)
}

// GetCDCWithResponse request returning *GetCDCResponse
func (c *ClientWithResponses) GetCDCWithResponse(ctx context.Context, tenantName string, params *GetCDCParams, reqEditors ...RequestEditorFn) (*GetCDCResponse, error) {
	rsp, err := c.GetCDC(ctx, tenantName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCDCResponse(rsp)
}

// EnableCDCWithBodyWithResponse request with arbitrary body returning *EnableCDCResponse
func (c *ClientWithResponses) EnableCDCWithBodyWithResponse(ctx context.Context, tenantName string, params *EnableCDCParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableCDCResponse, error) {
	rsp, err := c.EnableCDCWithBody(ctx, tenantName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableCDCResponse(rsp)
}

func (c *ClientWithResponses) EnableCDCWithResponse(ctx context.Context, tenantName string, params *EnableCDCParams, body EnableCDCJSONRequestBody, reqEditors ...RequestEditorFn) (*EnableCDCResponse, error) {
	rsp, err := c.EnableCDC(ctx, tenantName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableCDCResponse(rsp)
}

// DeleteSinkWithResponse request returning *DeleteSinkResponse
func (c *ClientWithResponses) DeleteSinkWithResponse(ctx context.Context, tenant string, namespace string, sinkName string, params *DeleteSinkParams, reqEditors ...RequestEditorFn) (*DeleteSinkResponse, error) {
	rsp, err := c.DeleteSink(ctx, tenant, namespace, sinkName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSinkResponse(rsp)
}

// GetSinksWithResponse request returning *GetSinksResponse
func (c *ClientWithResponses) GetSinksWithResponse(ctx context.Context, tenant string, namespace string, sinkName string, params *GetSinksParams, reqEditors ...RequestEditorFn) (*GetSinksResponse, error) {
	rsp, err := c.GetSinks(ctx, tenant, namespace, sinkName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSinksResponse(rsp)
}

// CreateSinkJSONWithBodyWithResponse request with arbitrary body returning *CreateSinkJSONResponse
func (c *ClientWithResponses) CreateSinkJSONWithBodyWithResponse(ctx context.Context, tenant string, namespace string, sinkName string, params *CreateSinkJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSinkJSONResponse, error) {
	rsp, err := c.CreateSinkJSONWithBody(ctx, tenant, namespace, sinkName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSinkJSONResponse(rsp)
}

func (c *ClientWithResponses) CreateSinkJSONWithResponse(ctx context.Context, tenant string, namespace string, sinkName string, params *CreateSinkJSONParams, body CreateSinkJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSinkJSONResponse, error) {
	rsp, err := c.CreateSinkJSON(ctx, tenant, namespace, sinkName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSinkJSONResponse(rsp)
}

// UpdateSinkJSONWithBodyWithResponse request with arbitrary body returning *UpdateSinkJSONResponse
func (c *ClientWithResponses) UpdateSinkJSONWithBodyWithResponse(ctx context.Context, tenant string, namespace string, sinkName string, params *UpdateSinkJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSinkJSONResponse, error) {
	rsp, err := c.UpdateSinkJSONWithBody(ctx, tenant, namespace, sinkName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSinkJSONResponse(rsp)
}

func (c *ClientWithResponses) UpdateSinkJSONWithResponse(ctx context.Context, tenant string, namespace string, sinkName string, params *UpdateSinkJSONParams, body UpdateSinkJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSinkJSONResponse, error) {
	rsp, err := c.UpdateSinkJSON(ctx, tenant, namespace, sinkName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSinkJSONResponse(rsp)
}

// CreateSourceJSONWithBodyWithResponse request with arbitrary body returning *CreateSourceJSONResponse
func (c *ClientWithResponses) CreateSourceJSONWithBodyWithResponse(ctx context.Context, tenant string, namespace string, sourceName string, params *CreateSourceJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSourceJSONResponse, error) {
	rsp, err := c.CreateSourceJSONWithBody(ctx, tenant, namespace, sourceName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSourceJSONResponse(rsp)
}

func (c *ClientWithResponses) CreateSourceJSONWithResponse(ctx context.Context, tenant string, namespace string, sourceName string, params *CreateSourceJSONParams, body CreateSourceJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSourceJSONResponse, error) {
	rsp, err := c.CreateSourceJSON(ctx, tenant, namespace, sourceName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSourceJSONResponse(rsp)
}

// UpdateSourceJSONWithBodyWithResponse request with arbitrary body returning *UpdateSourceJSONResponse
func (c *ClientWithResponses) UpdateSourceJSONWithBodyWithResponse(ctx context.Context, tenant string, namespace string, sourceName string, params *UpdateSourceJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSourceJSONResponse, error) {
	rsp, err := c.UpdateSourceJSONWithBody(ctx, tenant, namespace, sourceName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSourceJSONResponse(rsp)
}

func (c *ClientWithResponses) UpdateSourceJSONWithResponse(ctx context.Context, tenant string, namespace string, sourceName string, params *UpdateSourceJSONParams, body UpdateSourceJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSourceJSONResponse, error) {
	rsp, err := c.UpdateSourceJSON(ctx, tenant, namespace, sourceName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSourceJSONResponse(rsp)
}

// GetBuiltInSinksWithResponse request returning *GetBuiltInSinksResponse
func (c *ClientWithResponses) GetBuiltInSinksWithResponse(ctx context.Context, params *GetBuiltInSinksParams, reqEditors ...RequestEditorFn) (*GetBuiltInSinksResponse, error) {
	rsp, err := c.GetBuiltInSinks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBuiltInSinksResponse(rsp)
}

// GetAccessListTemplateWithResponse request returning *GetAccessListTemplateResponse
func (c *ClientWithResponses) GetAccessListTemplateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAccessListTemplateResponse, error) {
	rsp, err := c.GetAccessListTemplate(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccessListTemplateResponse(rsp)
}

// ValidateAccessListWithResponse request returning *ValidateAccessListResponse
func (c *ClientWithResponses) ValidateAccessListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ValidateAccessListResponse, error) {
	rsp, err := c.ValidateAccessList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateAccessListResponse(rsp)
}

// GetAllAccessListsForOrganizationWithResponse request returning *GetAllAccessListsForOrganizationResponse
func (c *ClientWithResponses) GetAllAccessListsForOrganizationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllAccessListsForOrganizationResponse, error) {
	rsp, err := c.GetAllAccessListsForOrganization(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllAccessListsForOrganizationResponse(rsp)
}

// ListAvailableRegionsWithResponse request returning *ListAvailableRegionsResponse
func (c *ClientWithResponses) ListAvailableRegionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAvailableRegionsResponse, error) {
	rsp, err := c.ListAvailableRegions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAvailableRegionsResponse(rsp)
}

// DeleteTokenForClientWithResponse request returning *DeleteTokenForClientResponse
func (c *ClientWithResponses) DeleteTokenForClientWithResponse(ctx context.Context, clientId ClientIdParam, reqEditors ...RequestEditorFn) (*DeleteTokenForClientResponse, error) {
	rsp, err := c.DeleteTokenForClient(ctx, clientId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTokenForClientResponse(rsp)
}

// GetClientsForOrgWithResponse request returning *GetClientsForOrgResponse
func (c *ClientWithResponses) GetClientsForOrgWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClientsForOrgResponse, error) {
	rsp, err := c.GetClientsForOrg(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientsForOrgResponse(rsp)
}

// GenerateTokenForClientWithBodyWithResponse request with arbitrary body returning *GenerateTokenForClientResponse
func (c *ClientWithResponses) GenerateTokenForClientWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateTokenForClientResponse, error) {
	rsp, err := c.GenerateTokenForClientWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateTokenForClientResponse(rsp)
}

func (c *ClientWithResponses) GenerateTokenForClientWithResponse(ctx context.Context, body GenerateTokenForClientJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateTokenForClientResponse, error) {
	rsp, err := c.GenerateTokenForClient(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateTokenForClientResponse(rsp)
}

// GetCurrentOrganizationWithResponse request returning *GetCurrentOrganizationResponse
func (c *ClientWithResponses) GetCurrentOrganizationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentOrganizationResponse, error) {
	rsp, err := c.GetCurrentOrganization(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentOrganizationResponse(rsp)
}

// ListDatabasesWithResponse request returning *ListDatabasesResponse
func (c *ClientWithResponses) ListDatabasesWithResponse(ctx context.Context, params *ListDatabasesParams, reqEditors ...RequestEditorFn) (*ListDatabasesResponse, error) {
	rsp, err := c.ListDatabases(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDatabasesResponse(rsp)
}

// CreateDatabaseWithBodyWithResponse request with arbitrary body returning *CreateDatabaseResponse
func (c *ClientWithResponses) CreateDatabaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseResponse, error) {
	rsp, err := c.CreateDatabaseWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseResponse(rsp)
}

func (c *ClientWithResponses) CreateDatabaseWithResponse(ctx context.Context, body CreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseResponse, error) {
	rsp, err := c.CreateDatabase(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseResponse(rsp)
}

// GetDatabaseWithResponse request returning *GetDatabaseResponse
func (c *ClientWithResponses) GetDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*GetDatabaseResponse, error) {
	rsp, err := c.GetDatabase(ctx, databaseId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatabaseResponse(rsp)
}

// DeleteAddressesOrAccessListForDatabaseWithResponse request returning *DeleteAddressesOrAccessListForDatabaseResponse
func (c *ClientWithResponses) DeleteAddressesOrAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, params *DeleteAddressesOrAccessListForDatabaseParams, reqEditors ...RequestEditorFn) (*DeleteAddressesOrAccessListForDatabaseResponse, error) {
	rsp, err := c.DeleteAddressesOrAccessListForDatabase(ctx, databaseId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAddressesOrAccessListForDatabaseResponse(rsp)
}

// GetAccessListForDatabaseWithResponse request returning *GetAccessListForDatabaseResponse
func (c *ClientWithResponses) GetAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*GetAccessListForDatabaseResponse, error) {
	rsp, err := c.GetAccessListForDatabase(ctx, databaseId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccessListForDatabaseResponse(rsp)
}

// UpdateAccessListForDatabaseWithBodyWithResponse request with arbitrary body returning *UpdateAccessListForDatabaseResponse
func (c *ClientWithResponses) UpdateAccessListForDatabaseWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccessListForDatabaseResponse, error) {
	rsp, err := c.UpdateAccessListForDatabaseWithBody(ctx, databaseId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccessListForDatabaseResponse(rsp)
}

func (c *ClientWithResponses) UpdateAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, body UpdateAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccessListForDatabaseResponse, error) {
	rsp, err := c.UpdateAccessListForDatabase(ctx, databaseId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccessListForDatabaseResponse(rsp)
}

// AddAddressesToAccessListForDatabaseWithBodyWithResponse request with arbitrary body returning *AddAddressesToAccessListForDatabaseResponse
func (c *ClientWithResponses) AddAddressesToAccessListForDatabaseWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddAddressesToAccessListForDatabaseResponse, error) {
	rsp, err := c.AddAddressesToAccessListForDatabaseWithBody(ctx, databaseId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddAddressesToAccessListForDatabaseResponse(rsp)
}

func (c *ClientWithResponses) AddAddressesToAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, body AddAddressesToAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*AddAddressesToAccessListForDatabaseResponse, error) {
	rsp, err := c.AddAddressesToAccessListForDatabase(ctx, databaseId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddAddressesToAccessListForDatabaseResponse(rsp)
}

// UpsertAccessListForDatabaseWithBodyWithResponse request with arbitrary body returning *UpsertAccessListForDatabaseResponse
func (c *ClientWithResponses) UpsertAccessListForDatabaseWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertAccessListForDatabaseResponse, error) {
	rsp, err := c.UpsertAccessListForDatabaseWithBody(ctx, databaseId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertAccessListForDatabaseResponse(rsp)
}

func (c *ClientWithResponses) UpsertAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, body UpsertAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertAccessListForDatabaseResponse, error) {
	rsp, err := c.UpsertAccessListForDatabase(ctx, databaseId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertAccessListForDatabaseResponse(rsp)
}

// AddKeyspaceWithResponse request returning *AddKeyspaceResponse
func (c *ClientWithResponses) AddKeyspaceWithResponse(ctx context.Context, databaseId DatabaseIdParam, keyspaceName KeyspaceNameParam, reqEditors ...RequestEditorFn) (*AddKeyspaceResponse, error) {
	rsp, err := c.AddKeyspace(ctx, databaseId, keyspaceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddKeyspaceResponse(rsp)
}

// ParkDatabaseWithResponse request returning *ParkDatabaseResponse
func (c *ClientWithResponses) ParkDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*ParkDatabaseResponse, error) {
	rsp, err := c.ParkDatabase(ctx, databaseId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseParkDatabaseResponse(rsp)
}

// ResetPasswordWithBodyWithResponse request with arbitrary body returning *ResetPasswordResponse
func (c *ClientWithResponses) ResetPasswordWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error) {
	rsp, err := c.ResetPasswordWithBody(ctx, databaseId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPasswordResponse(rsp)
}

func (c *ClientWithResponses) ResetPasswordWithResponse(ctx context.Context, databaseId DatabaseIdParam, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error) {
	rsp, err := c.ResetPassword(ctx, databaseId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPasswordResponse(rsp)
}

// ResizeDatabaseWithBodyWithResponse request with arbitrary body returning *ResizeDatabaseResponse
func (c *ClientWithResponses) ResizeDatabaseWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResizeDatabaseResponse, error) {
	rsp, err := c.ResizeDatabaseWithBody(ctx, databaseId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResizeDatabaseResponse(rsp)
}

func (c *ClientWithResponses) ResizeDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, body ResizeDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*ResizeDatabaseResponse, error) {
	rsp, err := c.ResizeDatabase(ctx, databaseId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResizeDatabaseResponse(rsp)
}

// GenerateSecureBundleURLWithResponse request returning *GenerateSecureBundleURLResponse
func (c *ClientWithResponses) GenerateSecureBundleURLWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*GenerateSecureBundleURLResponse, error) {
	rsp, err := c.GenerateSecureBundleURL(ctx, databaseId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateSecureBundleURLResponse(rsp)
}

// TerminateDatabaseWithResponse request returning *TerminateDatabaseResponse
func (c *ClientWithResponses) TerminateDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, params *TerminateDatabaseParams, reqEditors ...RequestEditorFn) (*TerminateDatabaseResponse, error) {
	rsp, err := c.TerminateDatabase(ctx, databaseId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTerminateDatabaseResponse(rsp)
}

// UnparkDatabaseWithResponse request returning *UnparkDatabaseResponse
func (c *ClientWithResponses) UnparkDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*UnparkDatabaseResponse, error) {
	rsp, err := c.UnparkDatabase(ctx, databaseId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnparkDatabaseResponse(rsp)
}

// GetOrganizationRolesWithResponse request returning *GetOrganizationRolesResponse
func (c *ClientWithResponses) GetOrganizationRolesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOrganizationRolesResponse, error) {
	rsp, err := c.GetOrganizationRoles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationRolesResponse(rsp)
}

// AddOrganizationRoleWithBodyWithResponse request with arbitrary body returning *AddOrganizationRoleResponse
func (c *ClientWithResponses) AddOrganizationRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrganizationRoleResponse, error) {
	rsp, err := c.AddOrganizationRoleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrganizationRoleResponse(rsp)
}

func (c *ClientWithResponses) AddOrganizationRoleWithResponse(ctx context.Context, body AddOrganizationRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrganizationRoleResponse, error) {
	rsp, err := c.AddOrganizationRole(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrganizationRoleResponse(rsp)
}

// DeleteOrganizationRoleWithResponse request returning *DeleteOrganizationRoleResponse
func (c *ClientWithResponses) DeleteOrganizationRoleWithResponse(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*DeleteOrganizationRoleResponse, error) {
	rsp, err := c.DeleteOrganizationRole(ctx, roleID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOrganizationRoleResponse(rsp)
}

// GetOrganizationRoleWithResponse request returning *GetOrganizationRoleResponse
func (c *ClientWithResponses) GetOrganizationRoleWithResponse(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*GetOrganizationRoleResponse, error) {
	rsp, err := c.GetOrganizationRole(ctx, roleID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationRoleResponse(rsp)
}

// UpdateRoleWithBodyWithResponse request with arbitrary body returning *UpdateRoleResponse
func (c *ClientWithResponses) UpdateRoleWithBodyWithResponse(ctx context.Context, roleID RoleIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error) {
	rsp, err := c.UpdateRoleWithBody(ctx, roleID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleResponse(rsp)
}

func (c *ClientWithResponses) UpdateRoleWithResponse(ctx context.Context, roleID RoleIdParam, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error) {
	rsp, err := c.UpdateRole(ctx, roleID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleResponse(rsp)
}

// GetOrganizationUsersWithResponse request returning *GetOrganizationUsersResponse
func (c *ClientWithResponses) GetOrganizationUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOrganizationUsersResponse, error) {
	rsp, err := c.GetOrganizationUsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationUsersResponse(rsp)
}

// InviteUserToOrganizationWithBodyWithResponse request with arbitrary body returning *InviteUserToOrganizationResponse
func (c *ClientWithResponses) InviteUserToOrganizationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteUserToOrganizationResponse, error) {
	rsp, err := c.InviteUserToOrganizationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteUserToOrganizationResponse(rsp)
}

func (c *ClientWithResponses) InviteUserToOrganizationWithResponse(ctx context.Context, body InviteUserToOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteUserToOrganizationResponse, error) {
	rsp, err := c.InviteUserToOrganization(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteUserToOrganizationResponse(rsp)
}

// RemoveUserFromOrganizationWithResponse request returning *RemoveUserFromOrganizationResponse
func (c *ClientWithResponses) RemoveUserFromOrganizationWithResponse(ctx context.Context, userID UserIdParam, reqEditors ...RequestEditorFn) (*RemoveUserFromOrganizationResponse, error) {
	rsp, err := c.RemoveUserFromOrganization(ctx, userID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUserFromOrganizationResponse(rsp)
}

// GetOrganizationUserWithResponse request returning *GetOrganizationUserResponse
func (c *ClientWithResponses) GetOrganizationUserWithResponse(ctx context.Context, userID UserIdParam, reqEditors ...RequestEditorFn) (*GetOrganizationUserResponse, error) {
	rsp, err := c.GetOrganizationUser(ctx, userID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationUserResponse(rsp)
}

// UpdateRolesForUserInOrganizationWithBodyWithResponse request with arbitrary body returning *UpdateRolesForUserInOrganizationResponse
func (c *ClientWithResponses) UpdateRolesForUserInOrganizationWithBodyWithResponse(ctx context.Context, userID UserIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRolesForUserInOrganizationResponse, error) {
	rsp, err := c.UpdateRolesForUserInOrganizationWithBody(ctx, userID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRolesForUserInOrganizationResponse(rsp)
}

func (c *ClientWithResponses) UpdateRolesForUserInOrganizationWithResponse(ctx context.Context, userID UserIdParam, body UpdateRolesForUserInOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRolesForUserInOrganizationResponse, error) {
	rsp, err := c.UpdateRolesForUserInOrganization(ctx, userID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRolesForUserInOrganizationResponse(rsp)
}

// IdOfTenantWithResponse request returning *IdOfTenantResponse
func (c *ClientWithResponses) IdOfTenantWithResponse(ctx context.Context, params *IdOfTenantParams, reqEditors ...RequestEditorFn) (*IdOfTenantResponse, error) {
	rsp, err := c.IdOfTenant(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIdOfTenantResponse(rsp)
}

// GetPulsarClustersWithResponse request returning *GetPulsarClustersResponse
func (c *ClientWithResponses) GetPulsarClustersWithResponse(ctx context.Context, org string, reqEditors ...RequestEditorFn) (*GetPulsarClustersResponse, error) {
	rsp, err := c.GetPulsarClusters(ctx, org, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPulsarClustersResponse(rsp)
}

// GetStreamingTenantWithResponse request returning *GetStreamingTenantResponse
func (c *ClientWithResponses) GetStreamingTenantWithResponse(ctx context.Context, org string, tenant string, reqEditors ...RequestEditorFn) (*GetStreamingTenantResponse, error) {
	rsp, err := c.GetStreamingTenant(ctx, org, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamingTenantResponse(rsp)
}

// GetStreamingProvidersWithResponse request returning *GetStreamingProvidersResponse
func (c *ClientWithResponses) GetStreamingProvidersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStreamingProvidersResponse, error) {
	rsp, err := c.GetStreamingProviders(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamingProvidersResponse(rsp)
}

// GetTenantsWithResponse request returning *GetTenantsResponse
func (c *ClientWithResponses) GetTenantsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTenantsResponse, error) {
	rsp, err := c.GetTenants(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTenantsResponse(rsp)
}

// IdOfCreateTenantEndpointWithBodyWithResponse request with arbitrary body returning *IdOfCreateTenantEndpointResponse
func (c *ClientWithResponses) IdOfCreateTenantEndpointWithBodyWithResponse(ctx context.Context, params *IdOfCreateTenantEndpointParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IdOfCreateTenantEndpointResponse, error) {
	rsp, err := c.IdOfCreateTenantEndpointWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIdOfCreateTenantEndpointResponse(rsp)
}

func (c *ClientWithResponses) IdOfCreateTenantEndpointWithResponse(ctx context.Context, params *IdOfCreateTenantEndpointParams, body IdOfCreateTenantEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*IdOfCreateTenantEndpointResponse, error) {
	rsp, err := c.IdOfCreateTenantEndpoint(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIdOfCreateTenantEndpointResponse(rsp)
}

// GetTeneantLimitUsageWithResponse request returning *GetTeneantLimitUsageResponse
func (c *ClientWithResponses) GetTeneantLimitUsageWithResponse(ctx context.Context, tenantName string, params *GetTeneantLimitUsageParams, reqEditors ...RequestEditorFn) (*GetTeneantLimitUsageResponse, error) {
	rsp, err := c.GetTeneantLimitUsage(ctx, tenantName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeneantLimitUsageResponse(rsp)
}

// DeleteStreamingTenantWithResponse request returning *DeleteStreamingTenantResponse
func (c *ClientWithResponses) DeleteStreamingTenantWithResponse(ctx context.Context, tenant string, cluster string, params *DeleteStreamingTenantParams, reqEditors ...RequestEditorFn) (*DeleteStreamingTenantResponse, error) {
	rsp, err := c.DeleteStreamingTenant(ctx, tenant, cluster, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStreamingTenantResponse(rsp)
}

// GetLimitsWithResponse request returning *GetLimitsResponse
func (c *ClientWithResponses) GetLimitsWithResponse(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*GetLimitsResponse, error) {
	rsp, err := c.GetLimits(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLimitsResponse(rsp)
}

// IdListTenantTokensWithResponse request returning *IdListTenantTokensResponse
func (c *ClientWithResponses) IdListTenantTokensWithResponse(ctx context.Context, tenant string, params *IdListTenantTokensParams, reqEditors ...RequestEditorFn) (*IdListTenantTokensResponse, error) {
	rsp, err := c.IdListTenantTokens(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIdListTenantTokensResponse(rsp)
}

// GetTokenByIDWithResponse request returning *GetTokenByIDResponse
func (c *ClientWithResponses) GetTokenByIDWithResponse(ctx context.Context, tenant string, tokenId string, params *GetTokenByIDParams, reqEditors ...RequestEditorFn) (*GetTokenByIDResponse, error) {
	rsp, err := c.GetTokenByID(ctx, tenant, tokenId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTokenByIDResponse(rsp)
}

// ParseGetTenantsResponse parses an HTTP response from a GetTenantsWithResponse call
func ParseGetTenantsResponse(rsp *http.Response) (*GetTenantsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTenantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteTopicResponse parses an HTTP response from a DeleteTopicWithResponse call
func ParseDeleteTopicResponse(rsp *http.Response) (*DeleteTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateTopicResponse parses an HTTP response from a CreateTopicWithResponse call
func ParseCreateTopicResponse(rsp *http.Response) (*CreateTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseIdNamespaceStatsTenantResponse parses an HTTP response from a IdNamespaceStatsTenantWithResponse call
func ParseIdNamespaceStatsTenantResponse(rsp *http.Response) (*IdNamespaceStatsTenantResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IdNamespaceStatsTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIdNamespaceStatsTenantNamespaceResponse parses an HTTP response from a IdNamespaceStatsTenantNamespaceWithResponse call
func ParseIdNamespaceStatsTenantNamespaceResponse(rsp *http.Response) (*IdNamespaceStatsTenantNamespaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IdNamespaceStatsTenantNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIdTopicStatsTenantResponse parses an HTTP response from a IdTopicStatsTenantWithResponse call
func ParseIdTopicStatsTenantResponse(rsp *http.Response) (*IdTopicStatsTenantResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IdTopicStatsTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIdTopicStatsTenantNamespaceResponse parses an HTTP response from a IdTopicStatsTenantNamespaceWithResponse call
func ParseIdTopicStatsTenantNamespaceResponse(rsp *http.Response) (*IdTopicStatsTenantNamespaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IdTopicStatsTenantNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCDCResponse parses an HTTP response from a DeleteCDCWithResponse call
func ParseDeleteCDCResponse(rsp *http.Response) (*DeleteCDCResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCDCResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreatedTenantResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCDCResponse parses an HTTP response from a GetCDCWithResponse call
func ParseGetCDCResponse(rsp *http.Response) (*GetCDCResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCDCResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreatedTenantResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEnableCDCResponse parses an HTTP response from a EnableCDCWithResponse call
func ParseEnableCDCResponse(rsp *http.Response) (*EnableCDCResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnableCDCResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreatedTenantResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSinkResponse parses an HTTP response from a DeleteSinkWithResponse call
func ParseDeleteSinkResponse(rsp *http.Response) (*DeleteSinkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSinksResponse parses an HTTP response from a GetSinksWithResponse call
func ParseGetSinksResponse(rsp *http.Response) (*GetSinksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateSinkJSONResponse parses an HTTP response from a CreateSinkJSONWithResponse call
func ParseCreateSinkJSONResponse(rsp *http.Response) (*CreateSinkJSONResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSinkJSONResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSinkJSONResponse parses an HTTP response from a UpdateSinkJSONWithResponse call
func ParseUpdateSinkJSONResponse(rsp *http.Response) (*UpdateSinkJSONResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSinkJSONResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateSourceJSONResponse parses an HTTP response from a CreateSourceJSONWithResponse call
func ParseCreateSourceJSONResponse(rsp *http.Response) (*CreateSourceJSONResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSourceJSONResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSourceJSONResponse parses an HTTP response from a UpdateSourceJSONWithResponse call
func ParseUpdateSourceJSONResponse(rsp *http.Response) (*UpdateSourceJSONResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSourceJSONResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBuiltInSinksResponse parses an HTTP response from a GetBuiltInSinksWithResponse call
func ParseGetBuiltInSinksResponse(rsp *http.Response) (*GetBuiltInSinksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBuiltInSinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAccessListTemplateResponse parses an HTTP response from a GetAccessListTemplateWithResponse call
func ParseGetAccessListTemplateResponse(rsp *http.Response) (*GetAccessListTemplateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccessListTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccessListRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseValidateAccessListResponse parses an HTTP response from a ValidateAccessListWithResponse call
func ParseValidateAccessListResponse(rsp *http.Response) (*ValidateAccessListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateAccessListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ValidationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAllAccessListsForOrganizationResponse parses an HTTP response from a GetAllAccessListsForOrganizationWithResponse call
func ParseGetAllAccessListsForOrganizationResponse(rsp *http.Response) (*GetAllAccessListsForOrganizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllAccessListsForOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AccessListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAvailableRegionsResponse parses an HTTP response from a ListAvailableRegionsWithResponse call
func ParseListAvailableRegionsResponse(rsp *http.Response) (*ListAvailableRegionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAvailableRegionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AvailableRegionCombination
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseDeleteTokenForClientResponse parses an HTTP response from a DeleteTokenForClientWithResponse call
func ParseDeleteTokenForClientResponse(rsp *http.Response) (*DeleteTokenForClientResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTokenForClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClientsForOrgResponse parses an HTTP response from a GetClientsForOrgWithResponse call
func ParseGetClientsForOrgResponse(rsp *http.Response) (*GetClientsForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientsForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGenerateTokenForClientResponse parses an HTTP response from a GenerateTokenForClientWithResponse call
func ParseGenerateTokenForClientResponse(rsp *http.Response) (*GenerateTokenForClientResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateTokenForClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCurrentOrganizationResponse parses an HTTP response from a GetCurrentOrganizationWithResponse call
func ParseGetCurrentOrganizationResponse(rsp *http.Response) (*GetCurrentOrganizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListDatabasesResponse parses an HTTP response from a ListDatabasesWithResponse call
func ParseListDatabasesResponse(rsp *http.Response) (*ListDatabasesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDatabasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Database
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseCreateDatabaseResponse parses an HTTP response from a CreateDatabaseWithResponse call
func ParseCreateDatabaseResponse(rsp *http.Response) (*CreateDatabaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDatabaseResponse parses an HTTP response from a GetDatabaseWithResponse call
func ParseGetDatabaseResponse(rsp *http.Response) (*GetDatabaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Database
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseDeleteAddressesOrAccessListForDatabaseResponse parses an HTTP response from a DeleteAddressesOrAccessListForDatabaseWithResponse call
func ParseDeleteAddressesOrAccessListForDatabaseResponse(rsp *http.Response) (*DeleteAddressesOrAccessListForDatabaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAddressesOrAccessListForDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAccessListForDatabaseResponse parses an HTTP response from a GetAccessListForDatabaseWithResponse call
func ParseGetAccessListForDatabaseResponse(rsp *http.Response) (*GetAccessListForDatabaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccessListForDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccessListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAccessListForDatabaseResponse parses an HTTP response from a UpdateAccessListForDatabaseWithResponse call
func ParseUpdateAccessListForDatabaseResponse(rsp *http.Response) (*UpdateAccessListForDatabaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAccessListForDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddAddressesToAccessListForDatabaseResponse parses an HTTP response from a AddAddressesToAccessListForDatabaseWithResponse call
func ParseAddAddressesToAccessListForDatabaseResponse(rsp *http.Response) (*AddAddressesToAccessListForDatabaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddAddressesToAccessListForDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpsertAccessListForDatabaseResponse parses an HTTP response from a UpsertAccessListForDatabaseWithResponse call
func ParseUpsertAccessListForDatabaseResponse(rsp *http.Response) (*UpsertAccessListForDatabaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertAccessListForDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddKeyspaceResponse parses an HTTP response from a AddKeyspaceWithResponse call
func ParseAddKeyspaceResponse(rsp *http.Response) (*AddKeyspaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddKeyspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseParkDatabaseResponse parses an HTTP response from a ParkDatabaseWithResponse call
func ParseParkDatabaseResponse(rsp *http.Response) (*ParkDatabaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ParkDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseResetPasswordResponse parses an HTTP response from a ResetPasswordWithResponse call
func ParseResetPasswordResponse(rsp *http.Response) (*ResetPasswordResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseResizeDatabaseResponse parses an HTTP response from a ResizeDatabaseWithResponse call
func ParseResizeDatabaseResponse(rsp *http.Response) (*ResizeDatabaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResizeDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGenerateSecureBundleURLResponse parses an HTTP response from a GenerateSecureBundleURLWithResponse call
func ParseGenerateSecureBundleURLResponse(rsp *http.Response) (*GenerateSecureBundleURLResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateSecureBundleURLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CredsURL
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseTerminateDatabaseResponse parses an HTTP response from a TerminateDatabaseWithResponse call
func ParseTerminateDatabaseResponse(rsp *http.Response) (*TerminateDatabaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TerminateDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseUnparkDatabaseResponse parses an HTTP response from a UnparkDatabaseWithResponse call
func ParseUnparkDatabaseResponse(rsp *http.Response) (*UnparkDatabaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnparkDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetOrganizationRolesResponse parses an HTTP response from a GetOrganizationRolesWithResponse call
func ParseGetOrganizationRolesResponse(rsp *http.Response) (*GetOrganizationRolesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddOrganizationRoleResponse parses an HTTP response from a AddOrganizationRoleWithResponse call
func ParseAddOrganizationRoleResponse(rsp *http.Response) (*AddOrganizationRoleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddOrganizationRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteOrganizationRoleResponse parses an HTTP response from a DeleteOrganizationRoleWithResponse call
func ParseDeleteOrganizationRoleResponse(rsp *http.Response) (*DeleteOrganizationRoleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOrganizationRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOrganizationRoleResponse parses an HTTP response from a GetOrganizationRoleWithResponse call
func ParseGetOrganizationRoleResponse(rsp *http.Response) (*GetOrganizationRoleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRoleResponse parses an HTTP response from a UpdateRoleWithResponse call
func ParseUpdateRoleResponse(rsp *http.Response) (*UpdateRoleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOrganizationUsersResponse parses an HTTP response from a GetOrganizationUsersWithResponse call
func ParseGetOrganizationUsersResponse(rsp *http.Response) (*GetOrganizationUsersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOrgUsersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInviteUserToOrganizationResponse parses an HTTP response from a InviteUserToOrganizationWithResponse call
func ParseInviteUserToOrganizationResponse(rsp *http.Response) (*InviteUserToOrganizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InviteUserToOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRemoveUserFromOrganizationResponse parses an HTTP response from a RemoveUserFromOrganizationWithResponse call
func ParseRemoveUserFromOrganizationResponse(rsp *http.Response) (*RemoveUserFromOrganizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveUserFromOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOrganizationUserResponse parses an HTTP response from a GetOrganizationUserWithResponse call
func ParseGetOrganizationUserResponse(rsp *http.Response) (*GetOrganizationUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRolesForUserInOrganizationResponse parses an HTTP response from a UpdateRolesForUserInOrganizationWithResponse call
func ParseUpdateRolesForUserInOrganizationResponse(rsp *http.Response) (*UpdateRolesForUserInOrganizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRolesForUserInOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIdOfTenantResponse parses an HTTP response from a IdOfTenantWithResponse call
func ParseIdOfTenantResponse(rsp *http.Response) (*IdOfTenantResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IdOfTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PulsarClustersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPulsarClustersResponse parses an HTTP response from a GetPulsarClustersWithResponse call
func ParseGetPulsarClustersResponse(rsp *http.Response) (*GetPulsarClustersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPulsarClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantClusterPlansResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetStreamingTenantResponse parses an HTTP response from a GetStreamingTenantWithResponse call
func ParseGetStreamingTenantResponse(rsp *http.Response) (*GetStreamingTenantResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamingTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantClusterPlanResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetStreamingProvidersResponse parses an HTTP response from a GetStreamingProvidersWithResponse call
func ParseGetStreamingProvidersResponse(rsp *http.Response) (*GetStreamingProvidersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamingProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProviderRegionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTenantsResponse parses an HTTP response from a GetTenantsWithResponse call
func ParseGetTenantsResponse(rsp *http.Response) (*GetTenantsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTenantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantClusterPlansResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIdOfCreateTenantEndpointResponse parses an HTTP response from a IdOfCreateTenantEndpointWithResponse call
func ParseIdOfCreateTenantEndpointResponse(rsp *http.Response) (*IdOfCreateTenantEndpointResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IdOfCreateTenantEndpointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantClusterPlanResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTeneantLimitUsageResponse parses an HTTP response from a GetTeneantLimitUsageWithResponse call
func ParseGetTeneantLimitUsageResponse(rsp *http.Response) (*GetTeneantLimitUsageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeneantLimitUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteStreamingTenantResponse parses an HTTP response from a DeleteStreamingTenantWithResponse call
func ParseDeleteStreamingTenantResponse(rsp *http.Response) (*DeleteStreamingTenantResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStreamingTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLimitsResponse parses an HTTP response from a GetLimitsWithResponse call
func ParseGetLimitsResponse(rsp *http.Response) (*GetLimitsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLimitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantLimitResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIdListTenantTokensResponse parses an HTTP response from a IdListTenantTokensWithResponse call
func ParseIdListTenantTokensResponse(rsp *http.Response) (*IdListTenantTokensResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IdListTenantTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListOfMaps
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTokenByIDResponse parses an HTTP response from a GetTokenByIDWithResponse call
func ParseGetTokenByIDResponse(rsp *http.Response) (*GetTokenByIDResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTokenByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
