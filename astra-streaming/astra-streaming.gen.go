// Package astrastreaming provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package astrastreaming

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerScopes = "Bearer.Scopes"
)

// Defines values for CryptoConfigConsumerCryptoFailureAction.
const (
	CryptoConfigConsumerCryptoFailureActionCONSUME CryptoConfigConsumerCryptoFailureAction = "CONSUME"
	CryptoConfigConsumerCryptoFailureActionDISCARD CryptoConfigConsumerCryptoFailureAction = "DISCARD"
	CryptoConfigConsumerCryptoFailureActionFAIL    CryptoConfigConsumerCryptoFailureAction = "FAIL"
)

// Defines values for CryptoConfigProducerCryptoFailureAction.
const (
	CryptoConfigProducerCryptoFailureActionFAIL CryptoConfigProducerCryptoFailureAction = "FAIL"
	CryptoConfigProducerCryptoFailureActionSEND CryptoConfigProducerCryptoFailureAction = "SEND"
)

// Defines values for DatabaseAvailableActions.
const (
	AddDatacenters       DatabaseAvailableActions = "addDatacenters"
	AddKeyspace          DatabaseAvailableActions = "addKeyspace"
	AddTable             DatabaseAvailableActions = "addTable"
	GetCreds             DatabaseAvailableActions = "getCreds"
	LaunchMigrationProxy DatabaseAvailableActions = "launchMigrationProxy"
	Park                 DatabaseAvailableActions = "park"
	RemoveKeyspace       DatabaseAvailableActions = "removeKeyspace"
	RemoveMigrationProxy DatabaseAvailableActions = "removeMigrationProxy"
	ResetPassword        DatabaseAvailableActions = "resetPassword"
	Resize               DatabaseAvailableActions = "resize"
	Terminate            DatabaseAvailableActions = "terminate"
	TerminateDatacenter  DatabaseAvailableActions = "terminateDatacenter"
	Unpark               DatabaseAvailableActions = "unpark"
)

// Defines values for DatabaseInfoCloudProvider.
const (
	DatabaseInfoCloudProviderAWS DatabaseInfoCloudProvider = "AWS"
	DatabaseInfoCloudProviderGCP DatabaseInfoCloudProvider = "GCP"
)

// Defines values for DatabaseInfoTier.
const (
	DatabaseInfoTierServerless DatabaseInfoTier = "serverless"
)

// Defines values for DatabaseInfoCreateCloudProvider.
const (
	DatabaseInfoCreateCloudProviderAWS DatabaseInfoCreateCloudProvider = "AWS"
	DatabaseInfoCreateCloudProviderGCP DatabaseInfoCreateCloudProvider = "GCP"
)

// Defines values for DatabaseInfoCreateTier.
const (
	DatabaseInfoCreateTierServerless DatabaseInfoCreateTier = "serverless"
)

// Defines values for PolicyActions.
const (
	DbAllKeyspaceCreate      PolicyActions = "db-all-keyspace-create"
	DbAllKeyspaceDescribe    PolicyActions = "db-all-keyspace-describe"
	DbCql                    PolicyActions = "db-cql"
	DbGraphql                PolicyActions = "db-graphql"
	DbKeyspaceAlter          PolicyActions = "db-keyspace-alter"
	DbKeyspaceAuthorize      PolicyActions = "db-keyspace-authorize"
	DbKeyspaceCreate         PolicyActions = "db-keyspace-create"
	DbKeyspaceDescribe       PolicyActions = "db-keyspace-describe"
	DbKeyspaceDrop           PolicyActions = "db-keyspace-drop"
	DbKeyspaceGrant          PolicyActions = "db-keyspace-grant"
	DbKeyspaceModify         PolicyActions = "db-keyspace-modify"
	DbRest                   PolicyActions = "db-rest"
	DbTableAlter             PolicyActions = "db-table-alter"
	DbTableAuthorize         PolicyActions = "db-table-authorize"
	DbTableCreate            PolicyActions = "db-table-create"
	DbTableDescribe          PolicyActions = "db-table-describe"
	DbTableDrop              PolicyActions = "db-table-drop"
	DbTableGrant             PolicyActions = "db-table-grant"
	DbTableModify            PolicyActions = "db-table-modify"
	DbTableSelect            PolicyActions = "db-table-select"
	OrgAuditsRead            PolicyActions = "org-audits-read"
	OrgBillingRead           PolicyActions = "org-billing-read"
	OrgBillingWrite          PolicyActions = "org-billing-write"
	OrgDbAddpeering          PolicyActions = "org-db-addpeering"
	OrgDbCreate              PolicyActions = "org-db-create"
	OrgDbExpand              PolicyActions = "org-db-expand"
	OrgDbManagemigratorproxy PolicyActions = "org-db-managemigratorproxy"
	OrgDbPasswordreset       PolicyActions = "org-db-passwordreset"
	OrgDbSuspend             PolicyActions = "org-db-suspend"
	OrgDbTerminate           PolicyActions = "org-db-terminate"
	OrgDbView                PolicyActions = "org-db-view"
	OrgExternalAuthRead      PolicyActions = "org-external-auth-read"
	OrgExternalAuthWrite     PolicyActions = "org-external-auth-write"
	OrgNotificationWrite     PolicyActions = "org-notification-write"
	OrgRead                  PolicyActions = "org-read"
	OrgRoleDelete            PolicyActions = "org-role-delete"
	OrgRoleRead              PolicyActions = "org-role-read"
	OrgRoleWrite             PolicyActions = "org-role-write"
	OrgTokenRead             PolicyActions = "org-token-read"
	OrgTokenWrite            PolicyActions = "org-token-write"
	OrgUserRead              PolicyActions = "org-user-read"
	OrgUserWrite             PolicyActions = "org-user-write"
	OrgWrite                 PolicyActions = "org-write"
)

// Defines values for PolicyEffect.
const (
	Allow PolicyEffect = "allow"
)

// Defines values for SinkConfigProcessingGuarantees.
const (
	SinkConfigProcessingGuaranteesATLEASTONCE     SinkConfigProcessingGuarantees = "ATLEAST_ONCE"
	SinkConfigProcessingGuaranteesATMOSTONCE      SinkConfigProcessingGuarantees = "ATMOST_ONCE"
	SinkConfigProcessingGuaranteesEFFECTIVELYONCE SinkConfigProcessingGuarantees = "EFFECTIVELY_ONCE"
)

// Defines values for SinkConfigSourceSubscriptionPosition.
const (
	Earliest SinkConfigSourceSubscriptionPosition = "Earliest"
	Latest   SinkConfigSourceSubscriptionPosition = "Latest"
)

// Defines values for SourceConfigProcessingGuarantees.
const (
	SourceConfigProcessingGuaranteesATLEASTONCE     SourceConfigProcessingGuarantees = "ATLEAST_ONCE"
	SourceConfigProcessingGuaranteesATMOSTONCE      SourceConfigProcessingGuarantees = "ATMOST_ONCE"
	SourceConfigProcessingGuaranteesEFFECTIVELYONCE SourceConfigProcessingGuarantees = "EFFECTIVELY_ONCE"
)

// Defines values for StatusEnum.
const (
	ACTIVE       StatusEnum = "ACTIVE"
	ERROR        StatusEnum = "ERROR"
	HIBERNATED   StatusEnum = "HIBERNATED"
	HIBERNATING  StatusEnum = "HIBERNATING"
	INITIALIZING StatusEnum = "INITIALIZING"
	MAINTENANCE  StatusEnum = "MAINTENANCE"
	PARKED       StatusEnum = "PARKED"
	PARKING      StatusEnum = "PARKING"
	PENDING      StatusEnum = "PENDING"
	PREPARED     StatusEnum = "PREPARED"
	PREPARING    StatusEnum = "PREPARING"
	RESIZING     StatusEnum = "RESIZING"
	RESUMING     StatusEnum = "RESUMING"
	TERMINATED   StatusEnum = "TERMINATED"
	TERMINATING  StatusEnum = "TERMINATING"
	UNKNOWN      StatusEnum = "UNKNOWN"
	UNPARKING    StatusEnum = "UNPARKING"
)

// Defines values for ListDatabasesParamsInclude.
const (
	ListDatabasesParamsIncludeActive        ListDatabasesParamsInclude = "active"
	ListDatabasesParamsIncludeAll           ListDatabasesParamsInclude = "all"
	ListDatabasesParamsIncludeError         ListDatabasesParamsInclude = "error"
	ListDatabasesParamsIncludeHibernated    ListDatabasesParamsInclude = "hibernated"
	ListDatabasesParamsIncludeHibernating   ListDatabasesParamsInclude = "hibernating"
	ListDatabasesParamsIncludeInitializing  ListDatabasesParamsInclude = "initializing"
	ListDatabasesParamsIncludeMaintenance   ListDatabasesParamsInclude = "maintenance"
	ListDatabasesParamsIncludeNonterminated ListDatabasesParamsInclude = "nonterminated"
	ListDatabasesParamsIncludeParked        ListDatabasesParamsInclude = "parked"
	ListDatabasesParamsIncludeParking       ListDatabasesParamsInclude = "parking"
	ListDatabasesParamsIncludePending       ListDatabasesParamsInclude = "pending"
	ListDatabasesParamsIncludePrepared      ListDatabasesParamsInclude = "prepared"
	ListDatabasesParamsIncludePreparing     ListDatabasesParamsInclude = "preparing"
	ListDatabasesParamsIncludeResizing      ListDatabasesParamsInclude = "resizing"
	ListDatabasesParamsIncludeResuming      ListDatabasesParamsInclude = "resuming"
	ListDatabasesParamsIncludeTerminated    ListDatabasesParamsInclude = "terminated"
	ListDatabasesParamsIncludeTerminating   ListDatabasesParamsInclude = "terminating"
	ListDatabasesParamsIncludeUnparking     ListDatabasesParamsInclude = "unparking"
)

// Defines values for ListDatabasesParamsProvider.
const (
	ALL   ListDatabasesParamsProvider = "ALL"
	AWS   ListDatabasesParamsProvider = "AWS"
	AZURE ListDatabasesParamsProvider = "AZURE"
	GCP   ListDatabasesParamsProvider = "GCP"
)

// AccessListConfigurations defines model for AccessListConfigurations.
type AccessListConfigurations struct {
	AccessListEnabled bool `json:"accessListEnabled"`
}

// AccessListRequest The model used to build an access list.
type AccessListRequest struct {
	// Addresses A listing of the allowed addresses
	Addresses      *[]AddressRequest         `json:"addresses,omitempty"`
	Configurations *AccessListConfigurations `json:"configurations,omitempty"`
}

// AccessListResponse The response for a requested access list.
type AccessListResponse struct {
	// Addresses A listing of the allowed addresses
	Addresses      *[]AddressResponse        `json:"addresses,omitempty"`
	Configurations *AccessListConfigurations `json:"configurations,omitempty"`

	// DatabaseId The unique identifier of the database
	DatabaseId *openapi_types.UUID `json:"databaseId,omitempty"`

	// OrganizationId The unique identifier of the organization
	OrganizationId *openapi_types.UUID `json:"organizationId,omitempty"`
}

// AddressRequest The model used to build an address for an access list.
type AddressRequest struct {
	// Address The address (IP address and subnet mask in CIDR notation) of the address to allow
	Address string `json:"address"`

	// Description Description of this addresses use
	Description string `json:"description"`

	// Enabled The indication if the access address is enabled or not
	Enabled bool `json:"enabled"`
}

// AddressResponse The response for a requested address in an access list.
type AddressResponse struct {
	// Address The address (IP address and subnet mask in CIDR notation) of the address to allow.
	Address *string `json:"address,omitempty"`

	// Description Description of this addresses use
	Description *string `json:"description,omitempty"`

	// Enabled The indication if the access address is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`

	// LastUpdateDateTime The last update date/time for the access list.
	LastUpdateDateTime *time.Time `json:"lastUpdateDateTime,omitempty"`
}

// AvailableRegionCombination AvailableRegionCombination defines a tier, cloud provider, and region combination.
type AvailableRegionCombination struct {
	CapacityUnitsLimit              int    `json:"capacityUnitsLimit"`
	CapacityUnitsUsed               int    `json:"capacityUnitsUsed"`
	CloudProvider                   string `json:"cloudProvider"`
	Cost                            Costs  `json:"cost"`
	DatabaseCountLimit              int    `json:"databaseCountLimit"`
	DatabaseCountUsed               int    `json:"databaseCountUsed"`
	DefaultStoragePerCapacityUnitGb int    `json:"defaultStoragePerCapacityUnitGb"`
	Region                          string `json:"region"`
	Tier                            string `json:"tier"`
}

// BatchSourceConfig defines model for BatchSourceConfig.
type BatchSourceConfig struct {
	DiscoveryTriggererClassName *string                            `json:"discoveryTriggererClassName,omitempty"`
	DiscoveryTriggererConfig    *map[string]map[string]interface{} `json:"discoveryTriggererConfig,omitempty"`
}

// CapacityUnits CapacityUnits is used to horizontally scale a database.
type CapacityUnits struct {
	// CapacityUnits CapacityUnits can be increased by a max of three additional capacity units per operation. Reducing capacity units is not currently supported.
	CapacityUnits *int `json:"capacityUnits,omitempty"`
}

// ClientRole An individual clientID and associated roles.
type ClientRole struct {
	// ClientId the clientID
	ClientId *string   `json:"clientId,omitempty"`
	Roles    *[]string `json:"roles,omitempty"`
}

// ClientRoleList The response for a requested token.
type ClientRoleList struct {
	// Clients a list of clientId and associated roles.
	Clients *[]ClientRole `json:"clients,omitempty"`
}

// CloudProviderRegionResponse CloudProviderRegionResponse is a map of cloud provider and its available regions.
type CloudProviderRegionResponse map[string][]string

// ClusterResponse ClusterResponse is the response struct for a cluster
type ClusterResponse struct {
	PulsarURL           *string `json:"brokerServiceUrl,omitempty"`
	CloudProvider       *string `json:"cloudProvider,omitempty"`
	CloudProviderRegion *string `json:"cloudRegion,omitempty"`
	ClusterName         *string `json:"clusterName,omitempty"`
	ClusterType         *string `json:"clusterType,omitempty"`
	AdminURL            *string `json:"webServiceUrl,omitempty"`
	WebsocketURL        *string `json:"websocketUrl,omitempty"`
}

// ConsumerConfig defines model for ConsumerConfig.
type ConsumerConfig struct {
	ConsumerProperties *map[string]string `json:"consumerProperties,omitempty"`
	CryptoConfig       *CryptoConfig      `json:"cryptoConfig,omitempty"`
	PoolMessages       *bool              `json:"poolMessages,omitempty"`
	ReceiverQueueSize  *int32             `json:"receiverQueueSize,omitempty"`
	RegexPattern       *bool              `json:"regexPattern,omitempty"`
	SchemaProperties   *map[string]string `json:"schemaProperties,omitempty"`
	SchemaType         *string            `json:"schemaType,omitempty"`
	SerdeClassName     *string            `json:"serdeClassName,omitempty"`
}

// Costs defines model for Costs.
type Costs struct {
	CostPerDayCents         *float64 `json:"costPerDayCents,omitempty"`
	CostPerDayParkedCents   *float64 `json:"costPerDayParkedCents,omitempty"`
	CostPerHourCents        *float64 `json:"costPerHourCents,omitempty"`
	CostPerHourParkedCents  *float64 `json:"costPerHourParkedCents,omitempty"`
	CostPerMinCents         *float64 `json:"costPerMinCents,omitempty"`
	CostPerMinParkedCents   *float64 `json:"costPerMinParkedCents,omitempty"`
	CostPerMonthCents       *float64 `json:"costPerMonthCents,omitempty"`
	CostPerMonthParkedCents *float64 `json:"costPerMonthParkedCents,omitempty"`
}

// CreateRoleRequest The createRole model.
type CreateRoleRequest struct {
	// Name The name for your custom role in your organization.
	Name string `json:"name"`

	// Policy A policy for a role in Astra.
	Policy Policy `json:"policy"`
}

// CreateTenantTokenV3Request CreateTenantTokenV3Request requests a new Pulsar token to be created
type CreateTenantTokenV3Request struct {
	// Exp Time duration before the token expires.  Expects a string format with a number and unit.  For example, '5m', '2h', '10d', etc.
	Exp  *string `json:"exp,omitempty"`
	Role *string `json:"role,omitempty"`
	Type *string `json:"type,omitempty"`
}

// CreateTenantTokenV3Response CreateTenantTokenV3Response wraps a newly generated Pulsar JWT token
type CreateTenantTokenV3Response struct {
	// ID ID unique within the scope of a Pulsar tenant
	ID *string `json:"id,omitempty"`

	// Rolename Rolename used for Pulsar authorization
	Rolename *string `json:"rolename,omitempty"`

	// Token JWT token string
	Token *string `json:"token,omitempty"`
}

// CredsURL CredsURL from which the creds zip may be downloaded.
type CredsURL struct {
	// DownloadURL DownloadURL is only valid for about 5 minutes.
	DownloadURL string `json:"downloadURL"`

	// DownloadURLInternal Internal DownloadURL is only valid for about 5 minutes.
	DownloadURLInternal *string `json:"downloadURLInternal,omitempty"`

	// DownloadURLMigrationProxy Migration Proxy DownloadURL is only valid for about 5 minutes.
	DownloadURLMigrationProxy *string `json:"downloadURLMigrationProxy,omitempty"`

	// DownloadURLMigrationProxyInternal Internal Migration Proxy DownloadURL is only valid for about 5 minutes.
	DownloadURLMigrationProxyInternal *string `json:"downloadURLMigrationProxyInternal,omitempty"`
}

// CryptoConfig defines model for CryptoConfig.
type CryptoConfig struct {
	ConsumerCryptoFailureAction *CryptoConfigConsumerCryptoFailureAction `json:"consumerCryptoFailureAction,omitempty"`
	CryptoKeyReaderClassName    *string                                  `json:"cryptoKeyReaderClassName,omitempty"`
	CryptoKeyReaderConfig       *map[string]map[string]interface{}       `json:"cryptoKeyReaderConfig,omitempty"`
	EncryptionKeys              *[]string                                `json:"encryptionKeys,omitempty"`
	ProducerCryptoFailureAction *CryptoConfigProducerCryptoFailureAction `json:"producerCryptoFailureAction,omitempty"`
}

// CryptoConfigConsumerCryptoFailureAction defines model for CryptoConfig.ConsumerCryptoFailureAction.
type CryptoConfigConsumerCryptoFailureAction string

// CryptoConfigProducerCryptoFailureAction defines model for CryptoConfig.ProducerCryptoFailureAction.
type CryptoConfigProducerCryptoFailureAction string

// Database Database contains the key information about a database.
type Database struct {
	AvailableActions *[]DatabaseAvailableActions `json:"availableActions,omitempty"`
	CqlshUrl         *string                     `json:"cqlshUrl,omitempty"`

	// CreationTime CreationTime in ISO RFC3339 format
	CreationTime    *string `json:"creationTime,omitempty"`
	DataEndpointUrl *string `json:"dataEndpointUrl,omitempty"`
	GrafanaUrl      *string `json:"grafanaUrl,omitempty"`
	GraphqlUrl      *string `json:"graphqlUrl,omitempty"`
	Id              string  `json:"id"`

	// Info DatabaseInfo is the user-provided information describing a database.
	Info DatabaseInfo `json:"info"`

	// Message Message to the customer about the cluster.
	Message *string    `json:"message,omitempty"`
	OrgId   string     `json:"orgId"`
	OwnerId string     `json:"ownerId"`
	Status  StatusEnum `json:"status"`

	// Storage Storage contains the information about how much storage space a cluster has available.
	Storage   *Storage `json:"storage,omitempty"`
	StudioUrl *string  `json:"studioUrl,omitempty"`

	// TerminationTime TerminationTime in ISO RFC3339 format
	TerminationTime *string `json:"terminationTime,omitempty"`
}

// DatabaseAvailableActions defines model for Database.AvailableActions.
type DatabaseAvailableActions string

// DatabaseInfo DatabaseInfo is the user-provided information describing a database.
type DatabaseInfo struct {
	// AdditionalKeyspaces Additional keyspaces names in database.
	AdditionalKeyspaces *[]string `json:"additionalKeyspaces,omitempty"`

	// CapacityUnits Capacity units were used for classic databases, but are not used for serverless databases. Enter 1 CU for serverless databases. Classic databases can no longer be created with the DevOps API.
	CapacityUnits *int `json:"capacityUnits,omitempty"`

	// CloudProvider This is the cloud provider where the database lives.
	CloudProvider *DatabaseInfoCloudProvider `json:"cloudProvider,omitempty"`

	// Keyspace Keyspace name in database.
	Keyspace *string `json:"keyspace,omitempty"`

	// Name Name of the database--user friendly identifier.
	Name *string `json:"name,omitempty"`

	// Password Password for the user to access the database.
	Password *string `json:"password,omitempty"`

	// Region Region refers to the cloud region.
	Region *string `json:"region,omitempty"`

	// Tier With the exception of classic databases, all databases are serverless. Classic databases can no longer be created with the DevOps API.
	Tier *DatabaseInfoTier `json:"tier,omitempty"`

	// User User is the user to access the database.
	User *string `json:"user,omitempty"`
}

// DatabaseInfoCloudProvider This is the cloud provider where the database lives.
type DatabaseInfoCloudProvider string

// DatabaseInfoTier With the exception of classic databases, all databases are serverless. Classic databases can no longer be created with the DevOps API.
type DatabaseInfoTier string

// DatabaseInfoCreate DatabaseInfo is the user-provided information describing a database.
type DatabaseInfoCreate struct {
	// CapacityUnits Capacity units were used for classic databases, but are not used for serverless databases. Enter 1 CU for serverless databases. Classic databases can no longer be created with the DevOps API.
	CapacityUnits int `json:"capacityUnits"`

	// CloudProvider This is the cloud provider where the database lives.
	CloudProvider DatabaseInfoCreateCloudProvider `json:"cloudProvider"`

	// Keyspace Keyspace name in database.
	Keyspace string `json:"keyspace"`

	// Name Name of the database--user friendly identifier.
	Name string `json:"name"`

	// Region Region refers to the cloud region.
	Region string `json:"region"`

	// Tier With the exception of classic databases, all databases are serverless. Classic databases can no longer be created with the DevOps API.
	Tier DatabaseInfoCreateTier `json:"tier"`
}

// DatabaseInfoCreateCloudProvider This is the cloud provider where the database lives.
type DatabaseInfoCreateCloudProvider string

// DatabaseInfoCreateTier With the exception of classic databases, all databases are serverless. Classic databases can no longer be created with the DevOps API.
type DatabaseInfoCreateTier string

// Error ModelError information that is returned to users.
type Error struct {
	// ID API specific error code.
	ID *int `json:"ID,omitempty"`

	// Message User-friendly description of error.
	Message string `json:"message"`
}

// Errors Errors is a collection of individual Error objects.
type Errors struct {
	Errors []Error `json:"errors"`
}

// GenerateTokenBody The POST body to generate a token.
type GenerateTokenBody struct {
	// Roles The roles for which the token will be generated.
	Roles []string `json:"roles"`
}

// GenerateTokenResponse The response for a requested token.
type GenerateTokenResponse struct {
	// ClientId The ID of the client (UUID).
	ClientId string `json:"clientId"`

	// OrgId The UUID of the organization.
	OrgId string `json:"orgId"`

	// Roles The roles for which the token will be generated.
	Roles []string `json:"roles"`

	// Secret The secret token.
	Secret string `json:"secret"`

	// Token AstraCS:clientId:hex(sha256(secret))
	Token *string `json:"token,omitempty"`
}

// GetOrgUsersResponse defines model for GetOrgUsersResponse.
type GetOrgUsersResponse struct {
	OrgID   string `json:"orgID"`
	OrgName string `json:"orgName"`

	// Users an array of users in the organization
	Users []UserResponse `json:"users"`
}

// LimitResponse LimitResponse is a response for tenant limits
type LimitResponse struct {
	NamespaceLimit         *int64                       `json:"namespace_limit,omitempty"`
	TopicPerNamespaceLimit *int64                       `json:"topic_per_namespace_limit,omitempty"`
	Usage                  *[]TenantNamespaceLimitUsage `json:"usage,omitempty"`
}

// Organization An organization.
type Organization struct {
	// Id The organization UUID.
	Id string `json:"id"`
}

// Policy A policy for a role in Astra.
type Policy struct {
	// Actions The actions this policy can take. Example actions: 'org-billing-write' 'db-keyspace-create'.
	Actions []PolicyActions `json:"actions"`

	// Description A description of this policy.
	Description string `json:"description"`

	// Effect Effect this policy will have on the provided resource.
	Effect PolicyEffect `json:"effect"`

	// Resources The resources this policy can manipulate.
	Resources []string `json:"resources"`
}

// PolicyActions defines model for Policy.Actions.
type PolicyActions string

// PolicyEffect Effect this policy will have on the provided resource.
type PolicyEffect string

// ProducerConfig defines model for ProducerConfig.
type ProducerConfig struct {
	BatchBuilder                       *string       `json:"batchBuilder,omitempty"`
	CryptoConfig                       *CryptoConfig `json:"cryptoConfig,omitempty"`
	MaxPendingMessages                 *int32        `json:"maxPendingMessages,omitempty"`
	MaxPendingMessagesAcrossPartitions *int32        `json:"maxPendingMessagesAcrossPartitions,omitempty"`
	UseThreadLocalProducers            *bool         `json:"useThreadLocalProducers,omitempty"`
}

// Resources defines model for Resources.
type Resources struct {
	Cpu  *float64 `json:"cpu,omitempty"`
	Disk *int64   `json:"disk,omitempty"`
	Ram  *int64   `json:"ram,omitempty"`
}

// ResponseErr ResponseErr error struct for Pulsar compliant HTTP responses
type ResponseErr struct {
	Error *string `json:"reason,omitempty"`
}

// Role Details of a user role and its policy details.
type Role struct {
	// Id The unique system generated identifier of the role.
	Id *string `json:"id,omitempty"`

	// LastUpdateDatetime The date and time of the last update on the role.
	LastUpdateDatetime *time.Time `json:"last_update_datetime,omitempty"`

	// LastUpdateUserid The userID of the user who last updated the role.
	LastUpdateUserid *string `json:"last_update_userid,omitempty"`

	// Name The name of the role.
	Name *string `json:"name,omitempty"`

	// Policy A policy for a role in Astra.
	Policy *Policy `json:"policy,omitempty"`
}

// RoleInviteRequest The roleInvite model.
type RoleInviteRequest struct {
	Roles []string `json:"roles"`
}

// Roles An array of roles.
type Roles = []Role

// SinkConfig defines model for SinkConfig.
type SinkConfig struct {
	Archive                      *string                               `json:"archive,omitempty"`
	AutoAck                      *bool                                 `json:"autoAck,omitempty"`
	ClassName                    *string                               `json:"className,omitempty"`
	CleanupSubscription          *bool                                 `json:"cleanupSubscription,omitempty"`
	Configs                      *map[string]interface{}               `json:"configs,omitempty"`
	CustomRuntimeOptions         *string                               `json:"customRuntimeOptions,omitempty"`
	DeadLetterTopic              *string                               `json:"deadLetterTopic,omitempty"`
	InputSpecs                   *map[string]ConsumerConfig            `json:"inputSpecs,omitempty"`
	Inputs                       *[]string                             `json:"inputs,omitempty"`
	MaxMessageRetries            *int32                                `json:"maxMessageRetries,omitempty"`
	Name                         *string                               `json:"name,omitempty"`
	Namespace                    *string                               `json:"namespace,omitempty"`
	NegativeAckRedeliveryDelayMs *int64                                `json:"negativeAckRedeliveryDelayMs,omitempty"`
	Parallelism                  *int32                                `json:"parallelism,omitempty"`
	ProcessingGuarantees         *SinkConfigProcessingGuarantees       `json:"processingGuarantees,omitempty"`
	Resources                    *Resources                            `json:"resources,omitempty"`
	RetainKeyOrdering            *bool                                 `json:"retainKeyOrdering,omitempty"`
	RetainOrdering               *bool                                 `json:"retainOrdering,omitempty"`
	RuntimeFlags                 *string                               `json:"runtimeFlags,omitempty"`
	Secrets                      *map[string]map[string]interface{}    `json:"secrets,omitempty"`
	SinkType                     *string                               `json:"sinkType,omitempty"`
	SourceSubscriptionName       *string                               `json:"sourceSubscriptionName,omitempty"`
	SourceSubscriptionPosition   *SinkConfigSourceSubscriptionPosition `json:"sourceSubscriptionPosition,omitempty"`
	Tenant                       *string                               `json:"tenant,omitempty"`
	TimeoutMs                    *int64                                `json:"timeoutMs,omitempty"`
	TopicToSchemaProperties      *map[string]string                    `json:"topicToSchemaProperties,omitempty"`
	TopicToSchemaType            *map[string]string                    `json:"topicToSchemaType,omitempty"`
	TopicToSerdeClassName        *map[string]string                    `json:"topicToSerdeClassName,omitempty"`
	TopicsPattern                *string                               `json:"topicsPattern,omitempty"`
}

// SinkConfigProcessingGuarantees defines model for SinkConfig.ProcessingGuarantees.
type SinkConfigProcessingGuarantees string

// SinkConfigSourceSubscriptionPosition defines model for SinkConfig.SourceSubscriptionPosition.
type SinkConfigSourceSubscriptionPosition string

// SourceConfig defines model for SourceConfig.
type SourceConfig struct {
	Archive              *string                            `json:"archive,omitempty"`
	BatchBuilder         *string                            `json:"batchBuilder,omitempty"`
	BatchSourceConfig    *BatchSourceConfig                 `json:"batchSourceConfig,omitempty"`
	ClassName            *string                            `json:"className,omitempty"`
	Configs              *map[string]map[string]interface{} `json:"configs,omitempty"`
	CustomRuntimeOptions *string                            `json:"customRuntimeOptions,omitempty"`
	Name                 *string                            `json:"name,omitempty"`
	Namespace            *string                            `json:"namespace,omitempty"`
	Parallelism          *int32                             `json:"parallelism,omitempty"`
	ProcessingGuarantees *SourceConfigProcessingGuarantees  `json:"processingGuarantees,omitempty"`
	ProducerConfig       *ProducerConfig                    `json:"producerConfig,omitempty"`
	Resources            *Resources                         `json:"resources,omitempty"`
	RuntimeFlags         *string                            `json:"runtimeFlags,omitempty"`
	SchemaType           *string                            `json:"schemaType,omitempty"`
	Secrets              *map[string]map[string]interface{} `json:"secrets,omitempty"`
	SerdeClassName       *string                            `json:"serdeClassName,omitempty"`
	Tenant               *string                            `json:"tenant,omitempty"`
	TopicName            *string                            `json:"topicName,omitempty"`
}

// SourceConfigProcessingGuarantees defines model for SourceConfig.ProcessingGuarantees.
type SourceConfigProcessingGuarantees string

// StatusEnum defines model for StatusEnum.
type StatusEnum string

// Storage Storage contains the information about how much storage space a cluster has available.
type Storage struct {
	// NodeCount NodeCount for the cluster.
	NodeCount int `json:"nodeCount"`

	// ReplicationFactor ReplicationFactor is the number of nodes storing a piece of data.
	ReplicationFactor int `json:"replicationFactor"`

	// TotalStorage TotalStorage of the cluster in GB.
	TotalStorage int `json:"totalStorage"`

	// UsedStorage UsedStorage in GB.
	UsedStorage *int `json:"usedStorage,omitempty"`
}

// TenantClusterPlanResponse TenantClusterPlanResponse tenant per cluster access
// For initial creation so namespace and topic are added
type TenantClusterPlanResponse struct {
	OrgName                *string `json:"astraOrgGUID,omitempty"`
	PulsarURL              *string `json:"brokerServiceUrl,omitempty"`
	CloudProvider          *string `json:"cloudProvider,omitempty"`
	CloudProviderCode      *string `json:"cloudProviderCode,omitempty"`
	CloudProviderRegion    *string `json:"cloudRegion,omitempty"`
	ClusterName            *string `json:"clusterName,omitempty"`
	Id                     *string `json:"id,omitempty"`
	PulsarJVMVersion       *string `json:"jvmVersion,omitempty"`
	Namespace              *string `json:"namespace,omitempty"`
	Plan                   *string `json:"plan,omitempty"`
	PlanCode               *string `json:"planCode,omitempty"`
	TenantPulsarToken      *string `json:"pulsarToken,omitempty"`
	PulsarVersion          *string `json:"pulsarVersion,omitempty"`
	Status                 *string `json:"status,omitempty"`
	TenantName             *string `json:"tenantName,omitempty"`
	TopicName              *string `json:"topic,omitempty"`
	UserMetricsURL         *string `json:"userMetricsUrl,omitempty"`
	AdminURL               *string `json:"webServiceUrl,omitempty"`
	WebsocketQueryParamURL *string `json:"websocketQueryParamUrl,omitempty"`
	WebsocketURL           *string `json:"websocketUrl,omitempty"`
}

// TenantNamespaceLimitUsage TenantNamespaceLimitUsage holds usages for enforcing limits
type TenantNamespaceLimitUsage struct {
	Namespace *string   `json:"namespace,omitempty"`
	Topics    *[]string `json:"topics,omitempty"`
}

// TenantToken defines model for TenantToken.
type TenantToken struct {
	Iat     *int    `json:"iat,omitempty"`
	Iss     *string `json:"iss,omitempty"`
	Sub     *string `json:"sub,omitempty"`
	TokenID *string `json:"tokenid,omitempty"`
}

// UpdateRoleRequest The updateRole model
type UpdateRoleRequest struct {
	// Name The name of the custom role you want to update in your organization.
	Name string `json:"name"`

	// Policy A policy for a role in Astra.
	Policy Policy `json:"policy"`
}

// Usage Usage is the data usage per single tenant
type Usage struct {
	BacklogStorageSize  *float64   `json:"backlogStorageByteSize,omitempty"`
	ConsumerCount       *float64   `json:"consumerCount,omitempty"`
	MsgBacklog          *float64   `json:"msgBacklogNumber,omitempty"`
	MsgRateIn           *float64   `json:"msgRateIn,omitempty"`
	MsgRateOut          *float64   `json:"msgRateOut,omitempty"`
	Name                *string    `json:"name,omitempty"`
	ProducerCount       *float64   `json:"producerCount,omitempty"`
	StorageSize         *float64   `json:"storageSize,omitempty"`
	SubscriptionCount   *float64   `json:"subscriptionCount,omitempty"`
	SubscriptionDelayed *float64   `json:"subscriptionDelayed,omitempty"`
	ThroughputIn        *float64   `json:"throughputIn,omitempty"`
	ThroughputOut       *float64   `json:"throughputOut,omitempty"`
	TotalBytesIn        *float64   `json:"totalBytesIn,omitempty"`
	TotalBytesOut       *float64   `json:"totalBytesOut,omitempty"`
	TotalMessagesIn     *float64   `json:"totalMessagesIn,omitempty"`
	TotalMessagesOut    *float64   `json:"totalMessagesOut,omitempty"`
	UpdatedAt           *time.Time `json:"updatedAt,omitempty"`
}

// UserInvite The userInvite model
type UserInvite struct {
	// Email The email of the user being invited
	Email string `json:"email"`

	// OrgID The unique system generated identifier of the organization
	OrgID string   `json:"orgID"`
	Roles []string `json:"roles"`
}

// UserPassword UserPassword specifies a username and new password. The specified password will be updated for the specified database user.
type UserPassword struct {
	// Password New password (min 6 characters)
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UserResponse defines model for UserResponse.
type UserResponse struct {
	Email *string `json:"email,omitempty"`

	// Roles an array of roles the user belongs to for an organization
	Roles *[]Role `json:"roles,omitempty"`

	// Status The status of a user within an organization either active or invited
	Status *string `json:"status,omitempty"`
	UserID string  `json:"userID"`
}

// ValidationResponse The response for validation checks.
type ValidationResponse struct {
	Valid              *bool     `json:"valid,omitempty"`
	ValidationFailures *[]string `json:"validationFailures,omitempty"`
}

// CdcRequest cdcRequest model
type CdcRequest struct {
	// DatabaseId Astra database id
	DatabaseId string `json:"databaseId"`

	// DatabaseName Astra database name
	DatabaseName string `json:"databaseName"`

	// Keyspace keyspace
	Keyspace string `json:"keyspace"`

	// OrgId The unique system generated identifier of the organization
	OrgId string `json:"orgId"`

	// TableName tableName
	TableName string `json:"tableName"`

	// TopicPartitions Number of partitions for pulsar topic (e.g. 3)
	TopicPartitions int `json:"topicPartitions"`
}

// CreatedTenantResponse defines model for createdTenantResponse.
type CreatedTenantResponse struct {
	// Body TenantClusterPlanResponse tenant per cluster access
	// For initial creation so namespace and topic are added
	Body *TenantClusterPlanResponse `json:"Body,omitempty"`
}

// ErrorResponse defines model for errorResponse.
type ErrorResponse struct {
	// Body ResponseErr error struct for Pulsar compliant HTTP responses
	Body ResponseErr `json:"Body"`
}

// PulsarClustersResponse defines model for pulsarClustersResponse.
type PulsarClustersResponse struct {
	Body *[]ClusterResponse `json:"Body,omitempty"`
}

// StatsResponse defines model for statsResponse.
type StatsResponse struct {
	Body *map[string]Usage `json:"Body,omitempty"`
}

// TenantClusterPlansResponse defines model for tenantClusterPlansResponse.
type TenantClusterPlansResponse = []interface{}

// TenantLimitResponse defines model for tenantLimitResponse.
type TenantLimitResponse struct {
	// Body LimitResponse is a response for tenant limits
	Body *LimitResponse `json:"Body,omitempty"`
}

// TenantRequest defines model for tenantRequest.
type TenantRequest struct {
	CloudProvider *string `json:"cloudProvider,omitempty"`
	CloudRegion   *string `json:"cloudRegion,omitempty"`
	ClusterName   *string `json:"clusterName,omitempty"`
	OrgID         *string `json:"orgID,omitempty"`
	OrgName       *string `json:"orgName,omitempty"`
	TenantName    *string `json:"tenantName,omitempty"`
	UserEmail     *string `json:"userEmail,omitempty"`
}

// NewTokenResponse NewTokenResponse is the json object for token server response
type NewTokenResponse struct {
	ID      *string `json:"id,omitempty"`
	Subject *string `json:"subject,omitempty"`
	Token   *string `json:"token,omitempty"`
}

// AddressesQueryParam defines model for AddressesQueryParam.
type AddressesQueryParam = []string

// ClientIdParam defines model for ClientIdParam.
type ClientIdParam = string

// DatabaseIdParam defines model for DatabaseIdParam.
type DatabaseIdParam = string

// KeyspaceNameParam defines model for KeyspaceNameParam.
type KeyspaceNameParam = string

// RoleIdParam defines model for RoleIdParam.
type RoleIdParam = string

// UserIdParam defines model for UserIdParam.
type UserIdParam = string

// BadRequest Errors is a collection of individual Error objects.
type BadRequest = Errors

// Conflict Errors is a collection of individual Error objects.
type Conflict = Errors

// Forbidden Errors is a collection of individual Error objects.
type Forbidden = Errors

// NotFound Errors is a collection of individual Error objects.
type NotFound = Errors

// ServerError Errors is a collection of individual Error objects.
type ServerError = Errors

// Unauthorized Errors is a collection of individual Error objects.
type Unauthorized = Errors

// UnprocessableEntity Errors is a collection of individual Error objects.
type UnprocessableEntity = Errors

// DeleteNamespaceParams defines parameters for DeleteNamespace.
type DeleteNamespaceParams struct {
	Force         *bool `form:"force,omitempty" json:"force,omitempty"`
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetTopicsParams defines parameters for GetTopics.
type GetTopicsParams struct {
	// Authorization Astra JWT token
	Authorization string `json:"Authorization"`

	// XDataStaxPulsarCluster Astra Streaming Cluster Name.
	XDataStaxPulsarCluster *string `json:"X-DataStax-Pulsar-Cluster,omitempty"`
}

// DeleteTopicParams defines parameters for DeleteTopic.
type DeleteTopicParams struct {
	// XDataStaxCurrentOrg Astra Org ID.
	XDataStaxCurrentOrg *string `json:"X-DataStax-Current-Org,omitempty"`

	// Authorization Astra JWT token
	Authorization string `json:"Authorization"`

	// XDataStaxPulsarCluster Astra Streaming Cluster Name.
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
}

// CreateTopicParams defines parameters for CreateTopic.
type CreateTopicParams struct {
	// XDataStaxCurrentOrg Astra Org ID.
	XDataStaxCurrentOrg *string `json:"X-DataStax-Current-Org,omitempty"`

	// Authorization Astra JWT token
	Authorization string `json:"Authorization"`

	// XDataStaxPulsarCluster Astra Streaming Cluster Name.
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
}

// DeleteCDCParams defines parameters for DeleteCDC.
type DeleteCDCParams struct {
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
	Authorization          string `json:"authorization"`
}

// GetCDCParams defines parameters for GetCDC.
type GetCDCParams struct {
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
	Authorization          string `json:"authorization"`
}

// EnableCDCParams defines parameters for EnableCDC.
type EnableCDCParams struct {
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
	Authorization          string `json:"authorization"`
}

// DeleteSinkParams defines parameters for DeleteSink.
type DeleteSinkParams struct {
	// XDataStaxCurrentOrg Astra Org ID.
	XDataStaxCurrentOrg string `json:"X-DataStax-Current-Org"`

	// Authorization Astra JWT token
	Authorization string `json:"Authorization"`

	// XDataStaxPulsarCluster Astra Streaming Cluster Name.
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
}

// GetSinksParams defines parameters for GetSinks.
type GetSinksParams struct {
	// Authorization Astra JWT token
	Authorization string `json:"Authorization"`

	// XDataStaxPulsarCluster Astra Streaming Cluster Name.
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
}

// CreateSinkJSONParams defines parameters for CreateSinkJSON.
type CreateSinkJSONParams struct {
	// Authorization Astra JWT token
	Authorization string `json:"Authorization"`

	// XDataStaxCurrentOrg Astra Org ID.
	XDataStaxCurrentOrg string `json:"X-DataStax-Current-Org"`

	// XDataStaxPulsarCluster Astra Streaming Cluster Name.
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
}

// UpdateSinkJSONParams defines parameters for UpdateSinkJSON.
type UpdateSinkJSONParams struct {
	// Authorization Astra JWT token
	Authorization string `json:"Authorization"`

	// XDataStaxCurrentOrg Astra Org ID.
	XDataStaxCurrentOrg string `json:"X-DataStax-Current-Org"`

	// XDataStaxPulsarCluster Astra Streaming Cluster Name.
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
}

// CreateSourceJSONParams defines parameters for CreateSourceJSON.
type CreateSourceJSONParams struct {
	// Authorization Astra JWT token
	Authorization string `json:"Authorization"`

	// XDataStaxCurrentOrg Astra Org ID.
	XDataStaxCurrentOrg string `json:"X-DataStax-Current-Org"`

	// XDataStaxPulsarCluster Astra Streaming Cluster Name.
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
}

// UpdateSourceJSONParams defines parameters for UpdateSourceJSON.
type UpdateSourceJSONParams struct {
	// Authorization Astra JWT token
	Authorization string `json:"Authorization"`

	// XDataStaxCurrentOrg Astra Org ID.
	XDataStaxCurrentOrg string `json:"X-DataStax-Current-Org"`

	// XDataStaxPulsarCluster Astra Streaming Cluster Name.
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
}

// GetBuiltInSinksParams defines parameters for GetBuiltInSinks.
type GetBuiltInSinksParams struct {
	// Authorization Astra JWT token
	Authorization string `json:"Authorization"`

	// XDataStaxPulsarCluster Astra Streaming Cluster Name.
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
}

// ListDatabasesParams defines parameters for ListDatabases.
type ListDatabasesParams struct {
	// Include Allows filtering so that databases in listed states are returned.
	Include *ListDatabasesParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Provider Allows filtering so that databases from a given provider are returned.
	Provider *ListDatabasesParamsProvider `form:"provider,omitempty" json:"provider,omitempty"`

	// StartingAfter Optional parameter for pagination purposes. Used as this value for starting retrieving a specific page of results.
	StartingAfter *string `form:"starting_after,omitempty" json:"starting_after,omitempty"`

	// Limit Optional parameter for pagination purposes. Specify the number of items for one page of data.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ListDatabasesParamsInclude defines parameters for ListDatabases.
type ListDatabasesParamsInclude string

// ListDatabasesParamsProvider defines parameters for ListDatabases.
type ListDatabasesParamsProvider string

// DeleteAddressesOrAccessListForDatabaseParams defines parameters for DeleteAddressesOrAccessListForDatabase.
type DeleteAddressesOrAccessListForDatabaseParams struct {
	// Addresses Array of addresses
	Addresses *AddressesQueryParam `form:"addresses,omitempty" json:"addresses,omitempty"`
}

// AddAddressesToAccessListForDatabaseJSONBody defines parameters for AddAddressesToAccessListForDatabase.
type AddAddressesToAccessListForDatabaseJSONBody = []AddressRequest

// TerminateDatabaseParams defines parameters for TerminateDatabase.
type TerminateDatabaseParams struct {
	// PreparedStateOnly For internal use only. Used to safely terminate prepared databases.
	PreparedStateOnly *bool `form:"preparedStateOnly,omitempty" json:"preparedStateOnly,omitempty"`
}

// IdOfTenantParams defines parameters for IdOfTenant.
type IdOfTenantParams struct {
	// Provider Cloud provider. For example, aws, gcp, azure, or digital+ocean
	Provider *string `form:"provider,omitempty" json:"provider,omitempty"`

	// Region Cloud provider region. For example, us-east1, us-west1, toronto
	Region *string `form:"region,omitempty" json:"region,omitempty"`
}

// IdOfCreateTenantEndpointParams defines parameters for IdOfCreateTenantEndpoint.
type IdOfCreateTenantEndpointParams struct {
	// Topic A topic name for auto-creation (if not specified, no topic is created)
	Topic *string `form:"topic,omitempty" json:"topic,omitempty"`
}

// GetStreamingTenantParams defines parameters for GetStreamingTenant.
type GetStreamingTenantParams struct {
	// Authorization Astra token (https://docs.datastax.com/en/streaming/astra-streaming/operations/astream-token-gen.html#astra-token)
	Authorization string `json:"Authorization"`

	// XDataStaxPulsarCluster The name of the Pulsar cluster on which the tenant resides.
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
}

// GetTeneantLimitUsageParams defines parameters for GetTeneantLimitUsage.
type GetTeneantLimitUsageParams struct {
	// Provider Cloud provider, for example, aws, gcp, azure; this is required to evaluate whether a tenant has been reserved by its org owner
	Provider *string `form:"provider,omitempty" json:"provider,omitempty"`

	// Region Cloud provider region, for example, us-east1, us-west1; this is required to evaluate whether a tenant has been reserved by its org owner
	Region *string `form:"region,omitempty" json:"region,omitempty"`
}

// DeleteStreamingTenantParams defines parameters for DeleteStreamingTenant.
type DeleteStreamingTenantParams struct {
	// Opt Performs a soft delete that only marks the tenant as deleted in the database (opt=soft)
	Opt *string `form:"opt,omitempty" json:"opt,omitempty"`
}

// GetPulsarTokensByTenantParams defines parameters for GetPulsarTokensByTenant.
type GetPulsarTokensByTenantParams struct {
	// Authorization Astra token (https://docs.datastax.com/en/streaming/astra-streaming/operations/astream-token-gen.html#astra-token)
	Authorization string `json:"Authorization"`

	// XDataStaxCurrentOrg Astra Org ID.
	XDataStaxCurrentOrg string `json:"X-DataStax-Current-Org"`

	// XDataStaxPulsarCluster Astra Streaming Cluster Name.
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
}

// CreateTenantTokenHandlerParams defines parameters for CreateTenantTokenHandler.
type CreateTenantTokenHandlerParams struct {
	// Authorization Astra token (https://docs.datastax.com/en/streaming/astra-streaming/operations/astream-token-gen.html#astra-token)
	Authorization string `json:"Authorization"`

	// XDataStaxCurrentOrg Astra Org ID.
	XDataStaxCurrentOrg string `json:"X-DataStax-Current-Org"`

	// XDataStaxPulsarCluster Astra Streaming Cluster Name.
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
}

// DeletePulsarTokenByIDParams defines parameters for DeletePulsarTokenByID.
type DeletePulsarTokenByIDParams struct {
	// Authorization Astra token (https://docs.datastax.com/en/streaming/astra-streaming/operations/astream-token-gen.html#astra-token)
	Authorization string `json:"Authorization"`

	// XDataStaxCurrentOrg Astra Org ID.
	XDataStaxCurrentOrg string `json:"X-DataStax-Current-Org"`

	// XDataStaxPulsarCluster Astra Streaming Cluster Name.
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
}

// GetPulsarTokenByIDParams defines parameters for GetPulsarTokenByID.
type GetPulsarTokenByIDParams struct {
	// Authorization Astra token (https://docs.datastax.com/en/streaming/astra-streaming/operations/astream-token-gen.html#astra-token)
	Authorization string `json:"Authorization"`

	// XDataStaxCurrentOrg Astra Org ID.
	XDataStaxCurrentOrg string `json:"X-DataStax-Current-Org"`

	// XDataStaxPulsarCluster Astra Streaming Cluster Name.
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
}

// CreateTenantTokenHandlerV3Params defines parameters for CreateTenantTokenHandlerV3.
type CreateTenantTokenHandlerV3Params struct {
	// Authorization Astra token (https://docs.datastax.com/en/streaming/astra-streaming/operations/astream-token-gen.html#astra-token) or a Keycloak token.
	Authorization string `json:"Authorization"`

	// XDataStaxCurrentOrg Astra Org ID.
	XDataStaxCurrentOrg string `json:"X-DataStax-Current-Org"`

	// XDataStaxPulsarCluster Astra Streaming Cluster Name.
	XDataStaxPulsarCluster string `json:"X-DataStax-Pulsar-Cluster"`
}

// DeleteCDCJSONRequestBody defines body for DeleteCDC for application/json ContentType.
type DeleteCDCJSONRequestBody = CdcRequest

// EnableCDCJSONRequestBody defines body for EnableCDC for application/json ContentType.
type EnableCDCJSONRequestBody = CdcRequest

// CreateSinkJSONJSONRequestBody defines body for CreateSinkJSON for application/json ContentType.
type CreateSinkJSONJSONRequestBody = SinkConfig

// UpdateSinkJSONJSONRequestBody defines body for UpdateSinkJSON for application/json ContentType.
type UpdateSinkJSONJSONRequestBody = SinkConfig

// CreateSourceJSONJSONRequestBody defines body for CreateSourceJSON for application/json ContentType.
type CreateSourceJSONJSONRequestBody = SourceConfig

// UpdateSourceJSONJSONRequestBody defines body for UpdateSourceJSON for application/json ContentType.
type UpdateSourceJSONJSONRequestBody = SourceConfig

// GenerateTokenForClientJSONRequestBody defines body for GenerateTokenForClient for application/json ContentType.
type GenerateTokenForClientJSONRequestBody = GenerateTokenBody

// CreateDatabaseJSONRequestBody defines body for CreateDatabase for application/json ContentType.
type CreateDatabaseJSONRequestBody = DatabaseInfoCreate

// UpdateAccessListForDatabaseJSONRequestBody defines body for UpdateAccessListForDatabase for application/json ContentType.
type UpdateAccessListForDatabaseJSONRequestBody = AccessListRequest

// AddAddressesToAccessListForDatabaseJSONRequestBody defines body for AddAddressesToAccessListForDatabase for application/json ContentType.
type AddAddressesToAccessListForDatabaseJSONRequestBody = AddAddressesToAccessListForDatabaseJSONBody

// UpsertAccessListForDatabaseJSONRequestBody defines body for UpsertAccessListForDatabase for application/json ContentType.
type UpsertAccessListForDatabaseJSONRequestBody = AccessListRequest

// ResetPasswordJSONRequestBody defines body for ResetPassword for application/json ContentType.
type ResetPasswordJSONRequestBody = UserPassword

// ResizeDatabaseJSONRequestBody defines body for ResizeDatabase for application/json ContentType.
type ResizeDatabaseJSONRequestBody = CapacityUnits

// AddOrganizationRoleJSONRequestBody defines body for AddOrganizationRole for application/json ContentType.
type AddOrganizationRoleJSONRequestBody = CreateRoleRequest

// UpdateRoleJSONRequestBody defines body for UpdateRole for application/json ContentType.
type UpdateRoleJSONRequestBody = UpdateRoleRequest

// InviteUserToOrganizationJSONRequestBody defines body for InviteUserToOrganization for application/json ContentType.
type InviteUserToOrganizationJSONRequestBody = UserInvite

// UpdateRolesForUserInOrganizationJSONRequestBody defines body for UpdateRolesForUserInOrganization for application/json ContentType.
type UpdateRolesForUserInOrganizationJSONRequestBody = RoleInviteRequest

// IdOfCreateTenantEndpointJSONRequestBody defines body for IdOfCreateTenantEndpoint for application/json ContentType.
type IdOfCreateTenantEndpointJSONRequestBody = TenantRequest

// CreateTenantTokenHandlerV3JSONRequestBody defines body for CreateTenantTokenHandlerV3 for application/json ContentType.
type CreateTenantTokenHandlerV3JSONRequestBody = CreateTenantTokenV3Request

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// DeleteNamespace request
	DeleteNamespace(ctx context.Context, tenant string, namespace string, params *DeleteNamespaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespace request
	GetNamespace(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNamespace request
	CreateNamespace(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTopics request
	GetTopics(ctx context.Context, tenant string, namespace string, params *GetTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTopic request
	DeleteTopic(ctx context.Context, tenant string, namespace string, topic string, params *DeleteTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTopic request
	CreateTopic(ctx context.Context, tenant string, namespace string, topic string, params *CreateTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IdNamespaceStatsTenant request
	IdNamespaceStatsTenant(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IdNamespaceStatsTenantNamespace request
	IdNamespaceStatsTenantNamespace(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IdTopicStatsTenant request
	IdTopicStatsTenant(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IdTopicStatsTenantNamespace request
	IdTopicStatsTenantNamespace(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCDCWithBody request with any body
	DeleteCDCWithBody(ctx context.Context, tenantName string, params *DeleteCDCParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteCDC(ctx context.Context, tenantName string, params *DeleteCDCParams, body DeleteCDCJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCDC request
	GetCDC(ctx context.Context, tenantName string, params *GetCDCParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnableCDCWithBody request with any body
	EnableCDCWithBody(ctx context.Context, tenantName string, params *EnableCDCParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EnableCDC(ctx context.Context, tenantName string, params *EnableCDCParams, body EnableCDCJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSink request
	DeleteSink(ctx context.Context, tenant string, namespace string, sinkName string, params *DeleteSinkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSinks request
	GetSinks(ctx context.Context, tenant string, namespace string, sinkName string, params *GetSinksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSinkJSONWithBody request with any body
	CreateSinkJSONWithBody(ctx context.Context, tenant string, namespace string, sinkName string, params *CreateSinkJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSinkJSON(ctx context.Context, tenant string, namespace string, sinkName string, params *CreateSinkJSONParams, body CreateSinkJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSinkJSONWithBody request with any body
	UpdateSinkJSONWithBody(ctx context.Context, tenant string, namespace string, sinkName string, params *UpdateSinkJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSinkJSON(ctx context.Context, tenant string, namespace string, sinkName string, params *UpdateSinkJSONParams, body UpdateSinkJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSourceJSONWithBody request with any body
	CreateSourceJSONWithBody(ctx context.Context, tenant string, namespace string, sourceName string, params *CreateSourceJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSourceJSON(ctx context.Context, tenant string, namespace string, sourceName string, params *CreateSourceJSONParams, body CreateSourceJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSourceJSONWithBody request with any body
	UpdateSourceJSONWithBody(ctx context.Context, tenant string, namespace string, sourceName string, params *UpdateSourceJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSourceJSON(ctx context.Context, tenant string, namespace string, sourceName string, params *UpdateSourceJSONParams, body UpdateSourceJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBuiltInSinks request
	GetBuiltInSinks(ctx context.Context, params *GetBuiltInSinksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccessListTemplate request
	GetAccessListTemplate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateAccessList request
	ValidateAccessList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllAccessListsForOrganization request
	GetAllAccessListsForOrganization(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAvailableRegions request
	ListAvailableRegions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTokenForClient request
	DeleteTokenForClient(ctx context.Context, clientId ClientIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientsForOrg request
	GetClientsForOrg(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateTokenForClientWithBody request with any body
	GenerateTokenForClientWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateTokenForClient(ctx context.Context, body GenerateTokenForClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentOrganization request
	GetCurrentOrganization(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDatabases request
	ListDatabases(ctx context.Context, params *ListDatabasesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDatabaseWithBody request with any body
	CreateDatabaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDatabase(ctx context.Context, body CreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatabase request
	GetDatabase(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAddressesOrAccessListForDatabase request
	DeleteAddressesOrAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, params *DeleteAddressesOrAccessListForDatabaseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccessListForDatabase request
	GetAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAccessListForDatabaseWithBody request with any body
	UpdateAccessListForDatabaseWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, body UpdateAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddAddressesToAccessListForDatabaseWithBody request with any body
	AddAddressesToAccessListForDatabaseWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddAddressesToAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, body AddAddressesToAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertAccessListForDatabaseWithBody request with any body
	UpsertAccessListForDatabaseWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, body UpsertAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddKeyspace request
	AddKeyspace(ctx context.Context, databaseId DatabaseIdParam, keyspaceName KeyspaceNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ParkDatabase request
	ParkDatabase(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetPasswordWithBody request with any body
	ResetPasswordWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResetPassword(ctx context.Context, databaseId DatabaseIdParam, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResizeDatabaseWithBody request with any body
	ResizeDatabaseWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResizeDatabase(ctx context.Context, databaseId DatabaseIdParam, body ResizeDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateSecureBundleURL request
	GenerateSecureBundleURL(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TerminateDatabase request
	TerminateDatabase(ctx context.Context, databaseId DatabaseIdParam, params *TerminateDatabaseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnparkDatabase request
	UnparkDatabase(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationRoles request
	GetOrganizationRoles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddOrganizationRoleWithBody request with any body
	AddOrganizationRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddOrganizationRole(ctx context.Context, body AddOrganizationRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOrganizationRole request
	DeleteOrganizationRole(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationRole request
	GetOrganizationRole(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRoleWithBody request with any body
	UpdateRoleWithBody(ctx context.Context, roleID RoleIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRole(ctx context.Context, roleID RoleIdParam, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationUsers request
	GetOrganizationUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InviteUserToOrganizationWithBody request with any body
	InviteUserToOrganizationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InviteUserToOrganization(ctx context.Context, body InviteUserToOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveUserFromOrganization request
	RemoveUserFromOrganization(ctx context.Context, userID UserIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationUser request
	GetOrganizationUser(ctx context.Context, userID UserIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRolesForUserInOrganizationWithBody request with any body
	UpdateRolesForUserInOrganizationWithBody(ctx context.Context, userID UserIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRolesForUserInOrganization(ctx context.Context, userID UserIdParam, body UpdateRolesForUserInOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IdOfTenant request
	IdOfTenant(ctx context.Context, params *IdOfTenantParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPulsarClusters request
	GetPulsarClusters(ctx context.Context, org string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamingTenantsByOrg request
	GetStreamingTenantsByOrg(ctx context.Context, org string, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamingProviders request
	GetStreamingProviders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTenants request
	GetTenants(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IdOfCreateTenantEndpointWithBody request with any body
	IdOfCreateTenantEndpointWithBody(ctx context.Context, params *IdOfCreateTenantEndpointParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IdOfCreateTenantEndpoint(ctx context.Context, params *IdOfCreateTenantEndpointParams, body IdOfCreateTenantEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamingTenant request
	GetStreamingTenant(ctx context.Context, tenant string, params *GetStreamingTenantParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeneantLimitUsage request
	GetTeneantLimitUsage(ctx context.Context, tenant string, params *GetTeneantLimitUsageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStreamingTenant request
	DeleteStreamingTenant(ctx context.Context, tenant string, cluster string, params *DeleteStreamingTenantParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLimits request
	GetLimits(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPulsarTokensByTenant request
	GetPulsarTokensByTenant(ctx context.Context, tenant string, params *GetPulsarTokensByTenantParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTenantTokenHandler request
	CreateTenantTokenHandler(ctx context.Context, tenant string, params *CreateTenantTokenHandlerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePulsarTokenByID request
	DeletePulsarTokenByID(ctx context.Context, tenant string, tokenID string, params *DeletePulsarTokenByIDParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPulsarTokenByID request
	GetPulsarTokenByID(ctx context.Context, tenant string, tokenID string, params *GetPulsarTokenByIDParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTenantTokenHandlerV3WithBody request with any body
	CreateTenantTokenHandlerV3WithBody(ctx context.Context, tenant string, params *CreateTenantTokenHandlerV3Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTenantTokenHandlerV3(ctx context.Context, tenant string, params *CreateTenantTokenHandlerV3Params, body CreateTenantTokenHandlerV3JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) DeleteNamespace(ctx context.Context, tenant string, namespace string, params *DeleteNamespaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNamespaceRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespace(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNamespace(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNamespaceRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTopics(ctx context.Context, tenant string, namespace string, params *GetTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTopicsRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTopic(ctx context.Context, tenant string, namespace string, topic string, params *DeleteTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTopic(ctx context.Context, tenant string, namespace string, topic string, params *CreateTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IdNamespaceStatsTenant(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIdNamespaceStatsTenantRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IdNamespaceStatsTenantNamespace(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIdNamespaceStatsTenantNamespaceRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IdTopicStatsTenant(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIdTopicStatsTenantRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IdTopicStatsTenantNamespace(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIdTopicStatsTenantNamespaceRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCDCWithBody(ctx context.Context, tenantName string, params *DeleteCDCParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCDCRequestWithBody(c.Server, tenantName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCDC(ctx context.Context, tenantName string, params *DeleteCDCParams, body DeleteCDCJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCDCRequest(c.Server, tenantName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCDC(ctx context.Context, tenantName string, params *GetCDCParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCDCRequest(c.Server, tenantName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableCDCWithBody(ctx context.Context, tenantName string, params *EnableCDCParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableCDCRequestWithBody(c.Server, tenantName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableCDC(ctx context.Context, tenantName string, params *EnableCDCParams, body EnableCDCJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableCDCRequest(c.Server, tenantName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSink(ctx context.Context, tenant string, namespace string, sinkName string, params *DeleteSinkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSinkRequest(c.Server, tenant, namespace, sinkName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSinks(ctx context.Context, tenant string, namespace string, sinkName string, params *GetSinksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSinksRequest(c.Server, tenant, namespace, sinkName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSinkJSONWithBody(ctx context.Context, tenant string, namespace string, sinkName string, params *CreateSinkJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSinkJSONRequestWithBody(c.Server, tenant, namespace, sinkName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSinkJSON(ctx context.Context, tenant string, namespace string, sinkName string, params *CreateSinkJSONParams, body CreateSinkJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSinkJSONRequest(c.Server, tenant, namespace, sinkName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSinkJSONWithBody(ctx context.Context, tenant string, namespace string, sinkName string, params *UpdateSinkJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSinkJSONRequestWithBody(c.Server, tenant, namespace, sinkName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSinkJSON(ctx context.Context, tenant string, namespace string, sinkName string, params *UpdateSinkJSONParams, body UpdateSinkJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSinkJSONRequest(c.Server, tenant, namespace, sinkName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSourceJSONWithBody(ctx context.Context, tenant string, namespace string, sourceName string, params *CreateSourceJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSourceJSONRequestWithBody(c.Server, tenant, namespace, sourceName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSourceJSON(ctx context.Context, tenant string, namespace string, sourceName string, params *CreateSourceJSONParams, body CreateSourceJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSourceJSONRequest(c.Server, tenant, namespace, sourceName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSourceJSONWithBody(ctx context.Context, tenant string, namespace string, sourceName string, params *UpdateSourceJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSourceJSONRequestWithBody(c.Server, tenant, namespace, sourceName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSourceJSON(ctx context.Context, tenant string, namespace string, sourceName string, params *UpdateSourceJSONParams, body UpdateSourceJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSourceJSONRequest(c.Server, tenant, namespace, sourceName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBuiltInSinks(ctx context.Context, params *GetBuiltInSinksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBuiltInSinksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccessListTemplate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccessListTemplateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateAccessList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateAccessListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllAccessListsForOrganization(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllAccessListsForOrganizationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAvailableRegions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAvailableRegionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTokenForClient(ctx context.Context, clientId ClientIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTokenForClientRequest(c.Server, clientId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientsForOrg(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientsForOrgRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateTokenForClientWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateTokenForClientRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateTokenForClient(ctx context.Context, body GenerateTokenForClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateTokenForClientRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentOrganization(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentOrganizationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDatabases(ctx context.Context, params *ListDatabasesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDatabasesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabase(ctx context.Context, body CreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatabase(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatabaseRequest(c.Server, databaseId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAddressesOrAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, params *DeleteAddressesOrAccessListForDatabaseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAddressesOrAccessListForDatabaseRequest(c.Server, databaseId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccessListForDatabaseRequest(c.Server, databaseId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccessListForDatabaseWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccessListForDatabaseRequestWithBody(c.Server, databaseId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, body UpdateAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccessListForDatabaseRequest(c.Server, databaseId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddAddressesToAccessListForDatabaseWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddAddressesToAccessListForDatabaseRequestWithBody(c.Server, databaseId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddAddressesToAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, body AddAddressesToAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddAddressesToAccessListForDatabaseRequest(c.Server, databaseId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertAccessListForDatabaseWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertAccessListForDatabaseRequestWithBody(c.Server, databaseId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertAccessListForDatabase(ctx context.Context, databaseId DatabaseIdParam, body UpsertAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertAccessListForDatabaseRequest(c.Server, databaseId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddKeyspace(ctx context.Context, databaseId DatabaseIdParam, keyspaceName KeyspaceNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddKeyspaceRequest(c.Server, databaseId, keyspaceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ParkDatabase(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewParkDatabaseRequest(c.Server, databaseId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPasswordWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPasswordRequestWithBody(c.Server, databaseId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPassword(ctx context.Context, databaseId DatabaseIdParam, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPasswordRequest(c.Server, databaseId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResizeDatabaseWithBody(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResizeDatabaseRequestWithBody(c.Server, databaseId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResizeDatabase(ctx context.Context, databaseId DatabaseIdParam, body ResizeDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResizeDatabaseRequest(c.Server, databaseId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateSecureBundleURL(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateSecureBundleURLRequest(c.Server, databaseId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TerminateDatabase(ctx context.Context, databaseId DatabaseIdParam, params *TerminateDatabaseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTerminateDatabaseRequest(c.Server, databaseId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnparkDatabase(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnparkDatabaseRequest(c.Server, databaseId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationRoles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationRolesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrganizationRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrganizationRoleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrganizationRole(ctx context.Context, body AddOrganizationRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrganizationRoleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOrganizationRole(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOrganizationRoleRequest(c.Server, roleID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationRole(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationRoleRequest(c.Server, roleID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRoleWithBody(ctx context.Context, roleID RoleIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleRequestWithBody(c.Server, roleID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRole(ctx context.Context, roleID RoleIdParam, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleRequest(c.Server, roleID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationUsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteUserToOrganizationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteUserToOrganizationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteUserToOrganization(ctx context.Context, body InviteUserToOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteUserToOrganizationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUserFromOrganization(ctx context.Context, userID UserIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUserFromOrganizationRequest(c.Server, userID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationUser(ctx context.Context, userID UserIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationUserRequest(c.Server, userID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRolesForUserInOrganizationWithBody(ctx context.Context, userID UserIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRolesForUserInOrganizationRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRolesForUserInOrganization(ctx context.Context, userID UserIdParam, body UpdateRolesForUserInOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRolesForUserInOrganizationRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IdOfTenant(ctx context.Context, params *IdOfTenantParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIdOfTenantRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPulsarClusters(ctx context.Context, org string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPulsarClustersRequest(c.Server, org)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamingTenantsByOrg(ctx context.Context, org string, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamingTenantsByOrgRequest(c.Server, org, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamingProviders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamingProvidersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTenants(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTenantsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IdOfCreateTenantEndpointWithBody(ctx context.Context, params *IdOfCreateTenantEndpointParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIdOfCreateTenantEndpointRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IdOfCreateTenantEndpoint(ctx context.Context, params *IdOfCreateTenantEndpointParams, body IdOfCreateTenantEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIdOfCreateTenantEndpointRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamingTenant(ctx context.Context, tenant string, params *GetStreamingTenantParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamingTenantRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeneantLimitUsage(ctx context.Context, tenant string, params *GetTeneantLimitUsageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeneantLimitUsageRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStreamingTenant(ctx context.Context, tenant string, cluster string, params *DeleteStreamingTenantParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStreamingTenantRequest(c.Server, tenant, cluster, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLimits(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLimitsRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPulsarTokensByTenant(ctx context.Context, tenant string, params *GetPulsarTokensByTenantParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPulsarTokensByTenantRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTenantTokenHandler(ctx context.Context, tenant string, params *CreateTenantTokenHandlerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTenantTokenHandlerRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePulsarTokenByID(ctx context.Context, tenant string, tokenID string, params *DeletePulsarTokenByIDParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePulsarTokenByIDRequest(c.Server, tenant, tokenID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPulsarTokenByID(ctx context.Context, tenant string, tokenID string, params *GetPulsarTokenByIDParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPulsarTokenByIDRequest(c.Server, tenant, tokenID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTenantTokenHandlerV3WithBody(ctx context.Context, tenant string, params *CreateTenantTokenHandlerV3Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTenantTokenHandlerV3RequestWithBody(c.Server, tenant, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTenantTokenHandlerV3(ctx context.Context, tenant string, params *CreateTenantTokenHandlerV3Params, body CreateTenantTokenHandlerV3JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTenantTokenHandlerV3Request(c.Server, tenant, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewDeleteNamespaceRequest generates requests for DeleteNamespace
func NewDeleteNamespaceRequest(server string, tenant string, namespace string, params *DeleteNamespaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v2/namespaces/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceRequest generates requests for GetNamespace
func NewGetNamespaceRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v2/namespaces/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNamespaceRequest generates requests for CreateNamespace
func NewCreateNamespaceRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v2/namespaces/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTopicsRequest generates requests for GetTopics
func NewGetTopicsRequest(server string, tenant string, namespace string, params *GetTopicsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v2/persistent/%s/%s/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		if params.XDataStaxPulsarCluster != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, *params.XDataStaxPulsarCluster)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam1)
		}

	}

	return req, nil
}

// NewDeleteTopicRequest generates requests for DeleteTopic
func NewDeleteTopicRequest(server string, tenant string, namespace string, topic string, params *DeleteTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v2/persistent/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XDataStaxCurrentOrg != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Current-Org", runtime.ParamLocationHeader, *params.XDataStaxCurrentOrg)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-DataStax-Current-Org", headerParam0)
		}

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam1)

		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam2)

	}

	return req, nil
}

// NewCreateTopicRequest generates requests for CreateTopic
func NewCreateTopicRequest(server string, tenant string, namespace string, topic string, params *CreateTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v2/persistent/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XDataStaxCurrentOrg != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Current-Org", runtime.ParamLocationHeader, *params.XDataStaxCurrentOrg)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-DataStax-Current-Org", headerParam0)
		}

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam1)

		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam2)

	}

	return req, nil
}

// NewIdNamespaceStatsTenantRequest generates requests for IdNamespaceStatsTenant
func NewIdNamespaceStatsTenantRequest(server string, tenant string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v2/stats/namespaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIdNamespaceStatsTenantNamespaceRequest generates requests for IdNamespaceStatsTenantNamespace
func NewIdNamespaceStatsTenantNamespaceRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v2/stats/namespaces/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIdTopicStatsTenantRequest generates requests for IdTopicStatsTenant
func NewIdTopicStatsTenantRequest(server string, tenant string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v2/stats/topics/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIdTopicStatsTenantNamespaceRequest generates requests for IdTopicStatsTenantNamespace
func NewIdTopicStatsTenantNamespaceRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v2/stats/topics/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCDCRequest calls the generic DeleteCDC builder with application/json body
func NewDeleteCDCRequest(server string, tenantName string, params *DeleteCDCParams, body DeleteCDCJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteCDCRequestWithBody(server, tenantName, params, "application/json", bodyReader)
}

// NewDeleteCDCRequestWithBody generates requests for DeleteCDC with any type of body
func NewDeleteCDCRequestWithBody(server string, tenantName string, params *DeleteCDCParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantName", runtime.ParamLocationPath, tenantName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v3/astra/tenants/%s/cdc", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("authorization", headerParam1)

	}

	return req, nil
}

// NewGetCDCRequest generates requests for GetCDC
func NewGetCDCRequest(server string, tenantName string, params *GetCDCParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantName", runtime.ParamLocationPath, tenantName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v3/astra/tenants/%s/cdc", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("authorization", headerParam1)

	}

	return req, nil
}

// NewEnableCDCRequest calls the generic EnableCDC builder with application/json body
func NewEnableCDCRequest(server string, tenantName string, params *EnableCDCParams, body EnableCDCJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEnableCDCRequestWithBody(server, tenantName, params, "application/json", bodyReader)
}

// NewEnableCDCRequestWithBody generates requests for EnableCDC with any type of body
func NewEnableCDCRequestWithBody(server string, tenantName string, params *EnableCDCParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantName", runtime.ParamLocationPath, tenantName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v3/astra/tenants/%s/cdc", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("authorization", headerParam1)

	}

	return req, nil
}

// NewDeleteSinkRequest generates requests for DeleteSink
func NewDeleteSinkRequest(server string, tenant string, namespace string, sinkName string, params *DeleteSinkParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "sinkName", runtime.ParamLocationPath, sinkName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v3/astrasinks/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Current-Org", runtime.ParamLocationHeader, params.XDataStaxCurrentOrg)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Current-Org", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam1)

		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam2)

	}

	return req, nil
}

// NewGetSinksRequest generates requests for GetSinks
func NewGetSinksRequest(server string, tenant string, namespace string, sinkName string, params *GetSinksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "sinkName", runtime.ParamLocationPath, sinkName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v3/astrasinks/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam1)

	}

	return req, nil
}

// NewCreateSinkJSONRequest calls the generic CreateSinkJSON builder with application/json body
func NewCreateSinkJSONRequest(server string, tenant string, namespace string, sinkName string, params *CreateSinkJSONParams, body CreateSinkJSONJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSinkJSONRequestWithBody(server, tenant, namespace, sinkName, params, "application/json", bodyReader)
}

// NewCreateSinkJSONRequestWithBody generates requests for CreateSinkJSON with any type of body
func NewCreateSinkJSONRequestWithBody(server string, tenant string, namespace string, sinkName string, params *CreateSinkJSONParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "sinkName", runtime.ParamLocationPath, sinkName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v3/astrasinks/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Current-Org", runtime.ParamLocationHeader, params.XDataStaxCurrentOrg)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Current-Org", headerParam1)

		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam2)

	}

	return req, nil
}

// NewUpdateSinkJSONRequest calls the generic UpdateSinkJSON builder with application/json body
func NewUpdateSinkJSONRequest(server string, tenant string, namespace string, sinkName string, params *UpdateSinkJSONParams, body UpdateSinkJSONJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSinkJSONRequestWithBody(server, tenant, namespace, sinkName, params, "application/json", bodyReader)
}

// NewUpdateSinkJSONRequestWithBody generates requests for UpdateSinkJSON with any type of body
func NewUpdateSinkJSONRequestWithBody(server string, tenant string, namespace string, sinkName string, params *UpdateSinkJSONParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "sinkName", runtime.ParamLocationPath, sinkName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v3/astrasinks/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Current-Org", runtime.ParamLocationHeader, params.XDataStaxCurrentOrg)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Current-Org", headerParam1)

		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam2)

	}

	return req, nil
}

// NewCreateSourceJSONRequest calls the generic CreateSourceJSON builder with application/json body
func NewCreateSourceJSONRequest(server string, tenant string, namespace string, sourceName string, params *CreateSourceJSONParams, body CreateSourceJSONJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSourceJSONRequestWithBody(server, tenant, namespace, sourceName, params, "application/json", bodyReader)
}

// NewCreateSourceJSONRequestWithBody generates requests for CreateSourceJSON with any type of body
func NewCreateSourceJSONRequestWithBody(server string, tenant string, namespace string, sourceName string, params *CreateSourceJSONParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "sourceName", runtime.ParamLocationPath, sourceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v3/astrasources/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Current-Org", runtime.ParamLocationHeader, params.XDataStaxCurrentOrg)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Current-Org", headerParam1)

		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam2)

	}

	return req, nil
}

// NewUpdateSourceJSONRequest calls the generic UpdateSourceJSON builder with application/json body
func NewUpdateSourceJSONRequest(server string, tenant string, namespace string, sourceName string, params *UpdateSourceJSONParams, body UpdateSourceJSONJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSourceJSONRequestWithBody(server, tenant, namespace, sourceName, params, "application/json", bodyReader)
}

// NewUpdateSourceJSONRequestWithBody generates requests for UpdateSourceJSON with any type of body
func NewUpdateSourceJSONRequestWithBody(server string, tenant string, namespace string, sourceName string, params *UpdateSourceJSONParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "sourceName", runtime.ParamLocationPath, sourceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v3/astrasources/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Current-Org", runtime.ParamLocationHeader, params.XDataStaxCurrentOrg)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Current-Org", headerParam1)

		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam2)

	}

	return req, nil
}

// NewGetBuiltInSinksRequest generates requests for GetBuiltInSinks
func NewGetBuiltInSinksRequest(server string, params *GetBuiltInSinksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/v3/sinks/builtinsinks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam1)

	}

	return req, nil
}

// NewGetAccessListTemplateRequest generates requests for GetAccessListTemplate
func NewGetAccessListTemplateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/access-list/template")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewValidateAccessListRequest generates requests for ValidateAccessList
func NewValidateAccessListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/access-list/validate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllAccessListsForOrganizationRequest generates requests for GetAllAccessListsForOrganization
func NewGetAllAccessListsForOrganizationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/access-lists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAvailableRegionsRequest generates requests for ListAvailableRegions
func NewListAvailableRegionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/availableRegions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteTokenForClientRequest generates requests for DeleteTokenForClient
func NewDeleteTokenForClientRequest(server string, clientId ClientIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/clientIdSecret/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClientsForOrgRequest generates requests for GetClientsForOrg
func NewGetClientsForOrgRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/clientIdSecrets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateTokenForClientRequest calls the generic GenerateTokenForClient builder with application/json body
func NewGenerateTokenForClientRequest(server string, body GenerateTokenForClientJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateTokenForClientRequestWithBody(server, "application/json", bodyReader)
}

// NewGenerateTokenForClientRequestWithBody generates requests for GenerateTokenForClient with any type of body
func NewGenerateTokenForClientRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/clientIdSecrets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCurrentOrganizationRequest generates requests for GetCurrentOrganization
func NewGetCurrentOrganizationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/currentOrg")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDatabasesRequest generates requests for ListDatabases
func NewListDatabasesRequest(server string, params *ListDatabasesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Provider != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "provider", runtime.ParamLocationQuery, *params.Provider); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDatabaseRequest calls the generic CreateDatabase builder with application/json body
func NewCreateDatabaseRequest(server string, body CreateDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDatabaseRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDatabaseRequestWithBody generates requests for CreateDatabase with any type of body
func NewCreateDatabaseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDatabaseRequest generates requests for GetDatabase
func NewGetDatabaseRequest(server string, databaseId DatabaseIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteAddressesOrAccessListForDatabaseRequest generates requests for DeleteAddressesOrAccessListForDatabase
func NewDeleteAddressesOrAccessListForDatabaseRequest(server string, databaseId DatabaseIdParam, params *DeleteAddressesOrAccessListForDatabaseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/access-list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Addresses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addresses", runtime.ParamLocationQuery, *params.Addresses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAccessListForDatabaseRequest generates requests for GetAccessListForDatabase
func NewGetAccessListForDatabaseRequest(server string, databaseId DatabaseIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/access-list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAccessListForDatabaseRequest calls the generic UpdateAccessListForDatabase builder with application/json body
func NewUpdateAccessListForDatabaseRequest(server string, databaseId DatabaseIdParam, body UpdateAccessListForDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAccessListForDatabaseRequestWithBody(server, databaseId, "application/json", bodyReader)
}

// NewUpdateAccessListForDatabaseRequestWithBody generates requests for UpdateAccessListForDatabase with any type of body
func NewUpdateAccessListForDatabaseRequestWithBody(server string, databaseId DatabaseIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/access-list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddAddressesToAccessListForDatabaseRequest calls the generic AddAddressesToAccessListForDatabase builder with application/json body
func NewAddAddressesToAccessListForDatabaseRequest(server string, databaseId DatabaseIdParam, body AddAddressesToAccessListForDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddAddressesToAccessListForDatabaseRequestWithBody(server, databaseId, "application/json", bodyReader)
}

// NewAddAddressesToAccessListForDatabaseRequestWithBody generates requests for AddAddressesToAccessListForDatabase with any type of body
func NewAddAddressesToAccessListForDatabaseRequestWithBody(server string, databaseId DatabaseIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/access-list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpsertAccessListForDatabaseRequest calls the generic UpsertAccessListForDatabase builder with application/json body
func NewUpsertAccessListForDatabaseRequest(server string, databaseId DatabaseIdParam, body UpsertAccessListForDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertAccessListForDatabaseRequestWithBody(server, databaseId, "application/json", bodyReader)
}

// NewUpsertAccessListForDatabaseRequestWithBody generates requests for UpsertAccessListForDatabase with any type of body
func NewUpsertAccessListForDatabaseRequestWithBody(server string, databaseId DatabaseIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/access-list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddKeyspaceRequest generates requests for AddKeyspace
func NewAddKeyspaceRequest(server string, databaseId DatabaseIdParam, keyspaceName KeyspaceNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "keyspaceName", runtime.ParamLocationPath, keyspaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/keyspaces/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewParkDatabaseRequest generates requests for ParkDatabase
func NewParkDatabaseRequest(server string, databaseId DatabaseIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/park", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResetPasswordRequest calls the generic ResetPassword builder with application/json body
func NewResetPasswordRequest(server string, databaseId DatabaseIdParam, body ResetPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResetPasswordRequestWithBody(server, databaseId, "application/json", bodyReader)
}

// NewResetPasswordRequestWithBody generates requests for ResetPassword with any type of body
func NewResetPasswordRequestWithBody(server string, databaseId DatabaseIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/resetPassword", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResizeDatabaseRequest calls the generic ResizeDatabase builder with application/json body
func NewResizeDatabaseRequest(server string, databaseId DatabaseIdParam, body ResizeDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResizeDatabaseRequestWithBody(server, databaseId, "application/json", bodyReader)
}

// NewResizeDatabaseRequestWithBody generates requests for ResizeDatabase with any type of body
func NewResizeDatabaseRequestWithBody(server string, databaseId DatabaseIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/resize", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenerateSecureBundleURLRequest generates requests for GenerateSecureBundleURL
func NewGenerateSecureBundleURLRequest(server string, databaseId DatabaseIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/secureBundleURL", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTerminateDatabaseRequest generates requests for TerminateDatabase
func NewTerminateDatabaseRequest(server string, databaseId DatabaseIdParam, params *TerminateDatabaseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/terminate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PreparedStateOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preparedStateOnly", runtime.ParamLocationQuery, *params.PreparedStateOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnparkDatabaseRequest generates requests for UnparkDatabase
func NewUnparkDatabaseRequest(server string, databaseId DatabaseIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/unpark", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationRolesRequest generates requests for GetOrganizationRoles
func NewGetOrganizationRolesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddOrganizationRoleRequest calls the generic AddOrganizationRole builder with application/json body
func NewAddOrganizationRoleRequest(server string, body AddOrganizationRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddOrganizationRoleRequestWithBody(server, "application/json", bodyReader)
}

// NewAddOrganizationRoleRequestWithBody generates requests for AddOrganizationRole with any type of body
func NewAddOrganizationRoleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOrganizationRoleRequest generates requests for DeleteOrganizationRole
func NewDeleteOrganizationRoleRequest(server string, roleID RoleIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleID", runtime.ParamLocationPath, roleID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationRoleRequest generates requests for GetOrganizationRole
func NewGetOrganizationRoleRequest(server string, roleID RoleIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleID", runtime.ParamLocationPath, roleID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRoleRequest calls the generic UpdateRole builder with application/json body
func NewUpdateRoleRequest(server string, roleID RoleIdParam, body UpdateRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRoleRequestWithBody(server, roleID, "application/json", bodyReader)
}

// NewUpdateRoleRequestWithBody generates requests for UpdateRole with any type of body
func NewUpdateRoleRequestWithBody(server string, roleID RoleIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleID", runtime.ParamLocationPath, roleID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOrganizationUsersRequest generates requests for GetOrganizationUsers
func NewGetOrganizationUsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInviteUserToOrganizationRequest calls the generic InviteUserToOrganization builder with application/json body
func NewInviteUserToOrganizationRequest(server string, body InviteUserToOrganizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInviteUserToOrganizationRequestWithBody(server, "application/json", bodyReader)
}

// NewInviteUserToOrganizationRequestWithBody generates requests for InviteUserToOrganization with any type of body
func NewInviteUserToOrganizationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveUserFromOrganizationRequest generates requests for RemoveUserFromOrganization
func NewRemoveUserFromOrganizationRequest(server string, userID UserIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationUserRequest generates requests for GetOrganizationUser
func NewGetOrganizationUserRequest(server string, userID UserIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRolesForUserInOrganizationRequest calls the generic UpdateRolesForUserInOrganization builder with application/json body
func NewUpdateRolesForUserInOrganizationRequest(server string, userID UserIdParam, body UpdateRolesForUserInOrganizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRolesForUserInOrganizationRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewUpdateRolesForUserInOrganizationRequestWithBody generates requests for UpdateRolesForUserInOrganization with any type of body
func NewUpdateRolesForUserInOrganizationRequestWithBody(server string, userID UserIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/users/%s/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIdOfTenantRequest generates requests for IdOfTenant
func NewIdOfTenantRequest(server string, params *IdOfTenantParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/streaming/clusters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Provider != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "provider", runtime.ParamLocationQuery, *params.Provider); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPulsarClustersRequest generates requests for GetPulsarClusters
func NewGetPulsarClustersRequest(server string, org string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/streaming/orgs/%s/tenants", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamingTenantsByOrgRequest generates requests for GetStreamingTenantsByOrg
func NewGetStreamingTenantsByOrgRequest(server string, org string, tenant string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/streaming/orgs/%s/tenants/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamingProvidersRequest generates requests for GetStreamingProviders
func NewGetStreamingProvidersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/streaming/providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTenantsRequest generates requests for GetTenants
func NewGetTenantsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/streaming/tenants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIdOfCreateTenantEndpointRequest calls the generic IdOfCreateTenantEndpoint builder with application/json body
func NewIdOfCreateTenantEndpointRequest(server string, params *IdOfCreateTenantEndpointParams, body IdOfCreateTenantEndpointJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIdOfCreateTenantEndpointRequestWithBody(server, params, "application/json", bodyReader)
}

// NewIdOfCreateTenantEndpointRequestWithBody generates requests for IdOfCreateTenantEndpoint with any type of body
func NewIdOfCreateTenantEndpointRequestWithBody(server string, params *IdOfCreateTenantEndpointParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/streaming/tenants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Topic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "topic", runtime.ParamLocationQuery, *params.Topic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStreamingTenantRequest generates requests for GetStreamingTenant
func NewGetStreamingTenantRequest(server string, tenant string, params *GetStreamingTenantParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/streaming/tenants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam1)

	}

	return req, nil
}

// NewGetTeneantLimitUsageRequest generates requests for GetTeneantLimitUsage
func NewGetTeneantLimitUsageRequest(server string, tenant string, params *GetTeneantLimitUsageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/streaming/tenants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Provider != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "provider", runtime.ParamLocationQuery, *params.Provider); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteStreamingTenantRequest generates requests for DeleteStreamingTenant
func NewDeleteStreamingTenantRequest(server string, tenant string, cluster string, params *DeleteStreamingTenantParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/streaming/tenants/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Opt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "opt", runtime.ParamLocationQuery, *params.Opt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLimitsRequest generates requests for GetLimits
func NewGetLimitsRequest(server string, tenant string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/streaming/tenants/%s/limits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPulsarTokensByTenantRequest generates requests for GetPulsarTokensByTenant
func NewGetPulsarTokensByTenantRequest(server string, tenant string, params *GetPulsarTokensByTenantParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/streaming/tenants/%s/tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Current-Org", runtime.ParamLocationHeader, params.XDataStaxCurrentOrg)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Current-Org", headerParam1)

		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam2)

	}

	return req, nil
}

// NewCreateTenantTokenHandlerRequest generates requests for CreateTenantTokenHandler
func NewCreateTenantTokenHandlerRequest(server string, tenant string, params *CreateTenantTokenHandlerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/streaming/tenants/%s/tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Current-Org", runtime.ParamLocationHeader, params.XDataStaxCurrentOrg)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Current-Org", headerParam1)

		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam2)

	}

	return req, nil
}

// NewDeletePulsarTokenByIDRequest generates requests for DeletePulsarTokenByID
func NewDeletePulsarTokenByIDRequest(server string, tenant string, tokenID string, params *DeletePulsarTokenByIDParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenID", runtime.ParamLocationPath, tokenID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/streaming/tenants/%s/tokens/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Current-Org", runtime.ParamLocationHeader, params.XDataStaxCurrentOrg)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Current-Org", headerParam1)

		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam2)

	}

	return req, nil
}

// NewGetPulsarTokenByIDRequest generates requests for GetPulsarTokenByID
func NewGetPulsarTokenByIDRequest(server string, tenant string, tokenID string, params *GetPulsarTokenByIDParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenID", runtime.ParamLocationPath, tokenID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/streaming/tenants/%s/tokens/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Current-Org", runtime.ParamLocationHeader, params.XDataStaxCurrentOrg)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Current-Org", headerParam1)

		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam2)

	}

	return req, nil
}

// NewCreateTenantTokenHandlerV3Request calls the generic CreateTenantTokenHandlerV3 builder with application/json body
func NewCreateTenantTokenHandlerV3Request(server string, tenant string, params *CreateTenantTokenHandlerV3Params, body CreateTenantTokenHandlerV3JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTenantTokenHandlerV3RequestWithBody(server, tenant, params, "application/json", bodyReader)
}

// NewCreateTenantTokenHandlerV3RequestWithBody generates requests for CreateTenantTokenHandlerV3 with any type of body
func NewCreateTenantTokenHandlerV3RequestWithBody(server string, tenant string, params *CreateTenantTokenHandlerV3Params, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/streaming/tenants/%s/tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Current-Org", runtime.ParamLocationHeader, params.XDataStaxCurrentOrg)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Current-Org", headerParam1)

		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-DataStax-Pulsar-Cluster", runtime.ParamLocationHeader, params.XDataStaxPulsarCluster)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-DataStax-Pulsar-Cluster", headerParam2)

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// DeleteNamespaceWithResponse request
	DeleteNamespaceWithResponse(ctx context.Context, tenant string, namespace string, params *DeleteNamespaceParams, reqEditors ...RequestEditorFn) (*DeleteNamespaceResponse, error)

	// GetNamespaceWithResponse request
	GetNamespaceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceResponse, error)

	// CreateNamespaceWithResponse request
	CreateNamespaceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*CreateNamespaceResponse, error)

	// GetTopicsWithResponse request
	GetTopicsWithResponse(ctx context.Context, tenant string, namespace string, params *GetTopicsParams, reqEditors ...RequestEditorFn) (*GetTopicsResponse, error)

	// DeleteTopicWithResponse request
	DeleteTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteTopicParams, reqEditors ...RequestEditorFn) (*DeleteTopicResponse, error)

	// CreateTopicWithResponse request
	CreateTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CreateTopicParams, reqEditors ...RequestEditorFn) (*CreateTopicResponse, error)

	// IdNamespaceStatsTenantWithResponse request
	IdNamespaceStatsTenantWithResponse(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*IdNamespaceStatsTenantResponse, error)

	// IdNamespaceStatsTenantNamespaceWithResponse request
	IdNamespaceStatsTenantNamespaceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*IdNamespaceStatsTenantNamespaceResponse, error)

	// IdTopicStatsTenantWithResponse request
	IdTopicStatsTenantWithResponse(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*IdTopicStatsTenantResponse, error)

	// IdTopicStatsTenantNamespaceWithResponse request
	IdTopicStatsTenantNamespaceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*IdTopicStatsTenantNamespaceResponse, error)

	// DeleteCDCWithBodyWithResponse request with any body
	DeleteCDCWithBodyWithResponse(ctx context.Context, tenantName string, params *DeleteCDCParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteCDCResponse, error)

	DeleteCDCWithResponse(ctx context.Context, tenantName string, params *DeleteCDCParams, body DeleteCDCJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteCDCResponse, error)

	// GetCDCWithResponse request
	GetCDCWithResponse(ctx context.Context, tenantName string, params *GetCDCParams, reqEditors ...RequestEditorFn) (*GetCDCResponse, error)

	// EnableCDCWithBodyWithResponse request with any body
	EnableCDCWithBodyWithResponse(ctx context.Context, tenantName string, params *EnableCDCParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableCDCResponse, error)

	EnableCDCWithResponse(ctx context.Context, tenantName string, params *EnableCDCParams, body EnableCDCJSONRequestBody, reqEditors ...RequestEditorFn) (*EnableCDCResponse, error)

	// DeleteSinkWithResponse request
	DeleteSinkWithResponse(ctx context.Context, tenant string, namespace string, sinkName string, params *DeleteSinkParams, reqEditors ...RequestEditorFn) (*DeleteSinkResponse, error)

	// GetSinksWithResponse request
	GetSinksWithResponse(ctx context.Context, tenant string, namespace string, sinkName string, params *GetSinksParams, reqEditors ...RequestEditorFn) (*GetSinksResponse, error)

	// CreateSinkJSONWithBodyWithResponse request with any body
	CreateSinkJSONWithBodyWithResponse(ctx context.Context, tenant string, namespace string, sinkName string, params *CreateSinkJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSinkJSONResponse, error)

	CreateSinkJSONWithResponse(ctx context.Context, tenant string, namespace string, sinkName string, params *CreateSinkJSONParams, body CreateSinkJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSinkJSONResponse, error)

	// UpdateSinkJSONWithBodyWithResponse request with any body
	UpdateSinkJSONWithBodyWithResponse(ctx context.Context, tenant string, namespace string, sinkName string, params *UpdateSinkJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSinkJSONResponse, error)

	UpdateSinkJSONWithResponse(ctx context.Context, tenant string, namespace string, sinkName string, params *UpdateSinkJSONParams, body UpdateSinkJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSinkJSONResponse, error)

	// CreateSourceJSONWithBodyWithResponse request with any body
	CreateSourceJSONWithBodyWithResponse(ctx context.Context, tenant string, namespace string, sourceName string, params *CreateSourceJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSourceJSONResponse, error)

	CreateSourceJSONWithResponse(ctx context.Context, tenant string, namespace string, sourceName string, params *CreateSourceJSONParams, body CreateSourceJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSourceJSONResponse, error)

	// UpdateSourceJSONWithBodyWithResponse request with any body
	UpdateSourceJSONWithBodyWithResponse(ctx context.Context, tenant string, namespace string, sourceName string, params *UpdateSourceJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSourceJSONResponse, error)

	UpdateSourceJSONWithResponse(ctx context.Context, tenant string, namespace string, sourceName string, params *UpdateSourceJSONParams, body UpdateSourceJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSourceJSONResponse, error)

	// GetBuiltInSinksWithResponse request
	GetBuiltInSinksWithResponse(ctx context.Context, params *GetBuiltInSinksParams, reqEditors ...RequestEditorFn) (*GetBuiltInSinksResponse, error)

	// GetAccessListTemplateWithResponse request
	GetAccessListTemplateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAccessListTemplateResponse, error)

	// ValidateAccessListWithResponse request
	ValidateAccessListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ValidateAccessListResponse, error)

	// GetAllAccessListsForOrganizationWithResponse request
	GetAllAccessListsForOrganizationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllAccessListsForOrganizationResponse, error)

	// ListAvailableRegionsWithResponse request
	ListAvailableRegionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAvailableRegionsResponse, error)

	// DeleteTokenForClientWithResponse request
	DeleteTokenForClientWithResponse(ctx context.Context, clientId ClientIdParam, reqEditors ...RequestEditorFn) (*DeleteTokenForClientResponse, error)

	// GetClientsForOrgWithResponse request
	GetClientsForOrgWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClientsForOrgResponse, error)

	// GenerateTokenForClientWithBodyWithResponse request with any body
	GenerateTokenForClientWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateTokenForClientResponse, error)

	GenerateTokenForClientWithResponse(ctx context.Context, body GenerateTokenForClientJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateTokenForClientResponse, error)

	// GetCurrentOrganizationWithResponse request
	GetCurrentOrganizationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentOrganizationResponse, error)

	// ListDatabasesWithResponse request
	ListDatabasesWithResponse(ctx context.Context, params *ListDatabasesParams, reqEditors ...RequestEditorFn) (*ListDatabasesResponse, error)

	// CreateDatabaseWithBodyWithResponse request with any body
	CreateDatabaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseResponse, error)

	CreateDatabaseWithResponse(ctx context.Context, body CreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseResponse, error)

	// GetDatabaseWithResponse request
	GetDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*GetDatabaseResponse, error)

	// DeleteAddressesOrAccessListForDatabaseWithResponse request
	DeleteAddressesOrAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, params *DeleteAddressesOrAccessListForDatabaseParams, reqEditors ...RequestEditorFn) (*DeleteAddressesOrAccessListForDatabaseResponse, error)

	// GetAccessListForDatabaseWithResponse request
	GetAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*GetAccessListForDatabaseResponse, error)

	// UpdateAccessListForDatabaseWithBodyWithResponse request with any body
	UpdateAccessListForDatabaseWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccessListForDatabaseResponse, error)

	UpdateAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, body UpdateAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccessListForDatabaseResponse, error)

	// AddAddressesToAccessListForDatabaseWithBodyWithResponse request with any body
	AddAddressesToAccessListForDatabaseWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddAddressesToAccessListForDatabaseResponse, error)

	AddAddressesToAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, body AddAddressesToAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*AddAddressesToAccessListForDatabaseResponse, error)

	// UpsertAccessListForDatabaseWithBodyWithResponse request with any body
	UpsertAccessListForDatabaseWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertAccessListForDatabaseResponse, error)

	UpsertAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, body UpsertAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertAccessListForDatabaseResponse, error)

	// AddKeyspaceWithResponse request
	AddKeyspaceWithResponse(ctx context.Context, databaseId DatabaseIdParam, keyspaceName KeyspaceNameParam, reqEditors ...RequestEditorFn) (*AddKeyspaceResponse, error)

	// ParkDatabaseWithResponse request
	ParkDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*ParkDatabaseResponse, error)

	// ResetPasswordWithBodyWithResponse request with any body
	ResetPasswordWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error)

	ResetPasswordWithResponse(ctx context.Context, databaseId DatabaseIdParam, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error)

	// ResizeDatabaseWithBodyWithResponse request with any body
	ResizeDatabaseWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResizeDatabaseResponse, error)

	ResizeDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, body ResizeDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*ResizeDatabaseResponse, error)

	// GenerateSecureBundleURLWithResponse request
	GenerateSecureBundleURLWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*GenerateSecureBundleURLResponse, error)

	// TerminateDatabaseWithResponse request
	TerminateDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, params *TerminateDatabaseParams, reqEditors ...RequestEditorFn) (*TerminateDatabaseResponse, error)

	// UnparkDatabaseWithResponse request
	UnparkDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*UnparkDatabaseResponse, error)

	// GetOrganizationRolesWithResponse request
	GetOrganizationRolesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOrganizationRolesResponse, error)

	// AddOrganizationRoleWithBodyWithResponse request with any body
	AddOrganizationRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrganizationRoleResponse, error)

	AddOrganizationRoleWithResponse(ctx context.Context, body AddOrganizationRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrganizationRoleResponse, error)

	// DeleteOrganizationRoleWithResponse request
	DeleteOrganizationRoleWithResponse(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*DeleteOrganizationRoleResponse, error)

	// GetOrganizationRoleWithResponse request
	GetOrganizationRoleWithResponse(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*GetOrganizationRoleResponse, error)

	// UpdateRoleWithBodyWithResponse request with any body
	UpdateRoleWithBodyWithResponse(ctx context.Context, roleID RoleIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error)

	UpdateRoleWithResponse(ctx context.Context, roleID RoleIdParam, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error)

	// GetOrganizationUsersWithResponse request
	GetOrganizationUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOrganizationUsersResponse, error)

	// InviteUserToOrganizationWithBodyWithResponse request with any body
	InviteUserToOrganizationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteUserToOrganizationResponse, error)

	InviteUserToOrganizationWithResponse(ctx context.Context, body InviteUserToOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteUserToOrganizationResponse, error)

	// RemoveUserFromOrganizationWithResponse request
	RemoveUserFromOrganizationWithResponse(ctx context.Context, userID UserIdParam, reqEditors ...RequestEditorFn) (*RemoveUserFromOrganizationResponse, error)

	// GetOrganizationUserWithResponse request
	GetOrganizationUserWithResponse(ctx context.Context, userID UserIdParam, reqEditors ...RequestEditorFn) (*GetOrganizationUserResponse, error)

	// UpdateRolesForUserInOrganizationWithBodyWithResponse request with any body
	UpdateRolesForUserInOrganizationWithBodyWithResponse(ctx context.Context, userID UserIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRolesForUserInOrganizationResponse, error)

	UpdateRolesForUserInOrganizationWithResponse(ctx context.Context, userID UserIdParam, body UpdateRolesForUserInOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRolesForUserInOrganizationResponse, error)

	// IdOfTenantWithResponse request
	IdOfTenantWithResponse(ctx context.Context, params *IdOfTenantParams, reqEditors ...RequestEditorFn) (*IdOfTenantResponse, error)

	// GetPulsarClustersWithResponse request
	GetPulsarClustersWithResponse(ctx context.Context, org string, reqEditors ...RequestEditorFn) (*GetPulsarClustersResponse, error)

	// GetStreamingTenantsByOrgWithResponse request
	GetStreamingTenantsByOrgWithResponse(ctx context.Context, org string, tenant string, reqEditors ...RequestEditorFn) (*GetStreamingTenantsByOrgResponse, error)

	// GetStreamingProvidersWithResponse request
	GetStreamingProvidersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStreamingProvidersResponse, error)

	// GetTenantsWithResponse request
	GetTenantsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTenantsResponse, error)

	// IdOfCreateTenantEndpointWithBodyWithResponse request with any body
	IdOfCreateTenantEndpointWithBodyWithResponse(ctx context.Context, params *IdOfCreateTenantEndpointParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IdOfCreateTenantEndpointResponse, error)

	IdOfCreateTenantEndpointWithResponse(ctx context.Context, params *IdOfCreateTenantEndpointParams, body IdOfCreateTenantEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*IdOfCreateTenantEndpointResponse, error)

	// GetStreamingTenantWithResponse request
	GetStreamingTenantWithResponse(ctx context.Context, tenant string, params *GetStreamingTenantParams, reqEditors ...RequestEditorFn) (*GetStreamingTenantResponse, error)

	// GetTeneantLimitUsageWithResponse request
	GetTeneantLimitUsageWithResponse(ctx context.Context, tenant string, params *GetTeneantLimitUsageParams, reqEditors ...RequestEditorFn) (*GetTeneantLimitUsageResponse, error)

	// DeleteStreamingTenantWithResponse request
	DeleteStreamingTenantWithResponse(ctx context.Context, tenant string, cluster string, params *DeleteStreamingTenantParams, reqEditors ...RequestEditorFn) (*DeleteStreamingTenantResponse, error)

	// GetLimitsWithResponse request
	GetLimitsWithResponse(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*GetLimitsResponse, error)

	// GetPulsarTokensByTenantWithResponse request
	GetPulsarTokensByTenantWithResponse(ctx context.Context, tenant string, params *GetPulsarTokensByTenantParams, reqEditors ...RequestEditorFn) (*GetPulsarTokensByTenantResponse, error)

	// CreateTenantTokenHandlerWithResponse request
	CreateTenantTokenHandlerWithResponse(ctx context.Context, tenant string, params *CreateTenantTokenHandlerParams, reqEditors ...RequestEditorFn) (*CreateTenantTokenHandlerResponse, error)

	// DeletePulsarTokenByIDWithResponse request
	DeletePulsarTokenByIDWithResponse(ctx context.Context, tenant string, tokenID string, params *DeletePulsarTokenByIDParams, reqEditors ...RequestEditorFn) (*DeletePulsarTokenByIDResponse, error)

	// GetPulsarTokenByIDWithResponse request
	GetPulsarTokenByIDWithResponse(ctx context.Context, tenant string, tokenID string, params *GetPulsarTokenByIDParams, reqEditors ...RequestEditorFn) (*GetPulsarTokenByIDResponse, error)

	// CreateTenantTokenHandlerV3WithBodyWithResponse request with any body
	CreateTenantTokenHandlerV3WithBodyWithResponse(ctx context.Context, tenant string, params *CreateTenantTokenHandlerV3Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTenantTokenHandlerV3Response, error)

	CreateTenantTokenHandlerV3WithResponse(ctx context.Context, tenant string, params *CreateTenantTokenHandlerV3Params, body CreateTenantTokenHandlerV3JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTenantTokenHandlerV3Response, error)
}

type DeleteNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTopicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetTopicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTopicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IdNamespaceStatsTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatsResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r IdNamespaceStatsTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IdNamespaceStatsTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IdNamespaceStatsTenantNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatsResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r IdNamespaceStatsTenantNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IdNamespaceStatsTenantNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IdTopicStatsTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatsResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r IdTopicStatsTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IdTopicStatsTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IdTopicStatsTenantNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatsResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r IdTopicStatsTenantNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IdTopicStatsTenantNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCDCResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreatedTenantResponse
	JSON401      *ErrorResponse
	JSON409      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteCDCResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCDCResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCDCResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreatedTenantResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCDCResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCDCResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnableCDCResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreatedTenantResponse
	JSON401      *ErrorResponse
	JSON409      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r EnableCDCResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnableCDCResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSinkJSONResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateSinkJSONResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSinkJSONResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSinkJSONResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateSinkJSONResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSinkJSONResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSourceJSONResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateSourceJSONResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSourceJSONResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSourceJSONResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateSourceJSONResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSourceJSONResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBuiltInSinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetBuiltInSinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBuiltInSinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccessListTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccessListRequest
	JSON500      *ServerError
}

// Status returns HTTPResponse.Status
func (r GetAccessListTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccessListTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateAccessListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ValidationResponse
	JSON500      *ServerError
}

// Status returns HTTPResponse.Status
func (r ValidateAccessListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateAccessListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllAccessListsForOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AccessListResponse
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *ServerError
}

// Status returns HTTPResponse.Status
func (r GetAllAccessListsForOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllAccessListsForOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAvailableRegionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AvailableRegionCombination
	JSON401      *Unauthorized
	JSON5XX      *ServerError
}

// Status returns HTTPResponse.Status
func (r ListAvailableRegionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAvailableRegionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTokenForClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON500      *ServerError
}

// Status returns HTTPResponse.Status
func (r DeleteTokenForClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTokenForClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientsForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON500      *ServerError
}

// Status returns HTTPResponse.Status
func (r GetClientsForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientsForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateTokenForClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON500      *ServerError
}

// Status returns HTTPResponse.Status
func (r GenerateTokenForClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateTokenForClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *ServerError
}

// Status returns HTTPResponse.Status
func (r GetCurrentOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDatabasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Database
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON5XX      *ServerError
}

// Status returns HTTPResponse.Status
func (r ListDatabasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDatabasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON422      *UnprocessableEntity
	JSON500      *ServerError
}

// Status returns HTTPResponse.Status
func (r CreateDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Database
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON5XX      *ServerError
}

// Status returns HTTPResponse.Status
func (r GetDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAddressesOrAccessListForDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *ServerError
}

// Status returns HTTPResponse.Status
func (r DeleteAddressesOrAccessListForDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAddressesOrAccessListForDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccessListForDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccessListResponse
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *ServerError
}

// Status returns HTTPResponse.Status
func (r GetAccessListForDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccessListForDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAccessListForDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *ServerError
}

// Status returns HTTPResponse.Status
func (r UpdateAccessListForDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAccessListForDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddAddressesToAccessListForDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *ServerError
}

// Status returns HTTPResponse.Status
func (r AddAddressesToAccessListForDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddAddressesToAccessListForDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertAccessListForDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *ServerError
}

// Status returns HTTPResponse.Status
func (r UpsertAccessListForDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertAccessListForDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddKeyspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON5XX      *ServerError
}

// Status returns HTTPResponse.Status
func (r AddKeyspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddKeyspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ParkDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON409      *Conflict
	JSON5XX      *ServerError
}

// Status returns HTTPResponse.Status
func (r ParkDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ParkDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON409      *Conflict
	JSON5XX      *ServerError
}

// Status returns HTTPResponse.Status
func (r ResetPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResizeDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON409      *Conflict
	JSON5XX      *ServerError
}

// Status returns HTTPResponse.Status
func (r ResizeDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResizeDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateSecureBundleURLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CredsURL
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON409      *Conflict
	JSON5XX      *ServerError
}

// Status returns HTTPResponse.Status
func (r GenerateSecureBundleURLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateSecureBundleURLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TerminateDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON409      *Conflict
	JSON5XX      *ServerError
}

// Status returns HTTPResponse.Status
func (r TerminateDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TerminateDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnparkDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON409      *Conflict
	JSON5XX      *ServerError
}

// Status returns HTTPResponse.Status
func (r UnparkDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnparkDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *ServerError
}

// Status returns HTTPResponse.Status
func (r GetOrganizationRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddOrganizationRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON409      *Conflict
	JSON500      *ServerError
}

// Status returns HTTPResponse.Status
func (r AddOrganizationRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddOrganizationRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOrganizationRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
	JSON500      *ServerError
}

// Status returns HTTPResponse.Status
func (r DeleteOrganizationRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOrganizationRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *ServerError
}

// Status returns HTTPResponse.Status
func (r GetOrganizationRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *ServerError
}

// Status returns HTTPResponse.Status
func (r UpdateRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOrgUsersResponse
	JSON404      *NotFound
	JSON500      *ServerError
}

// Status returns HTTPResponse.Status
func (r GetOrganizationUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InviteUserToOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *ServerError
}

// Status returns HTTPResponse.Status
func (r InviteUserToOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InviteUserToOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveUserFromOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *ServerError
}

// Status returns HTTPResponse.Status
func (r RemoveUserFromOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveUserFromOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserResponse
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *ServerError
}

// Status returns HTTPResponse.Status
func (r GetOrganizationUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRolesForUserInOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *ServerError
}

// Status returns HTTPResponse.Status
func (r UpdateRolesForUserInOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRolesForUserInOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IdOfTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PulsarClustersResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r IdOfTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IdOfTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPulsarClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantClusterPlansResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetPulsarClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPulsarClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamingTenantsByOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantClusterPlanResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetStreamingTenantsByOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamingTenantsByOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamingProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CloudProviderRegionResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetStreamingProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamingProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTenantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantClusterPlansResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTenantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTenantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IdOfCreateTenantEndpointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantClusterPlanResponse
	JSON401      *ErrorResponse
	JSON409      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r IdOfCreateTenantEndpointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IdOfCreateTenantEndpointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamingTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetStreamingTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamingTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeneantLimitUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetTeneantLimitUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeneantLimitUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStreamingTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteStreamingTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStreamingTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLimitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantLimitResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetLimitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLimitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPulsarTokensByTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TenantToken
}

// Status returns HTTPResponse.Status
func (r GetPulsarTokensByTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPulsarTokensByTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTenantTokenHandlerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateTenantTokenHandlerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTenantTokenHandlerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePulsarTokenByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePulsarTokenByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePulsarTokenByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPulsarTokenByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPulsarTokenByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPulsarTokenByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTenantTokenHandlerV3Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateTenantTokenV3Response
}

// Status returns HTTPResponse.Status
func (r CreateTenantTokenHandlerV3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTenantTokenHandlerV3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// DeleteNamespaceWithResponse request returning *DeleteNamespaceResponse
func (c *ClientWithResponses) DeleteNamespaceWithResponse(ctx context.Context, tenant string, namespace string, params *DeleteNamespaceParams, reqEditors ...RequestEditorFn) (*DeleteNamespaceResponse, error) {
	rsp, err := c.DeleteNamespace(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNamespaceResponse(rsp)
}

// GetNamespaceWithResponse request returning *GetNamespaceResponse
func (c *ClientWithResponses) GetNamespaceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceResponse, error) {
	rsp, err := c.GetNamespace(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceResponse(rsp)
}

// CreateNamespaceWithResponse request returning *CreateNamespaceResponse
func (c *ClientWithResponses) CreateNamespaceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*CreateNamespaceResponse, error) {
	rsp, err := c.CreateNamespace(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNamespaceResponse(rsp)
}

// GetTopicsWithResponse request returning *GetTopicsResponse
func (c *ClientWithResponses) GetTopicsWithResponse(ctx context.Context, tenant string, namespace string, params *GetTopicsParams, reqEditors ...RequestEditorFn) (*GetTopicsResponse, error) {
	rsp, err := c.GetTopics(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTopicsResponse(rsp)
}

// DeleteTopicWithResponse request returning *DeleteTopicResponse
func (c *ClientWithResponses) DeleteTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteTopicParams, reqEditors ...RequestEditorFn) (*DeleteTopicResponse, error) {
	rsp, err := c.DeleteTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTopicResponse(rsp)
}

// CreateTopicWithResponse request returning *CreateTopicResponse
func (c *ClientWithResponses) CreateTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CreateTopicParams, reqEditors ...RequestEditorFn) (*CreateTopicResponse, error) {
	rsp, err := c.CreateTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTopicResponse(rsp)
}

// IdNamespaceStatsTenantWithResponse request returning *IdNamespaceStatsTenantResponse
func (c *ClientWithResponses) IdNamespaceStatsTenantWithResponse(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*IdNamespaceStatsTenantResponse, error) {
	rsp, err := c.IdNamespaceStatsTenant(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIdNamespaceStatsTenantResponse(rsp)
}

// IdNamespaceStatsTenantNamespaceWithResponse request returning *IdNamespaceStatsTenantNamespaceResponse
func (c *ClientWithResponses) IdNamespaceStatsTenantNamespaceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*IdNamespaceStatsTenantNamespaceResponse, error) {
	rsp, err := c.IdNamespaceStatsTenantNamespace(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIdNamespaceStatsTenantNamespaceResponse(rsp)
}

// IdTopicStatsTenantWithResponse request returning *IdTopicStatsTenantResponse
func (c *ClientWithResponses) IdTopicStatsTenantWithResponse(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*IdTopicStatsTenantResponse, error) {
	rsp, err := c.IdTopicStatsTenant(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIdTopicStatsTenantResponse(rsp)
}

// IdTopicStatsTenantNamespaceWithResponse request returning *IdTopicStatsTenantNamespaceResponse
func (c *ClientWithResponses) IdTopicStatsTenantNamespaceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*IdTopicStatsTenantNamespaceResponse, error) {
	rsp, err := c.IdTopicStatsTenantNamespace(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIdTopicStatsTenantNamespaceResponse(rsp)
}

// DeleteCDCWithBodyWithResponse request with arbitrary body returning *DeleteCDCResponse
func (c *ClientWithResponses) DeleteCDCWithBodyWithResponse(ctx context.Context, tenantName string, params *DeleteCDCParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteCDCResponse, error) {
	rsp, err := c.DeleteCDCWithBody(ctx, tenantName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCDCResponse(rsp)
}

func (c *ClientWithResponses) DeleteCDCWithResponse(ctx context.Context, tenantName string, params *DeleteCDCParams, body DeleteCDCJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteCDCResponse, error) {
	rsp, err := c.DeleteCDC(ctx, tenantName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCDCResponse(rsp)
}

// GetCDCWithResponse request returning *GetCDCResponse
func (c *ClientWithResponses) GetCDCWithResponse(ctx context.Context, tenantName string, params *GetCDCParams, reqEditors ...RequestEditorFn) (*GetCDCResponse, error) {
	rsp, err := c.GetCDC(ctx, tenantName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCDCResponse(rsp)
}

// EnableCDCWithBodyWithResponse request with arbitrary body returning *EnableCDCResponse
func (c *ClientWithResponses) EnableCDCWithBodyWithResponse(ctx context.Context, tenantName string, params *EnableCDCParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableCDCResponse, error) {
	rsp, err := c.EnableCDCWithBody(ctx, tenantName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableCDCResponse(rsp)
}

func (c *ClientWithResponses) EnableCDCWithResponse(ctx context.Context, tenantName string, params *EnableCDCParams, body EnableCDCJSONRequestBody, reqEditors ...RequestEditorFn) (*EnableCDCResponse, error) {
	rsp, err := c.EnableCDC(ctx, tenantName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableCDCResponse(rsp)
}

// DeleteSinkWithResponse request returning *DeleteSinkResponse
func (c *ClientWithResponses) DeleteSinkWithResponse(ctx context.Context, tenant string, namespace string, sinkName string, params *DeleteSinkParams, reqEditors ...RequestEditorFn) (*DeleteSinkResponse, error) {
	rsp, err := c.DeleteSink(ctx, tenant, namespace, sinkName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSinkResponse(rsp)
}

// GetSinksWithResponse request returning *GetSinksResponse
func (c *ClientWithResponses) GetSinksWithResponse(ctx context.Context, tenant string, namespace string, sinkName string, params *GetSinksParams, reqEditors ...RequestEditorFn) (*GetSinksResponse, error) {
	rsp, err := c.GetSinks(ctx, tenant, namespace, sinkName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSinksResponse(rsp)
}

// CreateSinkJSONWithBodyWithResponse request with arbitrary body returning *CreateSinkJSONResponse
func (c *ClientWithResponses) CreateSinkJSONWithBodyWithResponse(ctx context.Context, tenant string, namespace string, sinkName string, params *CreateSinkJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSinkJSONResponse, error) {
	rsp, err := c.CreateSinkJSONWithBody(ctx, tenant, namespace, sinkName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSinkJSONResponse(rsp)
}

func (c *ClientWithResponses) CreateSinkJSONWithResponse(ctx context.Context, tenant string, namespace string, sinkName string, params *CreateSinkJSONParams, body CreateSinkJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSinkJSONResponse, error) {
	rsp, err := c.CreateSinkJSON(ctx, tenant, namespace, sinkName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSinkJSONResponse(rsp)
}

// UpdateSinkJSONWithBodyWithResponse request with arbitrary body returning *UpdateSinkJSONResponse
func (c *ClientWithResponses) UpdateSinkJSONWithBodyWithResponse(ctx context.Context, tenant string, namespace string, sinkName string, params *UpdateSinkJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSinkJSONResponse, error) {
	rsp, err := c.UpdateSinkJSONWithBody(ctx, tenant, namespace, sinkName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSinkJSONResponse(rsp)
}

func (c *ClientWithResponses) UpdateSinkJSONWithResponse(ctx context.Context, tenant string, namespace string, sinkName string, params *UpdateSinkJSONParams, body UpdateSinkJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSinkJSONResponse, error) {
	rsp, err := c.UpdateSinkJSON(ctx, tenant, namespace, sinkName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSinkJSONResponse(rsp)
}

// CreateSourceJSONWithBodyWithResponse request with arbitrary body returning *CreateSourceJSONResponse
func (c *ClientWithResponses) CreateSourceJSONWithBodyWithResponse(ctx context.Context, tenant string, namespace string, sourceName string, params *CreateSourceJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSourceJSONResponse, error) {
	rsp, err := c.CreateSourceJSONWithBody(ctx, tenant, namespace, sourceName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSourceJSONResponse(rsp)
}

func (c *ClientWithResponses) CreateSourceJSONWithResponse(ctx context.Context, tenant string, namespace string, sourceName string, params *CreateSourceJSONParams, body CreateSourceJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSourceJSONResponse, error) {
	rsp, err := c.CreateSourceJSON(ctx, tenant, namespace, sourceName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSourceJSONResponse(rsp)
}

// UpdateSourceJSONWithBodyWithResponse request with arbitrary body returning *UpdateSourceJSONResponse
func (c *ClientWithResponses) UpdateSourceJSONWithBodyWithResponse(ctx context.Context, tenant string, namespace string, sourceName string, params *UpdateSourceJSONParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSourceJSONResponse, error) {
	rsp, err := c.UpdateSourceJSONWithBody(ctx, tenant, namespace, sourceName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSourceJSONResponse(rsp)
}

func (c *ClientWithResponses) UpdateSourceJSONWithResponse(ctx context.Context, tenant string, namespace string, sourceName string, params *UpdateSourceJSONParams, body UpdateSourceJSONJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSourceJSONResponse, error) {
	rsp, err := c.UpdateSourceJSON(ctx, tenant, namespace, sourceName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSourceJSONResponse(rsp)
}

// GetBuiltInSinksWithResponse request returning *GetBuiltInSinksResponse
func (c *ClientWithResponses) GetBuiltInSinksWithResponse(ctx context.Context, params *GetBuiltInSinksParams, reqEditors ...RequestEditorFn) (*GetBuiltInSinksResponse, error) {
	rsp, err := c.GetBuiltInSinks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBuiltInSinksResponse(rsp)
}

// GetAccessListTemplateWithResponse request returning *GetAccessListTemplateResponse
func (c *ClientWithResponses) GetAccessListTemplateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAccessListTemplateResponse, error) {
	rsp, err := c.GetAccessListTemplate(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccessListTemplateResponse(rsp)
}

// ValidateAccessListWithResponse request returning *ValidateAccessListResponse
func (c *ClientWithResponses) ValidateAccessListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ValidateAccessListResponse, error) {
	rsp, err := c.ValidateAccessList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateAccessListResponse(rsp)
}

// GetAllAccessListsForOrganizationWithResponse request returning *GetAllAccessListsForOrganizationResponse
func (c *ClientWithResponses) GetAllAccessListsForOrganizationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllAccessListsForOrganizationResponse, error) {
	rsp, err := c.GetAllAccessListsForOrganization(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllAccessListsForOrganizationResponse(rsp)
}

// ListAvailableRegionsWithResponse request returning *ListAvailableRegionsResponse
func (c *ClientWithResponses) ListAvailableRegionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAvailableRegionsResponse, error) {
	rsp, err := c.ListAvailableRegions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAvailableRegionsResponse(rsp)
}

// DeleteTokenForClientWithResponse request returning *DeleteTokenForClientResponse
func (c *ClientWithResponses) DeleteTokenForClientWithResponse(ctx context.Context, clientId ClientIdParam, reqEditors ...RequestEditorFn) (*DeleteTokenForClientResponse, error) {
	rsp, err := c.DeleteTokenForClient(ctx, clientId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTokenForClientResponse(rsp)
}

// GetClientsForOrgWithResponse request returning *GetClientsForOrgResponse
func (c *ClientWithResponses) GetClientsForOrgWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClientsForOrgResponse, error) {
	rsp, err := c.GetClientsForOrg(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientsForOrgResponse(rsp)
}

// GenerateTokenForClientWithBodyWithResponse request with arbitrary body returning *GenerateTokenForClientResponse
func (c *ClientWithResponses) GenerateTokenForClientWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateTokenForClientResponse, error) {
	rsp, err := c.GenerateTokenForClientWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateTokenForClientResponse(rsp)
}

func (c *ClientWithResponses) GenerateTokenForClientWithResponse(ctx context.Context, body GenerateTokenForClientJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateTokenForClientResponse, error) {
	rsp, err := c.GenerateTokenForClient(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateTokenForClientResponse(rsp)
}

// GetCurrentOrganizationWithResponse request returning *GetCurrentOrganizationResponse
func (c *ClientWithResponses) GetCurrentOrganizationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentOrganizationResponse, error) {
	rsp, err := c.GetCurrentOrganization(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentOrganizationResponse(rsp)
}

// ListDatabasesWithResponse request returning *ListDatabasesResponse
func (c *ClientWithResponses) ListDatabasesWithResponse(ctx context.Context, params *ListDatabasesParams, reqEditors ...RequestEditorFn) (*ListDatabasesResponse, error) {
	rsp, err := c.ListDatabases(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDatabasesResponse(rsp)
}

// CreateDatabaseWithBodyWithResponse request with arbitrary body returning *CreateDatabaseResponse
func (c *ClientWithResponses) CreateDatabaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseResponse, error) {
	rsp, err := c.CreateDatabaseWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseResponse(rsp)
}

func (c *ClientWithResponses) CreateDatabaseWithResponse(ctx context.Context, body CreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseResponse, error) {
	rsp, err := c.CreateDatabase(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseResponse(rsp)
}

// GetDatabaseWithResponse request returning *GetDatabaseResponse
func (c *ClientWithResponses) GetDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*GetDatabaseResponse, error) {
	rsp, err := c.GetDatabase(ctx, databaseId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatabaseResponse(rsp)
}

// DeleteAddressesOrAccessListForDatabaseWithResponse request returning *DeleteAddressesOrAccessListForDatabaseResponse
func (c *ClientWithResponses) DeleteAddressesOrAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, params *DeleteAddressesOrAccessListForDatabaseParams, reqEditors ...RequestEditorFn) (*DeleteAddressesOrAccessListForDatabaseResponse, error) {
	rsp, err := c.DeleteAddressesOrAccessListForDatabase(ctx, databaseId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAddressesOrAccessListForDatabaseResponse(rsp)
}

// GetAccessListForDatabaseWithResponse request returning *GetAccessListForDatabaseResponse
func (c *ClientWithResponses) GetAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*GetAccessListForDatabaseResponse, error) {
	rsp, err := c.GetAccessListForDatabase(ctx, databaseId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccessListForDatabaseResponse(rsp)
}

// UpdateAccessListForDatabaseWithBodyWithResponse request with arbitrary body returning *UpdateAccessListForDatabaseResponse
func (c *ClientWithResponses) UpdateAccessListForDatabaseWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccessListForDatabaseResponse, error) {
	rsp, err := c.UpdateAccessListForDatabaseWithBody(ctx, databaseId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccessListForDatabaseResponse(rsp)
}

func (c *ClientWithResponses) UpdateAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, body UpdateAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccessListForDatabaseResponse, error) {
	rsp, err := c.UpdateAccessListForDatabase(ctx, databaseId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccessListForDatabaseResponse(rsp)
}

// AddAddressesToAccessListForDatabaseWithBodyWithResponse request with arbitrary body returning *AddAddressesToAccessListForDatabaseResponse
func (c *ClientWithResponses) AddAddressesToAccessListForDatabaseWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddAddressesToAccessListForDatabaseResponse, error) {
	rsp, err := c.AddAddressesToAccessListForDatabaseWithBody(ctx, databaseId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddAddressesToAccessListForDatabaseResponse(rsp)
}

func (c *ClientWithResponses) AddAddressesToAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, body AddAddressesToAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*AddAddressesToAccessListForDatabaseResponse, error) {
	rsp, err := c.AddAddressesToAccessListForDatabase(ctx, databaseId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddAddressesToAccessListForDatabaseResponse(rsp)
}

// UpsertAccessListForDatabaseWithBodyWithResponse request with arbitrary body returning *UpsertAccessListForDatabaseResponse
func (c *ClientWithResponses) UpsertAccessListForDatabaseWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertAccessListForDatabaseResponse, error) {
	rsp, err := c.UpsertAccessListForDatabaseWithBody(ctx, databaseId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertAccessListForDatabaseResponse(rsp)
}

func (c *ClientWithResponses) UpsertAccessListForDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, body UpsertAccessListForDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertAccessListForDatabaseResponse, error) {
	rsp, err := c.UpsertAccessListForDatabase(ctx, databaseId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertAccessListForDatabaseResponse(rsp)
}

// AddKeyspaceWithResponse request returning *AddKeyspaceResponse
func (c *ClientWithResponses) AddKeyspaceWithResponse(ctx context.Context, databaseId DatabaseIdParam, keyspaceName KeyspaceNameParam, reqEditors ...RequestEditorFn) (*AddKeyspaceResponse, error) {
	rsp, err := c.AddKeyspace(ctx, databaseId, keyspaceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddKeyspaceResponse(rsp)
}

// ParkDatabaseWithResponse request returning *ParkDatabaseResponse
func (c *ClientWithResponses) ParkDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*ParkDatabaseResponse, error) {
	rsp, err := c.ParkDatabase(ctx, databaseId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseParkDatabaseResponse(rsp)
}

// ResetPasswordWithBodyWithResponse request with arbitrary body returning *ResetPasswordResponse
func (c *ClientWithResponses) ResetPasswordWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error) {
	rsp, err := c.ResetPasswordWithBody(ctx, databaseId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPasswordResponse(rsp)
}

func (c *ClientWithResponses) ResetPasswordWithResponse(ctx context.Context, databaseId DatabaseIdParam, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error) {
	rsp, err := c.ResetPassword(ctx, databaseId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPasswordResponse(rsp)
}

// ResizeDatabaseWithBodyWithResponse request with arbitrary body returning *ResizeDatabaseResponse
func (c *ClientWithResponses) ResizeDatabaseWithBodyWithResponse(ctx context.Context, databaseId DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResizeDatabaseResponse, error) {
	rsp, err := c.ResizeDatabaseWithBody(ctx, databaseId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResizeDatabaseResponse(rsp)
}

func (c *ClientWithResponses) ResizeDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, body ResizeDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*ResizeDatabaseResponse, error) {
	rsp, err := c.ResizeDatabase(ctx, databaseId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResizeDatabaseResponse(rsp)
}

// GenerateSecureBundleURLWithResponse request returning *GenerateSecureBundleURLResponse
func (c *ClientWithResponses) GenerateSecureBundleURLWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*GenerateSecureBundleURLResponse, error) {
	rsp, err := c.GenerateSecureBundleURL(ctx, databaseId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateSecureBundleURLResponse(rsp)
}

// TerminateDatabaseWithResponse request returning *TerminateDatabaseResponse
func (c *ClientWithResponses) TerminateDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, params *TerminateDatabaseParams, reqEditors ...RequestEditorFn) (*TerminateDatabaseResponse, error) {
	rsp, err := c.TerminateDatabase(ctx, databaseId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTerminateDatabaseResponse(rsp)
}

// UnparkDatabaseWithResponse request returning *UnparkDatabaseResponse
func (c *ClientWithResponses) UnparkDatabaseWithResponse(ctx context.Context, databaseId DatabaseIdParam, reqEditors ...RequestEditorFn) (*UnparkDatabaseResponse, error) {
	rsp, err := c.UnparkDatabase(ctx, databaseId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnparkDatabaseResponse(rsp)
}

// GetOrganizationRolesWithResponse request returning *GetOrganizationRolesResponse
func (c *ClientWithResponses) GetOrganizationRolesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOrganizationRolesResponse, error) {
	rsp, err := c.GetOrganizationRoles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationRolesResponse(rsp)
}

// AddOrganizationRoleWithBodyWithResponse request with arbitrary body returning *AddOrganizationRoleResponse
func (c *ClientWithResponses) AddOrganizationRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrganizationRoleResponse, error) {
	rsp, err := c.AddOrganizationRoleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrganizationRoleResponse(rsp)
}

func (c *ClientWithResponses) AddOrganizationRoleWithResponse(ctx context.Context, body AddOrganizationRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrganizationRoleResponse, error) {
	rsp, err := c.AddOrganizationRole(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrganizationRoleResponse(rsp)
}

// DeleteOrganizationRoleWithResponse request returning *DeleteOrganizationRoleResponse
func (c *ClientWithResponses) DeleteOrganizationRoleWithResponse(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*DeleteOrganizationRoleResponse, error) {
	rsp, err := c.DeleteOrganizationRole(ctx, roleID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOrganizationRoleResponse(rsp)
}

// GetOrganizationRoleWithResponse request returning *GetOrganizationRoleResponse
func (c *ClientWithResponses) GetOrganizationRoleWithResponse(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*GetOrganizationRoleResponse, error) {
	rsp, err := c.GetOrganizationRole(ctx, roleID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationRoleResponse(rsp)
}

// UpdateRoleWithBodyWithResponse request with arbitrary body returning *UpdateRoleResponse
func (c *ClientWithResponses) UpdateRoleWithBodyWithResponse(ctx context.Context, roleID RoleIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error) {
	rsp, err := c.UpdateRoleWithBody(ctx, roleID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleResponse(rsp)
}

func (c *ClientWithResponses) UpdateRoleWithResponse(ctx context.Context, roleID RoleIdParam, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error) {
	rsp, err := c.UpdateRole(ctx, roleID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleResponse(rsp)
}

// GetOrganizationUsersWithResponse request returning *GetOrganizationUsersResponse
func (c *ClientWithResponses) GetOrganizationUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOrganizationUsersResponse, error) {
	rsp, err := c.GetOrganizationUsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationUsersResponse(rsp)
}

// InviteUserToOrganizationWithBodyWithResponse request with arbitrary body returning *InviteUserToOrganizationResponse
func (c *ClientWithResponses) InviteUserToOrganizationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteUserToOrganizationResponse, error) {
	rsp, err := c.InviteUserToOrganizationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteUserToOrganizationResponse(rsp)
}

func (c *ClientWithResponses) InviteUserToOrganizationWithResponse(ctx context.Context, body InviteUserToOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteUserToOrganizationResponse, error) {
	rsp, err := c.InviteUserToOrganization(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteUserToOrganizationResponse(rsp)
}

// RemoveUserFromOrganizationWithResponse request returning *RemoveUserFromOrganizationResponse
func (c *ClientWithResponses) RemoveUserFromOrganizationWithResponse(ctx context.Context, userID UserIdParam, reqEditors ...RequestEditorFn) (*RemoveUserFromOrganizationResponse, error) {
	rsp, err := c.RemoveUserFromOrganization(ctx, userID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUserFromOrganizationResponse(rsp)
}

// GetOrganizationUserWithResponse request returning *GetOrganizationUserResponse
func (c *ClientWithResponses) GetOrganizationUserWithResponse(ctx context.Context, userID UserIdParam, reqEditors ...RequestEditorFn) (*GetOrganizationUserResponse, error) {
	rsp, err := c.GetOrganizationUser(ctx, userID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationUserResponse(rsp)
}

// UpdateRolesForUserInOrganizationWithBodyWithResponse request with arbitrary body returning *UpdateRolesForUserInOrganizationResponse
func (c *ClientWithResponses) UpdateRolesForUserInOrganizationWithBodyWithResponse(ctx context.Context, userID UserIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRolesForUserInOrganizationResponse, error) {
	rsp, err := c.UpdateRolesForUserInOrganizationWithBody(ctx, userID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRolesForUserInOrganizationResponse(rsp)
}

func (c *ClientWithResponses) UpdateRolesForUserInOrganizationWithResponse(ctx context.Context, userID UserIdParam, body UpdateRolesForUserInOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRolesForUserInOrganizationResponse, error) {
	rsp, err := c.UpdateRolesForUserInOrganization(ctx, userID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRolesForUserInOrganizationResponse(rsp)
}

// IdOfTenantWithResponse request returning *IdOfTenantResponse
func (c *ClientWithResponses) IdOfTenantWithResponse(ctx context.Context, params *IdOfTenantParams, reqEditors ...RequestEditorFn) (*IdOfTenantResponse, error) {
	rsp, err := c.IdOfTenant(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIdOfTenantResponse(rsp)
}

// GetPulsarClustersWithResponse request returning *GetPulsarClustersResponse
func (c *ClientWithResponses) GetPulsarClustersWithResponse(ctx context.Context, org string, reqEditors ...RequestEditorFn) (*GetPulsarClustersResponse, error) {
	rsp, err := c.GetPulsarClusters(ctx, org, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPulsarClustersResponse(rsp)
}

// GetStreamingTenantsByOrgWithResponse request returning *GetStreamingTenantsByOrgResponse
func (c *ClientWithResponses) GetStreamingTenantsByOrgWithResponse(ctx context.Context, org string, tenant string, reqEditors ...RequestEditorFn) (*GetStreamingTenantsByOrgResponse, error) {
	rsp, err := c.GetStreamingTenantsByOrg(ctx, org, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamingTenantsByOrgResponse(rsp)
}

// GetStreamingProvidersWithResponse request returning *GetStreamingProvidersResponse
func (c *ClientWithResponses) GetStreamingProvidersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStreamingProvidersResponse, error) {
	rsp, err := c.GetStreamingProviders(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamingProvidersResponse(rsp)
}

// GetTenantsWithResponse request returning *GetTenantsResponse
func (c *ClientWithResponses) GetTenantsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTenantsResponse, error) {
	rsp, err := c.GetTenants(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTenantsResponse(rsp)
}

// IdOfCreateTenantEndpointWithBodyWithResponse request with arbitrary body returning *IdOfCreateTenantEndpointResponse
func (c *ClientWithResponses) IdOfCreateTenantEndpointWithBodyWithResponse(ctx context.Context, params *IdOfCreateTenantEndpointParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IdOfCreateTenantEndpointResponse, error) {
	rsp, err := c.IdOfCreateTenantEndpointWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIdOfCreateTenantEndpointResponse(rsp)
}

func (c *ClientWithResponses) IdOfCreateTenantEndpointWithResponse(ctx context.Context, params *IdOfCreateTenantEndpointParams, body IdOfCreateTenantEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*IdOfCreateTenantEndpointResponse, error) {
	rsp, err := c.IdOfCreateTenantEndpoint(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIdOfCreateTenantEndpointResponse(rsp)
}

// GetStreamingTenantWithResponse request returning *GetStreamingTenantResponse
func (c *ClientWithResponses) GetStreamingTenantWithResponse(ctx context.Context, tenant string, params *GetStreamingTenantParams, reqEditors ...RequestEditorFn) (*GetStreamingTenantResponse, error) {
	rsp, err := c.GetStreamingTenant(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamingTenantResponse(rsp)
}

// GetTeneantLimitUsageWithResponse request returning *GetTeneantLimitUsageResponse
func (c *ClientWithResponses) GetTeneantLimitUsageWithResponse(ctx context.Context, tenant string, params *GetTeneantLimitUsageParams, reqEditors ...RequestEditorFn) (*GetTeneantLimitUsageResponse, error) {
	rsp, err := c.GetTeneantLimitUsage(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeneantLimitUsageResponse(rsp)
}

// DeleteStreamingTenantWithResponse request returning *DeleteStreamingTenantResponse
func (c *ClientWithResponses) DeleteStreamingTenantWithResponse(ctx context.Context, tenant string, cluster string, params *DeleteStreamingTenantParams, reqEditors ...RequestEditorFn) (*DeleteStreamingTenantResponse, error) {
	rsp, err := c.DeleteStreamingTenant(ctx, tenant, cluster, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStreamingTenantResponse(rsp)
}

// GetLimitsWithResponse request returning *GetLimitsResponse
func (c *ClientWithResponses) GetLimitsWithResponse(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*GetLimitsResponse, error) {
	rsp, err := c.GetLimits(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLimitsResponse(rsp)
}

// GetPulsarTokensByTenantWithResponse request returning *GetPulsarTokensByTenantResponse
func (c *ClientWithResponses) GetPulsarTokensByTenantWithResponse(ctx context.Context, tenant string, params *GetPulsarTokensByTenantParams, reqEditors ...RequestEditorFn) (*GetPulsarTokensByTenantResponse, error) {
	rsp, err := c.GetPulsarTokensByTenant(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPulsarTokensByTenantResponse(rsp)
}

// CreateTenantTokenHandlerWithResponse request returning *CreateTenantTokenHandlerResponse
func (c *ClientWithResponses) CreateTenantTokenHandlerWithResponse(ctx context.Context, tenant string, params *CreateTenantTokenHandlerParams, reqEditors ...RequestEditorFn) (*CreateTenantTokenHandlerResponse, error) {
	rsp, err := c.CreateTenantTokenHandler(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTenantTokenHandlerResponse(rsp)
}

// DeletePulsarTokenByIDWithResponse request returning *DeletePulsarTokenByIDResponse
func (c *ClientWithResponses) DeletePulsarTokenByIDWithResponse(ctx context.Context, tenant string, tokenID string, params *DeletePulsarTokenByIDParams, reqEditors ...RequestEditorFn) (*DeletePulsarTokenByIDResponse, error) {
	rsp, err := c.DeletePulsarTokenByID(ctx, tenant, tokenID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePulsarTokenByIDResponse(rsp)
}

// GetPulsarTokenByIDWithResponse request returning *GetPulsarTokenByIDResponse
func (c *ClientWithResponses) GetPulsarTokenByIDWithResponse(ctx context.Context, tenant string, tokenID string, params *GetPulsarTokenByIDParams, reqEditors ...RequestEditorFn) (*GetPulsarTokenByIDResponse, error) {
	rsp, err := c.GetPulsarTokenByID(ctx, tenant, tokenID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPulsarTokenByIDResponse(rsp)
}

// CreateTenantTokenHandlerV3WithBodyWithResponse request with arbitrary body returning *CreateTenantTokenHandlerV3Response
func (c *ClientWithResponses) CreateTenantTokenHandlerV3WithBodyWithResponse(ctx context.Context, tenant string, params *CreateTenantTokenHandlerV3Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTenantTokenHandlerV3Response, error) {
	rsp, err := c.CreateTenantTokenHandlerV3WithBody(ctx, tenant, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTenantTokenHandlerV3Response(rsp)
}

func (c *ClientWithResponses) CreateTenantTokenHandlerV3WithResponse(ctx context.Context, tenant string, params *CreateTenantTokenHandlerV3Params, body CreateTenantTokenHandlerV3JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTenantTokenHandlerV3Response, error) {
	rsp, err := c.CreateTenantTokenHandlerV3(ctx, tenant, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTenantTokenHandlerV3Response(rsp)
}

// ParseDeleteNamespaceResponse parses an HTTP response from a DeleteNamespaceWithResponse call
func ParseDeleteNamespaceResponse(rsp *http.Response) (*DeleteNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceResponse parses an HTTP response from a GetNamespaceWithResponse call
func ParseGetNamespaceResponse(rsp *http.Response) (*GetNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateNamespaceResponse parses an HTTP response from a CreateNamespaceWithResponse call
func ParseCreateNamespaceResponse(rsp *http.Response) (*CreateNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTopicsResponse parses an HTTP response from a GetTopicsWithResponse call
func ParseGetTopicsResponse(rsp *http.Response) (*GetTopicsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTopicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteTopicResponse parses an HTTP response from a DeleteTopicWithResponse call
func ParseDeleteTopicResponse(rsp *http.Response) (*DeleteTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateTopicResponse parses an HTTP response from a CreateTopicWithResponse call
func ParseCreateTopicResponse(rsp *http.Response) (*CreateTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseIdNamespaceStatsTenantResponse parses an HTTP response from a IdNamespaceStatsTenantWithResponse call
func ParseIdNamespaceStatsTenantResponse(rsp *http.Response) (*IdNamespaceStatsTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IdNamespaceStatsTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIdNamespaceStatsTenantNamespaceResponse parses an HTTP response from a IdNamespaceStatsTenantNamespaceWithResponse call
func ParseIdNamespaceStatsTenantNamespaceResponse(rsp *http.Response) (*IdNamespaceStatsTenantNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IdNamespaceStatsTenantNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIdTopicStatsTenantResponse parses an HTTP response from a IdTopicStatsTenantWithResponse call
func ParseIdTopicStatsTenantResponse(rsp *http.Response) (*IdTopicStatsTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IdTopicStatsTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIdTopicStatsTenantNamespaceResponse parses an HTTP response from a IdTopicStatsTenantNamespaceWithResponse call
func ParseIdTopicStatsTenantNamespaceResponse(rsp *http.Response) (*IdTopicStatsTenantNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IdTopicStatsTenantNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCDCResponse parses an HTTP response from a DeleteCDCWithResponse call
func ParseDeleteCDCResponse(rsp *http.Response) (*DeleteCDCResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCDCResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreatedTenantResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCDCResponse parses an HTTP response from a GetCDCWithResponse call
func ParseGetCDCResponse(rsp *http.Response) (*GetCDCResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCDCResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreatedTenantResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEnableCDCResponse parses an HTTP response from a EnableCDCWithResponse call
func ParseEnableCDCResponse(rsp *http.Response) (*EnableCDCResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnableCDCResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreatedTenantResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSinkResponse parses an HTTP response from a DeleteSinkWithResponse call
func ParseDeleteSinkResponse(rsp *http.Response) (*DeleteSinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSinksResponse parses an HTTP response from a GetSinksWithResponse call
func ParseGetSinksResponse(rsp *http.Response) (*GetSinksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateSinkJSONResponse parses an HTTP response from a CreateSinkJSONWithResponse call
func ParseCreateSinkJSONResponse(rsp *http.Response) (*CreateSinkJSONResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSinkJSONResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSinkJSONResponse parses an HTTP response from a UpdateSinkJSONWithResponse call
func ParseUpdateSinkJSONResponse(rsp *http.Response) (*UpdateSinkJSONResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSinkJSONResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateSourceJSONResponse parses an HTTP response from a CreateSourceJSONWithResponse call
func ParseCreateSourceJSONResponse(rsp *http.Response) (*CreateSourceJSONResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSourceJSONResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSourceJSONResponse parses an HTTP response from a UpdateSourceJSONWithResponse call
func ParseUpdateSourceJSONResponse(rsp *http.Response) (*UpdateSourceJSONResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSourceJSONResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBuiltInSinksResponse parses an HTTP response from a GetBuiltInSinksWithResponse call
func ParseGetBuiltInSinksResponse(rsp *http.Response) (*GetBuiltInSinksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBuiltInSinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAccessListTemplateResponse parses an HTTP response from a GetAccessListTemplateWithResponse call
func ParseGetAccessListTemplateResponse(rsp *http.Response) (*GetAccessListTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccessListTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccessListRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseValidateAccessListResponse parses an HTTP response from a ValidateAccessListWithResponse call
func ParseValidateAccessListResponse(rsp *http.Response) (*ValidateAccessListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateAccessListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ValidationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAllAccessListsForOrganizationResponse parses an HTTP response from a GetAllAccessListsForOrganizationWithResponse call
func ParseGetAllAccessListsForOrganizationResponse(rsp *http.Response) (*GetAllAccessListsForOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllAccessListsForOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AccessListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAvailableRegionsResponse parses an HTTP response from a ListAvailableRegionsWithResponse call
func ParseListAvailableRegionsResponse(rsp *http.Response) (*ListAvailableRegionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAvailableRegionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AvailableRegionCombination
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseDeleteTokenForClientResponse parses an HTTP response from a DeleteTokenForClientWithResponse call
func ParseDeleteTokenForClientResponse(rsp *http.Response) (*DeleteTokenForClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTokenForClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClientsForOrgResponse parses an HTTP response from a GetClientsForOrgWithResponse call
func ParseGetClientsForOrgResponse(rsp *http.Response) (*GetClientsForOrgResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientsForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGenerateTokenForClientResponse parses an HTTP response from a GenerateTokenForClientWithResponse call
func ParseGenerateTokenForClientResponse(rsp *http.Response) (*GenerateTokenForClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateTokenForClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCurrentOrganizationResponse parses an HTTP response from a GetCurrentOrganizationWithResponse call
func ParseGetCurrentOrganizationResponse(rsp *http.Response) (*GetCurrentOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListDatabasesResponse parses an HTTP response from a ListDatabasesWithResponse call
func ParseListDatabasesResponse(rsp *http.Response) (*ListDatabasesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDatabasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Database
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseCreateDatabaseResponse parses an HTTP response from a CreateDatabaseWithResponse call
func ParseCreateDatabaseResponse(rsp *http.Response) (*CreateDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDatabaseResponse parses an HTTP response from a GetDatabaseWithResponse call
func ParseGetDatabaseResponse(rsp *http.Response) (*GetDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Database
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseDeleteAddressesOrAccessListForDatabaseResponse parses an HTTP response from a DeleteAddressesOrAccessListForDatabaseWithResponse call
func ParseDeleteAddressesOrAccessListForDatabaseResponse(rsp *http.Response) (*DeleteAddressesOrAccessListForDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAddressesOrAccessListForDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAccessListForDatabaseResponse parses an HTTP response from a GetAccessListForDatabaseWithResponse call
func ParseGetAccessListForDatabaseResponse(rsp *http.Response) (*GetAccessListForDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccessListForDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccessListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAccessListForDatabaseResponse parses an HTTP response from a UpdateAccessListForDatabaseWithResponse call
func ParseUpdateAccessListForDatabaseResponse(rsp *http.Response) (*UpdateAccessListForDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAccessListForDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddAddressesToAccessListForDatabaseResponse parses an HTTP response from a AddAddressesToAccessListForDatabaseWithResponse call
func ParseAddAddressesToAccessListForDatabaseResponse(rsp *http.Response) (*AddAddressesToAccessListForDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddAddressesToAccessListForDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpsertAccessListForDatabaseResponse parses an HTTP response from a UpsertAccessListForDatabaseWithResponse call
func ParseUpsertAccessListForDatabaseResponse(rsp *http.Response) (*UpsertAccessListForDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertAccessListForDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddKeyspaceResponse parses an HTTP response from a AddKeyspaceWithResponse call
func ParseAddKeyspaceResponse(rsp *http.Response) (*AddKeyspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddKeyspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseParkDatabaseResponse parses an HTTP response from a ParkDatabaseWithResponse call
func ParseParkDatabaseResponse(rsp *http.Response) (*ParkDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ParkDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseResetPasswordResponse parses an HTTP response from a ResetPasswordWithResponse call
func ParseResetPasswordResponse(rsp *http.Response) (*ResetPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseResizeDatabaseResponse parses an HTTP response from a ResizeDatabaseWithResponse call
func ParseResizeDatabaseResponse(rsp *http.Response) (*ResizeDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResizeDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGenerateSecureBundleURLResponse parses an HTTP response from a GenerateSecureBundleURLWithResponse call
func ParseGenerateSecureBundleURLResponse(rsp *http.Response) (*GenerateSecureBundleURLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateSecureBundleURLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CredsURL
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseTerminateDatabaseResponse parses an HTTP response from a TerminateDatabaseWithResponse call
func ParseTerminateDatabaseResponse(rsp *http.Response) (*TerminateDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TerminateDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseUnparkDatabaseResponse parses an HTTP response from a UnparkDatabaseWithResponse call
func ParseUnparkDatabaseResponse(rsp *http.Response) (*UnparkDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnparkDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetOrganizationRolesResponse parses an HTTP response from a GetOrganizationRolesWithResponse call
func ParseGetOrganizationRolesResponse(rsp *http.Response) (*GetOrganizationRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddOrganizationRoleResponse parses an HTTP response from a AddOrganizationRoleWithResponse call
func ParseAddOrganizationRoleResponse(rsp *http.Response) (*AddOrganizationRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddOrganizationRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteOrganizationRoleResponse parses an HTTP response from a DeleteOrganizationRoleWithResponse call
func ParseDeleteOrganizationRoleResponse(rsp *http.Response) (*DeleteOrganizationRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOrganizationRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOrganizationRoleResponse parses an HTTP response from a GetOrganizationRoleWithResponse call
func ParseGetOrganizationRoleResponse(rsp *http.Response) (*GetOrganizationRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRoleResponse parses an HTTP response from a UpdateRoleWithResponse call
func ParseUpdateRoleResponse(rsp *http.Response) (*UpdateRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOrganizationUsersResponse parses an HTTP response from a GetOrganizationUsersWithResponse call
func ParseGetOrganizationUsersResponse(rsp *http.Response) (*GetOrganizationUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOrgUsersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInviteUserToOrganizationResponse parses an HTTP response from a InviteUserToOrganizationWithResponse call
func ParseInviteUserToOrganizationResponse(rsp *http.Response) (*InviteUserToOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InviteUserToOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRemoveUserFromOrganizationResponse parses an HTTP response from a RemoveUserFromOrganizationWithResponse call
func ParseRemoveUserFromOrganizationResponse(rsp *http.Response) (*RemoveUserFromOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveUserFromOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOrganizationUserResponse parses an HTTP response from a GetOrganizationUserWithResponse call
func ParseGetOrganizationUserResponse(rsp *http.Response) (*GetOrganizationUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRolesForUserInOrganizationResponse parses an HTTP response from a UpdateRolesForUserInOrganizationWithResponse call
func ParseUpdateRolesForUserInOrganizationResponse(rsp *http.Response) (*UpdateRolesForUserInOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRolesForUserInOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIdOfTenantResponse parses an HTTP response from a IdOfTenantWithResponse call
func ParseIdOfTenantResponse(rsp *http.Response) (*IdOfTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IdOfTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PulsarClustersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPulsarClustersResponse parses an HTTP response from a GetPulsarClustersWithResponse call
func ParseGetPulsarClustersResponse(rsp *http.Response) (*GetPulsarClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPulsarClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantClusterPlansResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetStreamingTenantsByOrgResponse parses an HTTP response from a GetStreamingTenantsByOrgWithResponse call
func ParseGetStreamingTenantsByOrgResponse(rsp *http.Response) (*GetStreamingTenantsByOrgResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamingTenantsByOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantClusterPlanResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetStreamingProvidersResponse parses an HTTP response from a GetStreamingProvidersWithResponse call
func ParseGetStreamingProvidersResponse(rsp *http.Response) (*GetStreamingProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamingProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CloudProviderRegionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTenantsResponse parses an HTTP response from a GetTenantsWithResponse call
func ParseGetTenantsResponse(rsp *http.Response) (*GetTenantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTenantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantClusterPlansResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIdOfCreateTenantEndpointResponse parses an HTTP response from a IdOfCreateTenantEndpointWithResponse call
func ParseIdOfCreateTenantEndpointResponse(rsp *http.Response) (*IdOfCreateTenantEndpointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IdOfCreateTenantEndpointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantClusterPlanResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetStreamingTenantResponse parses an HTTP response from a GetStreamingTenantWithResponse call
func ParseGetStreamingTenantResponse(rsp *http.Response) (*GetStreamingTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamingTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTeneantLimitUsageResponse parses an HTTP response from a GetTeneantLimitUsageWithResponse call
func ParseGetTeneantLimitUsageResponse(rsp *http.Response) (*GetTeneantLimitUsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeneantLimitUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteStreamingTenantResponse parses an HTTP response from a DeleteStreamingTenantWithResponse call
func ParseDeleteStreamingTenantResponse(rsp *http.Response) (*DeleteStreamingTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStreamingTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLimitsResponse parses an HTTP response from a GetLimitsWithResponse call
func ParseGetLimitsResponse(rsp *http.Response) (*GetLimitsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLimitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantLimitResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPulsarTokensByTenantResponse parses an HTTP response from a GetPulsarTokensByTenantWithResponse call
func ParseGetPulsarTokensByTenantResponse(rsp *http.Response) (*GetPulsarTokensByTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPulsarTokensByTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TenantToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateTenantTokenHandlerResponse parses an HTTP response from a CreateTenantTokenHandlerWithResponse call
func ParseCreateTenantTokenHandlerResponse(rsp *http.Response) (*CreateTenantTokenHandlerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTenantTokenHandlerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeletePulsarTokenByIDResponse parses an HTTP response from a DeletePulsarTokenByIDWithResponse call
func ParseDeletePulsarTokenByIDResponse(rsp *http.Response) (*DeletePulsarTokenByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePulsarTokenByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPulsarTokenByIDResponse parses an HTTP response from a GetPulsarTokenByIDWithResponse call
func ParseGetPulsarTokenByIDResponse(rsp *http.Response) (*GetPulsarTokenByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPulsarTokenByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateTenantTokenHandlerV3Response parses an HTTP response from a CreateTenantTokenHandlerV3WithResponse call
func ParseCreateTenantTokenHandlerV3Response(rsp *http.Response) (*CreateTenantTokenHandlerV3Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTenantTokenHandlerV3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateTenantTokenV3Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}
